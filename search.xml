<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>事务是什么</title>
      <link href="/archives/947b043e.html"/>
      <url>/archives/947b043e.html</url>
      
        <content type="html"><![CDATA[<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>在数据系统的残酷现实中，很多事情都可能出错：</p><ul><li>数据库软件、硬件可能在任意时刻发生故障（包括写操作进行到一半时）。</li><li>应用程序可能在任意时刻崩溃（包括一系列操作的中间）。</li><li>网络中断可能会意外切断数据库与应用的连接，或数据库之间的连接。</li><li>多个客戶端可能会同时写入数据库，覆盖彼此的更改。</li><li>客戶端可能读取到无意义的数据，因为数据只更新了一部分。</li><li>客戶端之间的竞争条件可能导致令人惊讶的错误。</li></ul><p>为了实现可靠性，系统必须处理这些故障，确保它们不会导致整个系统的灾难性故障。但是实现容错机制工作量巨大。需要仔细考虑所有可能出错的事情，并进行大量的测试，以确保解决方案真正管用。</p><p>数十年来， <strong>事务（transaction）</strong> 一直是简化这些问题的首选机制。事务是应用程序将多个读写操作组合成一个逻辑单元的一种方式。从概念上讲，事务中的所有读写操作被视作单个操作来执行：整个事务要么成功 <strong>提交</strong> （commit），要么失败 <strong>中止</strong> （abort）或 <strong>回滚</strong> （rollback）。如果失败，应用程序可以安全地重试。对于事务来说，应用程序的错误处理变得简单多了，因为它不用再担心部分失败的情况了，即某些操作成功，某些失败（无论出于何种原因）。</p><p>和事务打交道时间⻓了，你可能会觉得它显而易⻅。但我们不应将其视为理所当然。事务不是天然存在的；它们是为了 <strong>简化应用编程模型</strong> 而创建的。通过使用事务，应用程序可以自由地忽略某些潜在的错误情况和并发问题，因为数据库会替应用处理好这些。（我们称之为 <strong>安全保证</strong> ，即safety guarantees）。</p><p>并不是所有的应用都需要事务，有时候弱化事务保证、或完全放弃事务也是有好处的（例如，为了获得更高性能或更高可用性）。一些安全属性也可以在没有事务的情况下实现。</p><p>怎样知道你是否需要事务？为了回答这个问题，首先需要确切理解事务可以提供的安全保障，以及它们的代价。尽管乍看事务似乎很简单，但实际上有许多微妙但重要的细节在起作用。</p><h3 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h3><p>现今，几乎所有的关系型数据库和一些非关系数据库都支持 <strong>事务</strong> 。其中大多数遵循IBMSystemR（第一个SQL数据库）在1975年引入的⻛格【1,2,3】。40年里，尽管一些实现细节发生了变化，但总体思路大同小异：MySQL、PostgreSQL、Oracle和SQLServer等数据库中的事务支持与SystemR异 乎寻常地相似。</p><p>2000年以后，非关系（NoSQL）数据库开始普及。它们的目标是在关系数据库的现状基础上，通过提供新的数据模型选择并默认包含复制和分区来进一步提升。事务是这次运动的主要牺牲品：这些新一代数据库中的许多数据库完全放弃了事务，或者重新定义了这个词，描述比以前所理解的更弱得多的一套保证。</p><p>随着这种新型分布式数据库的炒作，人们普遍认为事务是可伸缩性的对立面，任何大型系统都必须放弃事务以保持良好的性能和高可用性。另一方面，数据库厂商有时将事务保证作为“重要应用”和“有价值数据”的基本要求。这两种观点都是 <strong>纯粹的夸张</strong> 。</p><p>事实并非如此简单：与其他技术设计选择一样，事务有其优势和局限性。为了理解这些权衡，让我们了解事务所提供保证的细节⸺无论是在正常运行中还是在各种极端（但是现实存在）的情况下。</p>]]></content>
      
      
      <categories>
          
          <category> Java知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据一致性</title>
      <link href="/archives/cced2ad1.html"/>
      <url>/archives/cced2ad1.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><p>复制意味着在通过网络连接的多台机器上保留相同数据的副本。我们希望能复制数据，可能出于各种各样的原因：</p><ul><li>使得数据与用戶在地理上接近（从而减少延迟）</li><li>即使系统的一部分出现故障，系统也能继续工作（从而提高可用性）</li><li>伸缩可以接受读请求的机器数量（从而提高读取吞吐量）</li></ul><p>本章将假设你的数据集非常小，每台机器都可以保存整个数据集的副本。后续章节中将放宽这个假设，讨论对单个机器来说太大的数据集的分割（分片）。我们将讨论复制数据系统中可能发生的各种故障，以及如何处理这些故障。</p><p>如果复制中的数据不会随时间而改变，那复制就很简单：将数据复制到每个节点一次就万事大吉。复制的困难之处在于处理复制数据的 <strong>变更（change）</strong> ，这就是本章所要讲的。我们将讨论三种流行的变更复制算法： <strong>单领导者（singleleader，单主）</strong> ， <strong>多领导者（multileader，多主）</strong> 和 <strong>无领导者（leaderless，无主）</strong> 。几乎所有分布式数据库都使用这三种方法之一。</p><p>在复制时需要进行许多权衡：例如，使用同步复制还是异步复制？如何处理失败的副本？这些通常是数据库中的配置选项，细节因数据库而异，但原理在许多不同的实现中都类似。本章会讨论这些决策的后果。</p><p>数据库的复制算得上是老生常谈了⸺70年代研究得出的基本原则至今没有太大变化，因为网络的基本约束仍保持不变。然而在研究之外，许多开发人员仍然假设一个数据库只有一个节点。分布式数据库变为主流只是最近发生的事。许多程序员都是这一领域的新手，因此对于诸如 <strong>最终一致性 （eventualconsistency）</strong> 等问题存在许多误解。在“复制延迟问题”一节，我们将更加精确地了解最终一致性，并讨论诸如 <strong>读己之写（read-your-writes）</strong> 和 <strong>单调读（monotonicread）</strong> 等内容。</p><h3 id="副本中的领导者与追随者"><a href="#副本中的领导者与追随者" class="headerlink" title="副本中的领导者与追随者"></a>副本中的领导者与追随者</h3><p>存储了数据库拷⻉的每个节点被称为 <strong>副本（replica）</strong> 。当存在多个副本时，会不可避免的出现一个问题：如何确保所有数据都落在了所有的副本上？</p><p>每一次向数据库的写入操作都需要传播到所有副本上，否则副本就会包含不一样的数据。最常⻅的解决方案被称为 <strong>基于领导者的复制（leader-basedreplication）</strong> （也称 <strong>主动&#x2F;被动 （active&#x2F;passive）</strong> 复制或 <strong>主&#x2F;从（master&#x2F;slave）</strong> 复制），如图5-1所示。它的工作原理如下：</p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906210053.png"><br>（图5.1）基于领导者的（主&#x2F;从）复制</p><ol><li>其中一个副本被指定为 领导者（leader） ，也称为 主库（master|primary） 。当客戶端要向数据库写入时，它必须将请求发送给该 领导者 ，其会将新数据写入其本地存储。</li><li>其他副本被称为 追随者（followers） ，亦称为 只读副本（readreplicas） 、 从库（slaves） 、备库（secondaries） 或 热备（hot-standby） 。每当领导者将新数据写入本地存储时，它也会 将数据变更发送给所有的追随者，称之为 复制日志（replicationlog） 或 变更流（changestream） 。每个跟随者从领导者拉取日志，并相应更新其本地数据库副本，方法是按照与领导者相同的处理顺序来进行所有写入。</li><li>当客戶想要从数据库中读取数据时，它可以向领导者或任一追随者进行查询。但只有领导者才能接受写入操作（从客戶端的⻆度来看从库都是只读的）。</li></ol><p>这种复制模式是许多关系数据库的内置功能，如PostgreSQL（从9.0版本开始）、MySQL、Oracle DataGuard【 2 】和SQLServer的AlwaysOn可用性组【 3 】。它也被用于一些非关系数据库，包括MongoDB、RethinkDB和Espresso【 4 】。最后，基于领导者的复制并不仅限于数据库：像Kafka<br>【 5 】和RabbitMQ高可用队列【 6 】这样的分布式消息代理也使用它。某些网络文件系统，例如DRBD这样的块复制设备也与之类似。</p><h3 id="同步复制与异步复制"><a href="#同步复制与异步复制" class="headerlink" title="同步复制与异步复制"></a>同步复制与异步复制</h3><p>复制系统的一个重要细节是：复制是 <strong>同步（synchronously）</strong> 发生的还是 <strong>异步（asynchronously）</strong>发生的。（在关系型数据库中这通常是一个配置项，其他系统则通常硬编码为其中一个）。</p><p>想象一下图5-1中发生的场景，即网站的用戶更新他们的个人头像。在某个时间点，客戶向主库发送更新请求；不久之后主库就收到了请求。在某个时间点，主库又会将数据变更转发给自己的从库。最终，主库通知客戶更新成功。</p><p>图5-2显示了系统各个组件之间的通信：用戶客戶端、主库和两个从库。时间从左向右流动。请求或响应消息用粗箭头表示。</p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906210412.png"><br>图5-2基于领导者的复制：一个同步从库和一个异步从库</p><p>在图5-2的示例中，从库1的复制是同步的：在向用戶报告写入成功并使结果对其他用戶可⻅之前，主库需要等待从库1的确认，确保从库1已经收到写入操作。而从库2的复制是异步的：主库发送消息，但不等待该从库的响应。</p><p>在这幅图中，从库2处理消息前存在一个显著的延迟。通常情况下，复制的速度相当快：大多数数据库系统能在不到一秒内完成从库的同步，但它们不能提供复制用时的保证。有些情况下，从库可能落后主库几分钟或更久，例如：从库正在从故障中恢复，系统正在最大容量附近运行，或者当节点间存在网络问题时。</p><p>同步复制的优点是，从库能保证有与主库一致的最新数据副本。如果主库突然失效，我们可以确信这些数据仍然能在从库上找到。缺点是，如果同步从库没有响应（比如它已经崩溃，或者出现网络故障，或其它任何原因），主库就无法处理写入操作。主库必须阻止所有写入，并等待同步副本再次可用。</p><p>因此，将所有从库都设置为同步的是不切实际的：任何一个节点的中断都会导致整个系统停滞不前。 实际上，如果在数据库上启用同步复制，通常意味着其中 一个 从库是同步的，而其他的从库则是异步的。如果该同步从库变得不可用或缓慢，则将一个异步从库改为同步运行。这保证你至少在两个节点上拥有最新的数据副本：主库和同步从库。这种配置有时也被称为 <strong>半同步（semi-synchronous）</strong><br>【 7 】。</p><p>通常情况下，基于领导者的复制都配置为完全异步。在这种情况下，如果主库失效且不可恢复，则任何尚未复制给从库的写入都会丢失。这意味着即使已经向客戶端确认成功，写入也不能保证是 <strong>持久（Durable）</strong> 的。然而，一个完全异步的配置也有优点：即使所有的从库都落后了，主库也可以继续处理写入。</p><p>弱化的持久性可能听起来像是一个坏的折衷，但异步复制其实已经被广泛使用了，特别是在有很多从库的场景下，或者当从库在地理上分布很广的时候。我们将在讨论“复制延迟问题”时回到这个问题。</p><blockquote><p>关于复制的研究<br>对于异步复制系统而言，主库故障时会丢失数据可能是一个严重的问题，因此研究人员仍在研究不丢数据但仍能提供良好性能和可用性的复制方法。例如， 链式复制（chainreplication） 【8,9】是同步复制的一种变体，已经在一些系统（如MicrosoftAzureStorage【10,11】）中成功实现。</p></blockquote><blockquote><p>复制的一致性与 共识 （consensus，使几个节点就某个值达成一致）之间有着密切的联系。</p></blockquote><h3 id="处理节点宕机"><a href="#处理节点宕机" class="headerlink" title="处理节点宕机"></a>处理节点宕机</h3><p>系统中的任何节点都可能宕机，可能因为意外的故障，也可能由于计划内的维护（例如，重启机器以安装内核安全补丁）。对运维而言，能在系统不中断服务的情况下重启单个节点好处多多。我们的目标是，即使个别节点失效，也能保持整个系统运行，并尽可能控制节点停机带来的影响。</p><p>如何通过基于领导者的复制实现高可用？</p><h4 id="Follower失效：追赶恢复"><a href="#Follower失效：追赶恢复" class="headerlink" title="Follower失效：追赶恢复"></a>Follower失效：追赶恢复</h4><p>在其本地磁盘上，每个从库记录从主库收到的数据变更。如果从库崩溃并重新启动，或者，如果主库和从库之间的网络暂时中断，则比较容易恢复：从库可以从日志中知道，在发生故障之前处理的最后一个事务。因此，从库可以连接到主库，并请求在从库断开期间发生的所有数据变更。当应用完所有这些变更后，它就赶上了主库，并可以像以前一样继续接收数据变更流。</p><h4 id="Leader失效：故障切换"><a href="#Leader失效：故障切换" class="headerlink" title="Leader失效：故障切换"></a>Leader失效：故障切换</h4><p>主库失效处理起来相当棘手：其中一个从库需要被提升为新的主库，需要重新配置客戶端，以将它们 的写操作发送给新的主库，其他从库需要开始拉取来自新主库的数据变更。这个过程被称为 故障切换<strong>（failover）</strong> 。</p><p>故障切换可以手动进行（通知管理员主库挂了，并采取必要的步骤来创建新的主库）或自动进行。自动的故障切换过程通常由以下步骤组成：</p><ol><li>确认主库失效。有很多事情可能会出错：崩溃、停电、网络问题等等。没有万无一失的方法来检测出现了什么问题，所以大多数系统只是简单使用 超时（Timeout） ：节点频繁地相互来回传递消息，如果一个节点在一段时间内（例如30秒）没有响应，就认为它挂了（因为计划内维护而故意关闭主库不算）。</li><li>选择一个新的主库。这可以通过选举过程（主库由剩余副本以多数选举产生）来完成，或者可以由之前选定的 控制器节点（controllernode） 来指定新的主库。主库的最佳人选通常是拥有旧主库最新数据副本的从库（以最小化数据损失）。让所有的节点同意一个新的领导者，是一个共识问题。</li><li>重新配置系统以启用新的主库。客戶端现在需要将它们的写请求发送给新主库。如果旧主库恢复，可能仍然认为自己是主库，而没有意识到其他副本已经让它失去领导权了。系统需要确保旧主库意识到新主库的存在，并成为一个从库。</li></ol><p>故障切换的过程中有很多地方可能出错：</p><ul><li>如果使用异步复制，则新主库可能没有收到老主库宕机前最后的写入操作。在选出新主库后，如果老主库重新加入集群，新主库在此期间可能会收到冲突的写入，那这些写入该如何处理？最常⻅的解决方案是简单丢弃老主库未复制的写入，这很可能打破客戶对于数据持久性的期望。</li><li>如果数据库需要和其他外部存储相协调，那么丢弃写入内容是极其危险的操作。例如在GitHub【 13 】的一场事故中，一个过时的MySQL从库被提升为主库。数据库使用自增ID作为主键，因为新主库的计数器落后于老主库的计数器，所以新主库重新分配了一些已经被老主库分配掉的ID作为主键。这些主键也在Redis中使用，主键重用使得MySQL和Redis中的数据产生不一致，最后导致一些私有数据泄漏到错误的用戶手中。</li><li>发生某些故障时（⻅第八章）可能会出现两个节点都以为自己是主库的情况。这种情况称为 <strong>脑裂（splitbrain）</strong> ，非常危险：如果两个主库都可以接受写操作，却没有冲突解决机制（请参阅“多主复制”），那么数据就可能丢失或损坏。一些系统采取了安全防范措施：当检测到两个主库节点同时存在时会关闭其中一个节点(2)，但设计粗糙的机制可能最后会导致两个节点都被关闭 【 14 】。</li><li>主库被宣告死亡之前的正确超时应该怎么配置？在主库失效的情况下，超时时间越⻓意味着恢复时间也越⻓。但是如果超时设置太短，又可能会出现不必要的故障切换。例如，临时的负载峰值可能导致节点的响应时间增加到超出超时时间，或者网络故障也可能导致数据包延迟。如果系统已经处 于高负载或网络问题的困扰之中，那么不必要的故障切换可能会让情况变得更糟糕。</li></ul><p>这些问题没有简单的解决方案。因此，即使软件支持自动故障切换，不少运维团队还是更愿意手动执行故障切换。</p><p>节点故障、不可靠的网络、对副本一致性、持久性、可用性和延迟的权衡，这些问题实际上是分布式系统中的基本问题。</p><h3 id="复制日志的实现"><a href="#复制日志的实现" class="headerlink" title="复制日志的实现"></a>复制日志的实现</h3><p>基于领导者的复制在底层是如何工作的？实践中有好几种不同的复制方式，所以先简要地看一下。</p><h4 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h4><p>在最简单的情况下，主库记录下它执行的每个写入请求（ 语句 ，即statement）并将该语句日志发送给从库。对于关系数据库来说，这意味着每个INSERT、UPDATE或DELETE语句都被转发给每个从库，每个从库解析并执行该SQL语句，就像直接从客戶端收到一样。虽然听上去很合理，但有很多问题会搞砸这种复制方式：</p><ul><li>任何调用 <strong>非确定性函数（nondeterministic）</strong> 的语句，可能会在每个副本上生成不同的值。例如，使用NOW()获取当前日期时间，或使用RAND()获取一个随机数。</li><li>如果语句使用了 <strong>自增列（autoincrement）</strong> ，或者依赖于数据库中的现有数据（例如，UPDATE … WHERE &lt;某些条件&gt;），则必须在每个副本上按照完全相同的顺序执行它们，否则可能会产生不同的效果。当有多个并发执行的事务时，这可能成为一个限制。</li><li>有副作用的语句（例如：触发器、存储过程、用戶定义的函数）可能会在每个副本上产生不同的副作用，除非副作用是绝对确定性的。</li></ul><p>的确有办法绕开这些问题⸺例如，当语句被记录时，主库可以用固定的返回值替换掉任何不确定 的函数调用，以便所有从库都能获得相同的值。但是由于边缘情况实在太多了，现在通常会选择其他的复制方法。</p><p>基于语句的复制在5.1版本前的MySQL中被使用到。因为它相当紧凑，现在有时候也还在用。但现在在默认情况下，如果语句中存在任何不确定性，MySQL会切换到基于行的复制（稍后讨论）。 VoltDB使用了基于语句的复制，但要求事务必须是确定性的，以此来保证安全【 15 】。</p><p>基于语句的复制最大的缺点是， <strong>语句的执行结果可能不具备可回滚性。</strong></p><h4 id="预写式日志（WAL）"><a href="#预写式日志（WAL）" class="headerlink" title="预写式日志（WAL）"></a>预写式日志（WAL）</h4><p>将写操作追加到日志中：</p><ul><li>对于日志结构存储引擎（请参阅“SSTables和LSM树”），日志是主要的存储位置。日志段在后台压缩，并进行垃圾回收。</li><li>对于覆写单个磁盘块的B树，每次修改都会先写入 <strong>预写式日志（WriteAheadLog,WAL）</strong> ，以便崩溃后索引可以恢复到一个一致的状态。</li></ul><p>在任何一种情况下，该日志都是包含了所有数据库写入的追加写日志。可以使用完全相同的日志在另一个节点上构建副本：除了将日志写入磁盘之外，主库还可以通过网络将其发送给从库。</p><p>通过使用这个日志，从库可以构建一个与主库一模一样的数据结构拷⻉。</p><p>这种复制方法在PostgreSQL和Oracle等一些产品中被使用到【 16 】。其主要缺点是日志记录的数据非常底层：WAL包含哪些磁盘块中的哪些字节发生了更改。这使复制与存储引擎紧密耦合。如果数据库将其存储格式从一个版本更改为另一个版本，通常不可能在主库和从库上运行不同版本的数据<br>库软件。看上去这可能只是一个小的实现细节，但却可能对运维产生巨大的影响。如果复制协议允许从库使用比主库更新的软件版本，则可以先升级从库，然后执行故障切换，使升级后的节点之一成为新的主库，从而允许数据库软件的零停机升级。如果复制协议不允许版本不匹配（传输WAL经常出现这种情况），则此类升级需要停机。</p><h4 id="逻辑日志复制（基于行）"><a href="#逻辑日志复制（基于行）" class="headerlink" title="逻辑日志复制（基于行）"></a>逻辑日志复制（基于行）</h4><p>另一种方法是对复制和存储引擎使用不同的日志格式，这样可以将复制日志从存储引擎的内部实现中解耦出来。这种复制日志被称为逻辑日志（logicallog），以将其与存储引擎的（物理）数据表示区分开来。<br>关系数据库的逻辑日志通常是以行的粒度来描述对数据库表的写入记录的序列：</p><ul><li>对于插入的行，日志包含所有列的新值。</li><li>对于删除的行，日志包含足够的信息来唯一标识被删除的行，这通常是主键，但如果表上没有主键，则需要记录所有列的旧值。</li><li>对于更新的行，日志包含足够的信息来唯一标识被更新的行，以及所有列的新值（或至少所有已更改的列的新值）。</li></ul><p>修改多行的事务会生成多条这样的日志记录，后面跟着一条指明事务已经提交的记录。MySQL的二进制日志（当配置为使用基于行的复制时）使用了这种方法【 17 】。由于逻辑日志与存储引擎的内部实现是解耦的，系统可以更容易地做到向后兼容，从而使主库和从库能够运行不同版本的数据库软件，或者甚至不同的存储引擎。对于外部应用程序来说，逻辑日志格式也更容易解析。如果要将数据库的内容发送到外部系统，例如复制到数据仓库进行离线分析，或建立自定义索引和缓存【 18 】，这一点会很有用。这种技术被称为 数据变更捕获（changedatacapture） 。</p><h4 id="基于触发器的复制"><a href="#基于触发器的复制" class="headerlink" title="基于触发器的复制"></a>基于触发器的复制</h4><p>到目前为止描述的复制方法是由数据库系统实现的，不涉及任何应用程序代码。在很多情况下，这就是你想要的。但在某些情况下需要更多的灵活性。例如，如果你只想复制数据的一个子集，或者想从一种数据库复制到另一种数据库，或者如果你需要冲突解决逻辑（请参阅“处理写入冲突”），则可能需要将复制操作上移到应用程序层。</p><p>一些工具，如OracleGoldenGate【 19 】，可以通过读取数据库日志，使得其他应用程序可以使用数据。另一种方法是使用许多关系数据库自带的功能：触发器和存储过程。</p><p>触发器允许你将数据更改（写入事务）发生时自动执行的自定义应用程序代码注册在数据库系统中。触发器有机会将更改记录到一个单独的表中，使用外部程序读取这个表，再加上一些必要的业务逻辑，就可以将数据变更复制到另一个系统去。例如，DatabusforOracle【 20 】和BucardoforPostgres【 21 】就是这样工作的。基于触发器的复制通常比其他复制方法具有更高的开销，并且比数据库内置的复制更容易出错，也有很多限制。然而由于其灵活性，它仍然是很有用的。</p><h4 id="复制延迟问题"><a href="#复制延迟问题" class="headerlink" title="复制延迟问题"></a>复制延迟问题</h4><p>容忍节点故障只是需要复制的一个原因。其它原因还包括可伸缩性（处理比单个机器更多的请求）和延迟（让副本在地理位置上更接近用戶）。</p><p>基于领导者的复制要求所有写入都由单个节点处理，但只读查询可以由任何一个副本来处理。所以对于读多写少的场景（Web上的常⻅模式），一个有吸引力的选择是创建很多从库，并将读请求分散到所有的从库上去。这样能减小主库的负载，并允许由附近的副本来处理读请求。</p><p>在这种读伸缩（read-scaling）的体系结构中，只需添加更多的从库，就可以提高只读请求的服务容量。但是，这种方法实际上只适用于异步复制⸺如果尝试同步复制到所有从库，则单个节点故障或网络中断将导致整个系统都无法写入。而且节点越多越有可能出现个别节点宕机的情况，所以完全同步的配置将是非常不可靠的。</p><p>不幸的是，当应用程序从异步从库读取时，如果从库落后，它可能会看到过时的信息。这会导致数据库中出现明显的不一致：同时对主库和从库执行相同的查询，可能得到不同的结果，因为并非所有的写入都反映在从库中。这种不一致只是一个暂时的状态⸺如果停止写入数据库并等待一段时间，从库最终会赶上并与主库保持一致。出于这个原因，这种效应被称为 <strong>最终一致性（eventual consistency）</strong> 【22,23】。(3)</p><p>最终一致性中的“最终”一词有意进行了模糊化：总的来说，副本落后的程度是没有限制的。在正常的操作中， <strong>复制延迟（replicationlag）</strong> ，即写入主库到反映至从库之间的延迟，可能仅仅是几分之一秒，在实践中并不显眼。但如果系统在接近极限的情况下运行，或网络中存在问题时，延迟可以轻而易举地超过几秒，甚至达到几分钟。</p><p>因为滞后时间太⻓引入的不一致性，不仅仅是一个理论问题，更是应用设计中会遇到的真实问题。本节将重点介绍三个在复制延迟时可能发生的问题实例，并简述解决这些问题的一些方法。</p><h4 id="一致性的级别"><a href="#一致性的级别" class="headerlink" title="一致性的级别"></a>一致性的级别</h4><h5 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h5><p>也叫做线性一致性，强一致性有两个要求：</p><ul><li>任何一次读都能读到某个数据的最近一次写的数据。</li><li>系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。</li></ul><p>简言之，在任意时刻，所有节点中的数据都是一样的。</p><h5 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h5><p>顺序一致性有两个要求：</p><ul><li>任何一次读都能读到某个数据的最近一次写的数据。</li><li>系统的所有进程的顺序一致，而且是合理的。即不需要和全局时钟下的顺序一致，错的话一起错，对的话一起对。</li></ul><h5 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h5><p>“读己之所写（read-your-writes）”一致性。 当进程A自己更新一个数据项之后，它总是访问到更新过的值，绝不会看到旧值。这是因果一致性模型的一个特例。<br>因果一致性（CasualConsistency） 。如果进程A通知进程B它已更新了一个数据项，那么进程B的后续访问将返回更新后的值，且一次写入将保证取代前一次写入。与进程A无因果关系的进程C的访问，遵守一般的最终一致性规则。<br>会话（Session）一致性。 这是上一个模型的实用版本，它把访问存储系统的进程放到会话的上下文中。只要会话还存在，系统就保证“读己之所写”一致性。如果由于某些失败情形令会话终止，就要建立新的会话，而且系统的保证不会延续到新的会话。<br>单调（Monotonic）读一致性。 如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回在那个值之前的值。<br>单调写一致性。 系统保证来自同一个进程的写操作顺序执行。要是系统不能保证这种程度的一致性，就非常难以编程了。</p><h4 id="读己之写-因果一致性的特例"><a href="#读己之写-因果一致性的特例" class="headerlink" title="读己之写-因果一致性的特例"></a>读己之写-因果一致性的特例</h4><p>许多应用让用戶提交一些数据，然后查看他们提交的内容。可能是用戶数据库中的记录，也可能是对讨论主题的评论，或其他类似的内容。提交新数据时，必须将其发送给主库，但是当用戶查看数据时，可以通过从库进行读取。如果数据经常被查看，但只是偶尔写入，这是非常合适的。</p><p>但对于异步复制，问题就来了。如图5-3所示：如果用戶在写入后⻢上就查看数据，则新数据可能尚未到达副本。对用戶而言，看起来好像是刚提交的数据丢失了，所以他们不高兴是可以理解的。</p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906211916.png"></p><p>图5-3用戶写入后从旧副本中读取数据。需要写后读(read-after-write)的一致性来防止这种异常 在这种情况下，我们需要 <strong>写后读一致性（read-after-writeconsistency）</strong> ，也称为 <strong>读己之写一致性（read-your-writesconsistency）</strong> 【 24 】。这是一个保证，如果用戶重新加载⻚面，他们总会看到他们自己提交的任何更新。它不会对其他用戶的写入做出承诺：其他用戶的更新可能稍等才会看到。它保证用戶自己的输入已被正确保存。</p><p>如何在基于领导者的复制系统中实现写后读一致性？有各种可能的技术，这里说一些：</p><ul><li><p>对于用戶 <strong>可能修改过</strong> 的内容，总是从主库读取；这就要求得有办法不通过实际的查询就可以知道用戶是否修改了某些东西。举个例子，社交网络上的用戶个人资料信息通常只能由用戶本人编辑，而不能由其他人编辑。因此一个简单的规则就是：总是从主库读取用戶自己的档案，如果要读取其他用戶的档案就去从库。</p></li><li><p>如果应用中的大部分内容都可能被用戶编辑，那这种方法就没用了，因为大部分内容都必须从主库读取（读伸缩就没效果了）。在这种情况下可以使用其他标准来决定是否从主库读取。例如可以跟踪上次更新的时间，在上次更新后的一分钟内，从主库读。还可以监控从库的复制延迟，防止向任何滞后主库超过一分钟的从库发出查询。</p></li><li><p>客戶端可以记住最近一次写入的时间戳，系统需要确保从库在处理该用戶的读取请求时，该时间戳前的变更都已经传播到了本从库中。如果当前从库不够新，则可以从另一个从库读取，或者等待从库追赶上来。这里的时间戳可以是逻辑时间戳（表示写入顺序的东西，例如日志序列号）或实际的系统时钟（在这种情况下，时钟同步变得至关重要，请参阅“不可靠的时钟”）。</p></li><li><p>如果你的副本分布在多个数据中心（为了在地理上接近用戶或者出于可用性目的），还会有额外的复杂性。任何需要由主库提供服务的请求都必须路由到包含该主库的数据中心。</p></li></ul><p>另一种复杂的情况发生在同一位用戶从多个设备（例如桌面浏览器和移动APP）请求服务的时候。这种情况下可能就需要提供跨设备的写后读一致性：如果用戶在一个设备上输入了一些信息，然后在另一个设备上查看，则应该看到他们刚输入的信息。</p><p>在这种情况下，还有一些需要考虑的问题：</p><ul><li>记住用戶上次更新时间戳的方法变得更加困难，因为一个设备上运行的程序不知道另一个设备上发生了什么。需要对这些元数据进行中心化的存储。</li><li>如果副本分布在不同的数据中心，很难保证来自不同设备的连接会路由到同一数据中心。（例如，用戶的台式计算机使用家庭宽带连接，而移动设备使用蜂窝数据网络，则设备的网络路由可能完全不同）。如果你的方法需要读主库，可能首先需要把来自该用戶所有设备的请求都路由到同一个数据中心。</li></ul><h4 id="单调读-单调一致性"><a href="#单调读-单调一致性" class="headerlink" title="单调读-单调一致性"></a>单调读-单调一致性</h4><p>在从异步从库读取时可能发生的异常的第二个例子是用戶可能会遇到 <strong>时光倒流（moving backward in time）</strong> 。</p><p>如果用戶从不同从库进行多次读取，就可能发生这种情况。例如，图5-4显示了用戶2345两次进行相同的查询，首先查询了一个延迟很小的从库，然后是一个延迟较大的从库（如果用戶刷新网⻚时每个请求都被路由到一个随机的服务器，这种情况就很有可能发生）。第一个查询返回了最近由用戶 1234添加的评论，但是第二个查询不返回任何东西，因为滞后的从库还没有拉取到该写入内容。实际上可以认为第二个查询是在比第一个查询更早的时间点上观察系统。如果第一个查询没有返回任何内容，那问题并不大，因为用戶2345可能不知道用戶1234最近添加了评论。但如果用戶2345先看⻅用戶1234的评论，然后又看到它消失，这就会让人觉得非常困惑了。</p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906212144.png"><br>图5-4用戶首先从新副本读取，然后从旧副本读取。时间看上去回退了。为了防止这种异常，我们需要单调的读取。</p><p><strong>单调读（monotonicreads）</strong> 【 23 】可以保证这种异常不会发生。这是一个比 <strong>强一致性（strong consistency）</strong> 更弱，但比 <strong>最终一致性（eventualconsistency）</strong> 更强的保证。当读取数据时，你可能会看到一个旧值；单调读仅意味着如果一个用戶顺序地进行多次读取，则他们不会看到时间回退，也就是说，如果已经读取到较新的数据，后续的读取不会得到更旧的数据。</p><p>实现单调读的一种方式是确保每个用戶总是从同一个副本进行读取（不同的用戶可以从不同的副本读取）。例如，可以基于用戶ID的散列来选择副本，而不是随机选择副本。但是，如果该副本出现故障，用戶的查询将需要重新路由到另一个副本。</p><h4 id="一致前缀读-因果一致性"><a href="#一致前缀读-因果一致性" class="headerlink" title="一致前缀读-因果一致性"></a>一致前缀读-因果一致性</h4><p>第三个复制延迟异常的例子违反了因果律。想象一下Poons先生和Cake夫人之间的以下简短对话：</p><p>Mr.Poons</p><blockquote><p>Mrs.Cake，你能看到多远的未来？</p></blockquote><p>Mrs.Cake</p><blockquote><p>通常约十秒钟，Mr.Poons.</p></blockquote><p>这两句话之间有因果关系：Cake夫人听到了Poons先生的问题并回答了这个问题。</p><p>现在，想象第三个人正在通过从库来听这个对话。Cake夫人说的内容是从一个延迟很低的从库读取的，但Poons先生所说的内容，从库的延迟要大的多（⻅图5-5）。于是，这个观察者会听到以下内容：</p><p>Mrs.Cake</p><blockquote><p>通常约十秒钟，Mr.Poons.</p></blockquote><p>Mr.Poons</p><blockquote><p>Mrs.Cake，你能看到多远的未来？</p></blockquote><p>对于观察者来说，看起来好像Cake夫人在Poons先生提问前就回答了这个问题。这种超能力让人印<br>象深刻，但也会把人搞糊涂。【 25 】。</p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906212405.png"><br>图5-5如果某些分区的复制速度慢于其他分区，那么观察者可能会在看到问题之前先看到答案。<br>要防止这种异常，需要另一种类型的保证： <strong>一致前缀读（consistentprefixreads）</strong> 【 23 】。这个保证的意思是说：如果一系列写入按某个顺序发生，那么任何人读取这些写入时，也会看⻅它们以同样的顺序出现。</p><p>这是 <strong>分区（partitioned）</strong> 或 <strong>分片（sharded）</strong> 数据库中的一个特殊问题。如果数据库总是以相同的顺序应用写入，而读取总是看到一致的前缀，那么这种异常不会发生。但是在许多分布式数据库中，不同的分区独立运行，因此不存在 <strong>全局的写入顺序</strong> ：当用戶从数据库中读取数据时，可能会看到数据库的某些部分处于较旧的状态，而某些则处于较新的状态。</p><p>一种解决方案是，确保任何因果相关的写入都写入相同的分区，但在一些应用中可能无法高效地完成这种操作。还有一些显式跟踪因果依赖关系的算法，我们将在““此前发生”的关系和并发”一节中回到这个话题。</p><h4 id="复制延迟的解决方案"><a href="#复制延迟的解决方案" class="headerlink" title="复制延迟的解决方案"></a>复制延迟的解决方案</h4><p>在使用最终一致的系统时，如果复制延迟增加到几分钟甚至几小时，则应该考虑应用程序的行为。如答案是“没问题”，那很好。但如果结果对于用戶来说是不好的体验，那么设计系统来提供更强的保证（例如 写后读 ）是很重要的。明明是异步复制却假设复制是同步的，这是很多麻烦的根源。</p><p>如前所述，应用程序可以提供比底层数据库更强有力的保证，例如通过主库进行某种读取。但在应用程序代码中处理这些问题是复杂的，容易出错。<br>如果应用程序开发人员不必担心微妙的复制问题，并可以信赖他们的数据库“做了正确的事情”，那该多好呀。这就是 <strong>事务（transaction）</strong> 存在的原因： <strong>数据库通过事务提供强大的保证</strong> ，所以应用程序可以更加简单。<br>单节点事务已经存在了很⻓时间。然而在走向分布式（复制和分区）数据库时，许多系统放弃了事务，声称事务在性能和可用性上的代价太高，并断言在可伸缩系统中最终一致性是不可避免的。这个叙述有一些道理，但过于简单了，本书其余部分将提出更为细致的观点。</p><h3 id="单主复制"><a href="#单主复制" class="headerlink" title="单主复制"></a>单主复制</h3><p>以Raft算法为例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://raft.github.io/raftscope/index.html</span><br><span class="line">RaftScope</span><br><span class="line">Keyboardshortcuts/.Pause/unpause?HelpCSubmitclientrequesttoleaderofhighestterm,ifanyRRestartleaderof</span><br><span class="line">highestterm,ifanyTAdjustelectiontimerstoavoidasplitvoteAAlignel</span><br></pre></td></tr></table></figure><h4 id="⻆色"><a href="#⻆色" class="headerlink" title="⻆色"></a>⻆色</h4><ul><li><strong>Leader</strong> ：接受客戶端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</li><li><strong>Follower</strong> ：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</li><li><strong>Candidate</strong> ：Leader选举过程中的临时⻆色，即候选人。</li></ul><p>系统中任意时刻只能存在一个有效的leader；</p><h4 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h4><p>任期(term)是一个递增的数字，每当发生一轮选举产生了新的leader之后，该leader就会被分配一个新的任期；系统内假设存在多个自认为是leader的节点，则以任期大的节点为准。</p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>Raft算法中每个服务器使用RPC（远程过程调用）进行通信，分为以下三种。</p><ul><li>RequestVoteRPC：候选人在选举期间发起。</li><li>AppendEntriesRPC：领导人发起的一种心跳机制，复制日志也在该命令中完成。</li><li>InstallSnapshotRPC:领导者使用该RPC来发送快照给太落后的追随者。</li></ul><h4 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h4><h5 id="选举时机"><a href="#选举时机" class="headerlink" title="选举时机"></a>选举时机</h5><p>任何follower节点在一定的超时时间之后，没有收到leader的心跳，都可以转变⻆色为candidate，并向其他节点发起投票请求。</p><h5 id="选举方式"><a href="#选举方式" class="headerlink" title="选举方式"></a>选举方式</h5><p>所有节点收到投票请求之后，需要根据一定的原则来响应投票请求：</p><ul><li>在任一任期内，单个节点最多只能投一票</li><li><strong>候选人知道的信息不能比自己的少</strong></li><li>first-come-first-served先来先得</li></ul><p>4.5.4.3 选举结果</p><ol><li>收到 <strong>过半数</strong> 的投票（含自己的一票），则赢得选举，成为leader</li><li>被告知别人已当选，那么自行切换到follower</li><li>一段时间内没有收到过半数投票，则保持candidate状态，重新发出选举</li></ol><h4 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h4><ol><li>leader接受写请求</li><li>leader向follower发送AppendEntries请求</li><li>follower收到该请求后，将日志落地到本地WAL中</li><li>当leader收到 <strong>过半数</strong> 节点回复ok之后，leader将日志应用到本地状态机</li><li>向客戶端回复ok</li><li>leader通知所有follower，该日志已提交</li><li>follower将该日志应用到本地状态机</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Raft协议的原则：</p><ul><li>使用StrongLeader，即Leader的负责写入，且集群数据状态以Leader的数据状态为准；</li><li>日志编号必须是递增且连续的；</li><li>Raft保证：如果不同的节点日志集合中的两个日志条目拥有相同的term和index，那么它们一定存储了相同的指令。</li><li>同时Raft也保证：如果不同的节点日志集合中的两个日志条目拥有相同的term和 index，那么它们之前的所有日志条目也全部相同。</li><li>leader从来不会覆盖或者删除自己的日志，而是强制follower与它保持一致。</li><li>领导人完全原则：如果一个日志条目在一个给定任期内被提交，那么这个条目一定会出现在所有任期号更大的领导人中</li></ul><p>以上原则使得Raft可以保证安全性。</p><h3 id="多主复制"><a href="#多主复制" class="headerlink" title="多主复制"></a>多主复制</h3><p>本章到目前为止，我们只考虑了使用单个主库的复制架构。虽然这是一种常⻅的方法，但还有其它一些有趣的选择。<br>基于领导者的复制有一个主要的缺点：只有一个主库，而且所有的写入都必须通过它(4)。如果出于任何原因（例如和主库之间的网络连接中断）无法连接到主库，就无法向数据库写入。<br>基于领导者的复制模型的自然延伸是允许多个节点接受写入。复制仍然以同样的方式发生：处理写入的每个节点都必须将该数据变更转发给所有其他节点。我们将其称之为 多领导者配置 （multi-leaderconfiguration，也称多主、多活复制，即master-masterreplication或 active&#x2F;active replication）。在这种情况下，每个主库同时是其他主库的从库。</p><h3 id="无主复制"><a href="#无主复制" class="headerlink" title="无主复制"></a>无主复制</h3><p>我们在本章到目前为止所讨论的复制方法⸺单主复制、多主复制⸺都是这样的想法：客戶端向一个主库发送写请求，而数据库系统负责将写入复制到其他副本。主库决定写入的顺序，而从库按相同顺序应用主库的写入。<br>一些数据存储系统采用不同的方法，放弃主库的概念，并允许任何副本直接接受来自客戶端的写入。</p><p>最早的一些的复制数据系统是 <strong>无主的（leaderless）</strong> 【1,44】，但是在关系数据库主导的时代，这个想法几乎已被忘却。在亚⻢逊将其用于其内部的Dynamo系统(6)之后，它再一次成为数据库的一种时尚架构【 37 】。Riak，Cassandra和Voldemort是受Dynamo启发的无主复制模型的开源数据存储，所以这类数据库也被称为Dynamo⻛格。</p><p>在一些无主复制的实现中，客戶端直接将写入发送到几个副本中，而另一些情况下，由一个 <strong>协调者（coordinator）</strong> 节点代表客戶端进行写入。但与主库数据库不同，协调者不执行特定的写入顺序。我们将会看到，这种设计上的差异对数据库的使用方式有着深远的影响。</p>]]></content>
      
      
      <categories>
          
          <category> Java知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一致 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识分布式系统</title>
      <link href="/archives/b3d7f795.html"/>
      <url>/archives/b3d7f795.html</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要做分布式系统"><a href="#为什么要做分布式系统" class="headerlink" title="为什么要做分布式系统"></a>为什么要做分布式系统</h3><p>用大量节点“伪装”成一个单一节点对外服务</p><p><strong>规模</strong></p><p>&nbsp; 超大规模的存储量，要求系统必须具备较强的 横向扩展能力。 （为什么不是纵向扩展？）</p><p><strong>可靠性</strong><br>数据持久化存储之后，要保证数据不丢失，不损坏</p><p><strong>可用性</strong><br>整个分布式系统，要保证较高的可用性，几乎不间断的提供大规模服务</p><h3 id="分布式系统面临的挑战"><a href="#分布式系统面临的挑战" class="headerlink" title="分布式系统面临的挑战"></a>分布式系统面临的挑战</h3><p><strong>规模</strong><br>分布式系统中大部分问题都可以认为是规模问题。</p><p><strong>节点故障</strong><br>单节点稳定性假如是99.99%，那么在 1 万个节点的分布式集群中，至少 1 个节点发生故障的概率是多少？<br>当集群中的节点发生故障时，对集群内数据的可靠性，对集群整体的可用性会带来哪些影响？</p><p><strong>一致性</strong></p><p>在节点故障率如此之高，数据多副本存储的多于 1 个的情况下，我们如何保证多个副本数据是一致的？如何保证数据不会丢失或损坏？</p><p><strong>网络可靠性</strong></p><p>分布式系统谬误之一：网络是可靠的（维基百科：分布式系统的谬误）<br>网络不可靠是因为网络是复杂的<br>网络之所以复杂，是因为通信是复杂的<br>其中分布式系统最值得关注的网络问题是 网络分区</p><p><strong>CAP</strong><br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906204406.png"></p><p><strong>拜占庭将军问题</strong><br>若集群中的节点是不可信的，则需要考虑恶意节点对集群造成的影响；本文仅讨论可信节点组成的集群，即无需考虑拜占庭将军问题。</p><h3 id="怎么构建一个分布式系统"><a href="#怎么构建一个分布式系统" class="headerlink" title="怎么构建一个分布式系统"></a>怎么构建一个分布式系统</h3><p><strong>分布式系统的最终目标</strong><br>使用若干计算机组成一个系统，使得这个系统从外界看上去就像是一台计算机一样。该“计算机”拥有无限扩展能力，可靠性，可用性。 </p><p><strong>分布式系统模型</strong></p><ul><li>最简单的分布式系统：无状态分布式系统；</li><li>更复杂的分布式系统：有状态分布式系统，一般简称分布式系统；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906204546.png"></p><p><strong>有状态分布式系统模型</strong></p><ul><li><p>节点<br>每个节点运行一套各自的程序，所以节点和节点之间是 并行运行 的。</p></li><li><p>网络<br>节点之间通过网络进行通信，由于网络的不可靠性，所以任何其他节点发来的数据都是过期的。</p></li><li><p>失败<br>任意一个节点可能在任何时间发生任意类型的失败，也可能恢复。</p></li><li><p>时钟<br>整个集群没有全局时钟，也就是说，外部请求到达集群的顺序是偏序的。</p></li></ul><p><strong>分布式系统的主要构建策略</strong></p><ul><li><p>多副本</p></li><li><p>一致性协议</p></li><li><p>故障切换策略</p></li></ul><p>其中最重要的一个策略，就是“多副本”。而多副本场景下，要面临的最突出的问题就是副本的“数据一致性”。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回表</title>
      <link href="/archives/c4e28c6e.html"/>
      <url>/archives/c4e28c6e.html</url>
      
        <content type="html"><![CDATA[<h3 id="什么是回表（使用索引查询完整数据过程）？"><a href="#什么是回表（使用索引查询完整数据过程）？" class="headerlink" title="什么是回表（使用索引查询完整数据过程）？"></a>什么是回表（使用索引查询完整数据过程）？</h3><p>当我们需要<strong>查询一条完整的数据的时候</strong>：</p><ul><li>如果是通过<strong>聚簇索引</strong>来查询数据，例如 <code>select * from user where id=100</code>，那么此时只需要搜索<strong>聚簇索引</strong>的 B+Tree 就可以找到数据。</li><li>如果是通过<strong>非聚簇索引</strong>来查询数据，例如 <code>select * from user where username=zhangsan&#39;</code>，那么此时需要先搜索 username 这一列索引的 B+树，搜索完成后得到主键的值，然后再去搜索<strong>聚簇索引</strong>的 B+树，就可以获取到一行完整的数据。<br>对于第二种查询方式而言，一共搜索了两棵 B+树，<strong>第一次搜索 B+树 拿到主键值后再去搜索聚簇索引的 B+树，这个过程就是所谓的回表</strong>。</li></ul><h3 id="回表的代价？"><a href="#回表的代价？" class="headerlink" title="回表的代价？"></a>回表的代价？</h3><p><strong>回表的代价：</strong></p><ul><li><strong>需要回表的记录越多，使用二级索引的性能就越低</strong>，甚至让某些查询宁愿使用全表扫描也不使用二级索引 。</li><li>比方说 name 值在 Asa ～ Barlow 之间的用户记录数量占全部记录数量90%以上，那么如果使用 idx_name_birthday_phone_number 索引的话，有90%多的 id 值需要回表，这不是吃力不讨好么，还不如直接去扫描聚簇索引（也就是全表扫描）。<br><strong>那什么时候采用全表扫描的方式，什么时候使用采用 二级索引 + 回表 的方式去执行查询呢？</strong></li><li>这个就是查询优化器做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的 条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用<strong>全表扫描</strong>，反之倾向于使用 <strong>二级索引 + 回表</strong> 的方式。</li></ul><h3 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h3><p><strong>不一定：</strong></p><ul><li>这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含所有需要查询字段的值，被称之为”覆盖索引”。</li><li>举个简单的例子，假设我们在学生表的成绩上建立了索引，那么当进行<code>select score from student where score &gt; 90</code>的查询时，在索引的叶子节点上，已经包含了score 信息，不会再次进行回表查询。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引底层的底层实现</title>
      <link href="/archives/76572b50.html"/>
      <url>/archives/76572b50.html</url>
      
        <content type="html"><![CDATA[<h3 id="索引底层实现（数据结构）"><a href="#索引底层实现（数据结构）" class="headerlink" title="索引底层实现（数据结构）"></a>索引底层实现（数据结构）</h3><ol><li><p>Hash索引</p><ul><li>哈希表是一种以键—值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</li><li>不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</li><li><strong>哈希表这种结构适用于只有等值查询的场景</strong>，比如 Memcached 及其他一些 NoSQL 引擎。</li></ul></li><li><p>B 树索引</p><ul><li>B 树索引，又称<strong>平衡树索引</strong>，B Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，<strong>数据分布在各个节点之中</strong>。</li><li>一棵 <strong>m 阶 B Tree</strong> 的特性如下：</li><li>每个结点最多 m 个子结点；</li><li>所有的叶子结点都位于同一层；</li><li>每个节点中的元素按<strong>关键字key从小到大排列</strong>；</li><li>每个元素子左结点的值都小于或等于该元素，右结点的值都大于或等于该元素。</li><li>数据库以 B-Tree 的数据结构存储数据的图示如下：<br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230907232212.png"></li></ul></li><li><p>B+Tree索引</p><ul><li>是B-Tree的改进版本，同时也是数据库索引所采用的存储结构。<strong>数据都在叶子节点上，并且增加了顺序访问指针</strong>，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。</li><li>B+tree性质：</li><li>n棵子树的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li><li>所有的非叶子结点只存储 <strong>关键字key信息</strong>，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小<strong>自小而大顺序链接</strong>；</li><li>所有具体数据都存在叶子结点中；</li><li>所有的叶子结点中包含了全部元素的信息；</li><li>所有叶子节点之间都有一个链指针。</li><li>数据库以 B+ Tree 的数据结构存储数据的图示如下：<br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230907232443.png"></li></ul></li></ol><h3 id="为什么索引结构默认使用B-Tree，而不是B-Tree，Hash，二叉树，红黑树？"><a href="#为什么索引结构默认使用B-Tree，而不是B-Tree，Hash，二叉树，红黑树？" class="headerlink" title="为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？"></a>为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？</h3><p><strong>B+树与B树相比：</strong></p><ul><li>B+树的磁盘读写代价更低：B+树的非叶子节点不存贮数据，只存贮关键词key信息，进行数据索引，使每个非叶子节点所能保存的关键字大大增加。这样磁盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</li><li>更加适合区间查询：B树的数据分布在各个节点之中，当进行范围查找时会出现回旋查找。而B+树的数据都存储在叶子结点中，并且MySQL 索引数据结构对经典的 B+Tree 进行了优化，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高了区间访问的性能，防止回旋查找。</li></ul><p><strong>B+树与Hash相比：</strong></p><ul><li>Hash虽然可以快速定位，但是没有顺序，IO复杂度高。</li><li>Hash索引基于Hash表实现，只有Memory存储引擎显式支持哈希索引 。</li><li>Hash索引因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成排序。</li><li>如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。</li></ul><p><strong>B+树与红黑树相比：</strong></p><ul><li>红黑树的高度随着数据量增加而增加，IO代价高。<br>B+树与普通二叉树相比：</li><li>树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。</li><li>普通二叉树存在退化的情况，如果它退化成链表，相当于全表扫描。</li></ul><p><strong>B+树与平衡二叉树相比：</strong></p><ul><li>读取数据的时候，是从磁盘读到内存。如果树这种数据结构作为索引，那每查找⼀次数据就需要从磁盘中读取⼀个节点，也就是⼀个磁盘块，但是平衡二叉树的每个节点只存储⼀个键值和数据，树的节点将会非常多，高度也会极其高。如果是 B+ 树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来了，查询效率就会更快。</li></ul><h3 id="索引的B-树到底有多高？"><a href="#索引的B-树到底有多高？" class="headerlink" title="索引的B+树到底有多高？"></a>索引的B+树到底有多高？</h3><p><strong>InnoDB中页的大小一般为16 KB</strong>，我们假设一行记录的数据大小为1KB（实际上现在很多互联网业务数据记录大小通常就是1K左右）</p><ul><li>如果 B+ 树只有1层，也就是只有1个用于存放用户记录的节点，可以存放 <strong>16KB &#x2F; 1KB &#x3D; 16条数据记录</strong>；</li><li>如果 B+ 树有2层：</li><li>我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，一个页中共可以存放 16 * 1024 &#x2F; 14 &#x3D; 1170个指针，因此可以存放 <strong>1170 * 16 &#x3D; 18720条数据记录</strong>；</li><li>如果 B+ 树有3层：可以存放 <strong>1170 * 1170 * 16 &#x3D;  21902400，大约2000w条数据记录</strong>。<br><strong>所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储</strong>。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。</li></ul><p>与此同时，我们也可以发现<strong>索引的B+树高度也跟索引字段的数据类型有关</strong>，数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I&#x2F;O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</p><h3 id="索引的代价-索引是不是越多越好-？"><a href="#索引的代价-索引是不是越多越好-？" class="headerlink" title="索引的代价(索引是不是越多越好)？"></a>索引的代价(索引是不是越多越好)？</h3><ol><li>空间上的代价<ul><li>每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页， 一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树由许多数据页组成，就是很大的一片存储空间，在增删改记录的时候性能就越差。</li></ul></li><li>时间上的代价<ul><li>每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引</title>
      <link href="/archives/df9a61f7.html"/>
      <url>/archives/df9a61f7.html</url>
      
        <content type="html"><![CDATA[<h3 id="没有索引如何查找数据？"><a href="#没有索引如何查找数据？" class="headerlink" title="没有索引如何查找数据？"></a>没有索引如何查找数据？</h3><p>在一个页中的查找，分为<strong>两种情况</strong>：</p><ol><li><strong>以主键为搜索条件</strong><br>可以在 <strong>页目录</strong> 中使用二分法快速定位到对应的槽，然后再遍历该槽对应 分组中的记录即可快速找到指定的记录。</li><li><strong>以其他列作为搜索条件</strong><br>对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的 页目录 ，所以 我们无法通过二分法快速定位相应的 槽 。这种情况下只能从 最小记录 开始依次遍历单链表中的每条记录， 然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</li></ol><p><strong>在很多页中的查找，可以分为两个步骤：</strong></p><ol><li>定位到记录所在的页。</li><li>从所在的页内中查找相应的记录。<br>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录。</li></ol><h3 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h3><p><strong>索引本质是排好序的数据结构</strong>，一种特殊的文件，包含着对数据表里所有记录的引用指针，直接在索引中查找符合条件的选项，加快数据库的查询速度，而不是一行一行去遍历数据后才选择出符合条件的。<br><strong>优点：</strong></p><ul><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。<br><strong>缺点：</strong></li><li>索引是一个文件，它是要占据物理空间的。</li><li>创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增&#x2F;改&#x2F;删的执行效率。</li></ul><h3 id="MySQL有哪几种索引类型？"><a href="#MySQL有哪几种索引类型？" class="headerlink" title="MySQL有哪几种索引类型？"></a>MySQL有哪几种索引类型？</h3><ol><li>从<strong>数据结构</strong>上来划分：哈希索引，B树索引，B+树索引。</li><li>从<strong>功能层次</strong>上来划分：普通索引，唯一索引，主键索引，联合索引。<ul><li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引。</li><li>唯一索引：索引列的值必须唯一，但允许有空值。</li><li>主键索引：一种特殊的唯一索引，不允许有空值，一般在建表时同时创建主键索引;</li><li>联合索引：多列值组成一个索引，专门用于组合搜索。</li></ul></li><li>从<strong>物理存贮</strong>上来划分：聚簇索引，非聚簇索引。</li></ol><h3 id="聚簇索引和非聚簇索引？"><a href="#聚簇索引和非聚簇索引？" class="headerlink" title="聚簇索引和非聚簇索引？"></a>聚簇索引和非聚簇索引？</h3><p><strong>聚簇索引：</strong> 聚簇索引是按照每张表的主键构造一颗B+树，<strong>叶子节点中存放的就是整张表的数据</strong>，将聚簇索引的叶子节点称为数据页。<br>c1，c2，c3三列，我们以c1列建立索引，索引树如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230907231314.png"></p><p><strong>聚簇索引的特点：</strong><br>聚簇索引不需要我们显式去创建，InnoDB 存储引擎会<strong>自动的为我们创建聚簇索引</strong>，并且在 InnoDB 存储引擎中， <strong>聚簇索引</strong> 就是数据的存储方式（所有的用户记录都存储在了叶子节点 ），也就是所谓的<strong>索引即数据，数据即索引</strong>。<br><strong>聚簇索引的优点：</strong></p><ul><li>数据访问更快，聚簇索引将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快；</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快。<br><strong>聚簇索引的缺点：</strong></li><li>插入速度严重依赖于插入顺序，按照主键的顺序（递增）插入是最快的方式，否则将会出现页分裂，严重影响性能。</li><li>更新主键的代价很高，将会导致被更新的行移动，所以对于 InnoDB 表，一般定义主键为不可更新。</li><li>聚簇索引只能在搜索条件是主键值时才能发挥作用，因为 B+ 树中的数据都是按照主键进行排序的。</li></ul><p><strong>非聚簇索引：</strong>非聚簇索引叶子节点存储的是主键值，而不是数据的物理地址，所以访问数据需要二次查找，推荐使用覆盖索引，可以减少回表查询。<br>以c2列作为索引列，建立B+树：<br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230907231557.png"></p><p><strong>非聚簇索引的特点：</strong></p><ul><li>B+ 树的叶子节点存储的并不是完整的用户记录，而只是 <strong>索引列+主键</strong> 这两个列的值。</li><li>以索引列大小排序的 B+ 树只能确定我们要查找记录的主键值，所以如果我们想根据 c2 列的值查找到完整的用户记录的话，仍然需要到 <strong>聚簇索引</strong> 中再查一遍，这个过程也被称为 <strong>回表</strong>。<br><strong>非聚簇索引的优点：</strong></li><li>非聚簇索引由于不存储实际数据，所以实际文件较小，相比于聚簇索引再读取时可以减少磁盘IO。</li><li>非聚簇索引使用主键作为”指针” 而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作。<br><strong>非聚簇索引的缺点：</strong></li><li>需要进行回表查询，即查询到对应的聚簇索引之后再通过聚簇索引查询到所需数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB数据页结构</title>
      <link href="/archives/fd7e9834.html"/>
      <url>/archives/fd7e9834.html</url>
      
        <content type="html"><![CDATA[<h3 id="InnoDB页介绍一下？"><a href="#InnoDB页介绍一下？" class="headerlink" title="InnoDB页介绍一下？"></a>InnoDB页介绍一下？</h3><ul><li>InnoDB 是一个将表中的数据存储到磁盘上的存储引擎，当我们想从表中获取某些记录时，InnoDB 采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，<strong>InnoDB中页的大小一般为 16 KB</strong>。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB 内容刷新到磁盘中。</li><li><strong>InnoDB 为了不同的目的而设计了许多种不同类型的页</strong> ，比如存放表空间头部信息的页，存放 Insert Buffer 信息的页，存放 INODE 信息的页，存放 undo 日志信息的页。存放我们表中记录的那种类型的被称为索引（ INDEX ）页。</li></ul><h3 id="InnoDB数据页的大小为什么是16KB？"><a href="#InnoDB数据页的大小为什么是16KB？" class="headerlink" title="InnoDB数据页的大小为什么是16KB？"></a>InnoDB数据页的大小为什么是16KB？</h3><ul><li>在操作系统的文件管理系统中进行一次IO读写，<strong>默认读取的大小为4kb（一页）</strong>。</li><li><strong>又因为局部性原理</strong>，操作系统会将命中的页周围的三块页一同加载进Innodb的缓存池中，因此Innnodb数据页的大小为16kb。</li></ul><h3 id="数据页结构？"><a href="#数据页结构？" class="headerlink" title="数据页结构？"></a>数据页结构？</h3><p>数据页代表的这块 16KB 大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：<br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230907225514.png"></p><h3 id="数据页中查找指定主键值的过程？"><a href="#数据页中查找指定主键值的过程？" class="headerlink" title="数据页中查找指定主键值的过程？"></a>数据页中查找指定主键值的过程？</h3><p><strong>在一个数据页中查找指定主键值的记录的过程分为两步：</strong></p><ol><li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。</li><li>通过记录的 next_record 属性遍历该槽所在的组中的各个记录。<br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230907230037.png"></li></ol><h3 id="数据页总结"><a href="#数据页总结" class="headerlink" title="数据页总结"></a>数据页总结</h3><ol><li>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做 <strong>数据页</strong> 。</li><li><strong>一个数据页可以被大致划分为7个部分</strong>，分别是<br>-File Header ，表示页的一些通用信息，占固定的38字节。<br>-Page Header ，表示数据页专有的一些信息，占固定的56个字节。<br>-Infimum + Supremum ，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的 26 个字节。<br>-User Records ：真实存储我们插入的记录的部分，大小不固定。<br>-Free Space ：页中尚未使用的部分，大小不确定。<br>-Page Directory ：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。<br>-File Trailer ：用于检验页是否完整的部分，占用固定的8个字节。</li><li>每个记录的头信息中都有一个 next_record 属性，从而使页中的所有记录串联成一个<strong>单链表</strong> 。</li><li><strong>InnoDB 会为把页中的记录划分为若干个组</strong>，每个组的最后一个记录的地址偏移量作为一个槽 ，存放在Page Directory 中，所以在一个页中根据主键查找记录是非常快的，分为两步：<ul><li>通过<strong>二分法</strong>确定该记录所在的槽。</li><li>通过记录的<strong>next_record属性</strong>遍历该槽所在的组中的各个记录。</li></ul></li><li>每个数据页的 File Header 部分都有上一个和下一个页的编号，所以所有的数据页会组成一个<strong>双链表</strong> 。</li><li>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时<br>对应的 LSN 值，如果首部和尾部的校验和和 LSN 值校验不成功的话，就说明同步过程出现了问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB记录结构</title>
      <link href="/archives/15f888e2.html"/>
      <url>/archives/15f888e2.html</url>
      
        <content type="html"><![CDATA[<p>InnoDB记录结构</p><h3 id="InnoDB行格式-？"><a href="#InnoDB行格式-？" class="headerlink" title="InnoDB行格式 ？"></a>InnoDB行格式 ？</h3><ul><li>我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 行格式 或者 记录格式 。</li><li>设计InnoDB 存储引擎的作者到现在为止设计了4种不同类型的 行格式 ，分别是 Compact 、Redundant 、Dynamic 和 Compressed 行格式。</li></ul><h3 id="COMPACT行格式-？"><a href="#COMPACT行格式-？" class="headerlink" title="COMPACT行格式 ？"></a>COMPACT行格式 ？</h3><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230907225032.png"><br>一条完整的记录其实可以被分为 记录的额外信息 和 记录的真实数据 两大部分。<br>记录的额外信息<br>这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是 变长字段长度列表 、 NULL值列表 和 记录头信息：</p><ul><li>变长字段长度列表：将一些变长的数据类型，比如 VARCHAR(M)，VARBINARY(M)，占用的字节数存起来，这些变长字段占的存储空间分为两部分：<br>a.  真正的数据内容<br>b. 占用的字节数</li><li>NULL值列表：Compact 行格式把值为 NULL 的列统一管理起来，存储到 NULL 值列表中。</li><li>记录头信息：用于描述记录的记录头信息 ，它是由固定的 5 个字节组成。<br>记录的真实数据<br>对于 record_format_demo 表来说， 记录的真实数据 除了 c1 、 c2 、 c3 、 c4 这几个我们自己定义的列的数据以外， MySQL 会为每个记录默认的添加一些列（也称为 隐藏列 ），具体的列如下：<br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230907224816.png"></li></ul><h3 id="InnoDB-表对主键的生成策略？"><a href="#InnoDB-表对主键的生成策略？" class="headerlink" title="InnoDB 表对主键的生成策略？"></a>InnoDB 表对主键的生成策略？</h3><ul><li><strong>优先使用用户自定义主键作为主键</strong>，如果用户没有定义主键，则选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为row_id 的隐藏列作为主键。</li><li><strong>InnoDB存储引擎会为每条记录都添加</strong> <code>transaction_id</code> 和 <code>roll_pointer</code> 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心， InnoDB 存储引擎会自己帮我们生成的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础2</title>
      <link href="/archives/aa0dfa70.html"/>
      <url>/archives/aa0dfa70.html</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL中in和exists区别？"><a href="#MySQL中in和exists区别？" class="headerlink" title="MySQL中in和exists区别？"></a>MySQL中in和exists区别？</h3><p>exists用于对外表记录做筛选：</p><ul><li>exists会遍历外查询表，将外查询表的每一行，代入内查询进行判断。当exists里的条件语句能够返回记录行时，条件就为真，返回外表当前记录。反之如果exists里的条件语句不能返回记录行，条件为假，则外表当前记录被丢弃。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.<span class="operator">*</span> <span class="keyword">from</span> A awhere <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B b <span class="keyword">where</span> a.id<span class="operator">=</span>b.id)</span><br></pre></td></tr></table></figure><p><strong>in是先把后边的语句查出来放到临时表中</strong>，然后遍历临时表，将临时表的每一行，代入外查询去查找。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> id <span class="keyword">in</span>(<span class="keyword">select</span> id <span class="keyword">from</span> B)</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong></p><ul><li>子查询的表比较大的时候，使用exists可以有效减少总的循环次数来提升速度；</li><li>当外查询的表比较大的时候，使用in可以有效减少对外查询表循环遍历来提升速度；</li></ul><h3 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h3><p><strong>存贮过程：</strong> 存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合。用户可以像使用自定义的函数―样重复调用这些存储过程，实现它所定义的操作。这个过程经编译和优化后存储在数据库服务器中，使用时只要调用即可。<br><strong>优点：</strong></p><ul><li>存储过程和函数可以重复使用，减轻开发人员的工作量。类似于java中方法可以多次调用；</li><li>减少网络流量，存储过程和函数位于服务器上，调用的时候只需要传递名称和参数即可；</li><li>减少数据在数据库和应用服务器之间的传输，可以提高数据处理的效率；</li><li>将一些业务逻辑在数据库层面来实现，可以减少代码层面的业务处理。<br><strong>缺点：</strong></li><li>互联网项目中，迭代太快，项目的生命周期也比较短，在这样的情况下，存储过程的管理不是特别友好，同时复用性也没有写在服务层那么好。</li></ul><h3 id="MySQL-执行查询的过程？"><a href="#MySQL-执行查询的过程？" class="headerlink" title="MySQL 执行查询的过程？"></a>MySQL 执行查询的过程？</h3><ol><li>客户端通过 TCP 连接发送连接请求到 MySQL 连接器，连接器会对该请求进行权限验证及连接资源分配。</li><li>客户端发送一条查询给服务器，服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果，否则进入下一阶段。</li><li>分析器进行词法分析，语法分析。</li><li>优化器执行计划生成，索引选择。</li><li>最后交给执行器，操作引擎，返回结果。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230907220554.png"></p><h3 id="删除表的三种方式？"><a href="#删除表的三种方式？" class="headerlink" title="删除表的三种方式？"></a>删除表的三种方式？</h3><ol><li><p>delete from</p><ul><li>delete 是删除表中的数据，不删除表结构，速度最慢，但可以与where连用，可以删除指定的行；<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span>;  <span class="comment">-- 删除user表的所有数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">--删除user表的指定记录</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>drop table</p><ul><li>drop 是直接删除表信息，速度最快，但是无法找回数据 ；<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">user</span>; <span class="comment">-- 删除 user 表</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>truncate (table)</p><ul><li>truncate 是删除表数据，不删除表的结构，速度排第二，但不能与where一起使用；  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> <span class="keyword">user</span>; <span class="comment">--删除 user 表</span></span><br></pre></td></tr></table></figure>三种方式的区别：<br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230907223157.png"></li></ul></li></ol><h3 id="count-1-、count-与-count-列名-的区别？"><a href="#count-1-、count-与-count-列名-的区别？" class="headerlink" title="count(1)、count(*) 与 count(列名) 的区别？"></a>count(1)、count(*) 与 count(列名) 的区别？</h3><p><strong>执行效果：</strong></p><ul><li><code>count(*)包括了所有的列</code>，相当于行数，在统计结果的时候，不会忽略列值为NULL ；</li><li><code>count(1) 计算一共有多少符合条件的行</code> ，用1代表代码行，在统计结果的时候，不会忽略列值为NULL；</li><li><code>count(列名) 只包括列名那一列</code>，在统计结果的时候，会忽略列值为空（这⾥的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li></ul><p><strong>执行速度：</strong></p><ul><li>列名为主键，count(列名)会比count(1)快；</li><li>列名不为主键，count(1)会比count(列名)快；</li><li>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*);</li><li>如果有主键，则 select count（主键）的执行效率是最优的;</li><li>如果表只有一个字段，则 select count（*）最优。</li></ul><h3 id="MySQL-的内连接、左连接、右连接有有什么区别？"><a href="#MySQL-的内连接、左连接、右连接有有什么区别？" class="headerlink" title="MySQL 的内连接、左连接、右连接有有什么区别？"></a>MySQL 的内连接、左连接、右连接有有什么区别？</h3><p>MySQL的连接主要分为<strong>内连接</strong>和<strong>外连接</strong>，外连接常⽤的有<strong>左连接</strong>、<strong>右连接</strong>。</p><ol><li>inner join 内连接，在两张表进行连接查询时，<strong>只保留两张表中完全匹配的结果集</strong>；</li><li>left join左连接在两张表进行连接查询时，<strong>会返回左表所有的行，即使在右表中没有匹配的记录</strong>。</li><li>right join右连接在两张表进行连接查询时，会返回<strong>右</strong>表所有的行，即使在左表中没有匹配的记录。</li></ol><h3 id="MySQL使用枚举类型的优缺点？"><a href="#MySQL使用枚举类型的优缺点？" class="headerlink" title="MySQL使用枚举类型的优缺点？"></a>MySQL使用枚举类型的优缺点？</h3><p><strong>优点：</strong></p><ol><li>减少空间：枚举类型只存储了预先定义好的几种取值，而不是存储字符串或数字，因此能够节省存储空间。</li><li>限制字段值：使用枚举类型可以限制字段的取值范围，确保存储的数据的正确性。</li><li>数据安全：使用枚举类型可以降低因人为失误导致的数据错误的风险。</li><li>提高代码可读性：使用枚举类型可以使代码更容易理解，因为每个枚举值都有其明确的含义。</li></ol><p><strong>缺点：</strong></p><ol><li>可扩展性差：枚举类型定义了一组固定的值，如果要增加或删除枚举类型的值，需要修改数据库的表结构。</li><li>代码依赖性高：枚举类型定义在数据库中，如果需要修改枚举类型的值，需要修改代码。</li><li>限制：枚举类型只允许存储预先定义的有限集合中的值，不能存储其他值。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础1</title>
      <link href="/archives/3304abca.html"/>
      <url>/archives/3304abca.html</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL-的逻辑架构了解吗？"><a href="#MySQL-的逻辑架构了解吗？" class="headerlink" title="MySQL 的逻辑架构了解吗？"></a>MySQL 的逻辑架构了解吗？</h3><ol><li>第一层是网络连接层，主要完成一些类似于连接处理、授权认证、及相关的安全方案。</li><li>第二层是核心服务层，包括查询解析、分析、优化、缓存以及日期和时间等所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等。</li><li>第三层是存储引擎层，存储引擎负责 MySQL 中数据的存储和提取。服务器通过 API 和存储引擎进行通信，不同的存储引擎具有不同的功能，共用一个 Server 层，可以根据开发的需要，来选取合适的存储引擎。</li><li>第四层是系统文件层，主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</li></ol><h3 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a>SQL 约束有哪几种？</h3><ol><li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>CHECK: 用于控制字段的值范围。</li></ol><h3 id="自增主键（AUTO-INCREMENT）理解"><a href="#自增主键（AUTO-INCREMENT）理解" class="headerlink" title="自增主键（AUTO_INCREMENT）理解?"></a>自增主键（AUTO_INCREMENT）理解?</h3><p><strong>自增主键:</strong><br>InnoDB引擎的自增值，其实是保存在了内存里，并且到了MySQL 8.0版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的值”，具体情况是：</p><ul><li>在MySQL5.7及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值max(id)，然后将max(id) + 1作为这个表当前的自增值</li><li>举例来说，如果一个表当前数据行里最大的id是10，AUTO_INCREMENT&#x3D;11。这时候，我们删除id&#x3D;10的行，AUTO_INCREMENT还是11。但如果马上重启实例，重启后这个表的AUTO_INCREMENT就会变成10。也就是说，MySQL重启可能会修改一个表的AUTO INCREMENT的值。</li><li>在MySQL8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值，才有了“自增值持久化”的能力。</li></ul><p><strong>自增值修改机制</strong><br>如果id字段被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p><ol><li>如果插入数据时id字段指定为0、null或未指定值，那么就把这个表当前的AUTO_INCREMENT值填到自增字段;</li><li>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值 。<br><strong>自增值新增机制:</strong></li><li>如果准备插入的值&gt;&#x3D;当前自增值，新的自增值就是 “准备插入的值+1”;</li><li>否则，自增值不变。</li></ol><h3 id="为什么自增主键不连续？"><a href="#为什么自增主键不连续？" class="headerlink" title="为什么自增主键不连续？"></a>为什么自增主键不连续？</h3><p><strong>唯一键冲突：</strong></p><ul><li>由于表的自增值已变，但是主键发生冲突没插进去，下一次插入主键 &#x3D; 现在变了的自增值+1，所以不连续；</li><li>举例：假设执行 SQL 的时候 user 表 id &#x3D; 10，此时在内存中的自增 id 为11，此时发生唯一键冲突写库失败，则 user 表没有 id &#x3D; 10 这条记录，之后 id 从11开始写入，因此 id 是不连续的。</li></ul><p><strong>事务回滚：</strong></p><ul><li>自增值不能回退，因为并发插入数据时，回退自增ID可能造成主键冲突；</li><li>举例：  假设同时需要对 user、staff 表进行写库操作，执行 SQL 的时候 user 表 id &#x3D; 10，此时在内存中的自增 id 为11；staff 表 id &#x3D; 20，此时内存中的自增 id 为21，一旦事务执行失败，事务回滚，写库失败，则 user 表没有 id &#x3D; 10 这条记录，staff 表没有 id &#x3D; 20 这条记录，user 表从11开始写入，staff 表从21开始写入，如此产生 id 不连续的现象。</li></ul><h3 id="为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？"><a href="#为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？" class="headerlink" title="为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？"></a>为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？</h3><ol><li>InnoDB优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为row_id 的隐藏列作为主键。</li><li>使用自增主键好处：<ul><li>使用自增ID，主键页就会近乎于顺序的记录填满，提升了页面的最大填充率，不会有页的浪费;</li><li>新插入的行一定会在原有的最大数据行下一行，MySQL定位和寻址很快，不会为计算新行的位置而做出额外的消耗;</li><li>减少了页分裂和碎片的产生。</li></ul></li><li>如果使用非自增主键:<ul><li>由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页中间的某个位置  ， 此时MySQL不得不为了将新记录插到合适位置而移动数据 ，无疑增加了很多开销，同时分页操作也造成了大量的碎片。</li></ul></li></ol><h3 id="VARCHAR-和-CHAR有什么区别？"><a href="#VARCHAR-和-CHAR有什么区别？" class="headerlink" title="VARCHAR 和 CHAR有什么区别？"></a>VARCHAR 和 CHAR有什么区别？</h3><ol><li>固定长度 &amp; 可变长度<ul><li>CHAR用于存储固定长度字符串，假如申请了char(10)的空间，那么无论实际存储多少内容，该字段都占用 10 个字符。</li><li>VARCHAR用于存储可变长度字符串， MySQL会根据定义的字符串长度分配足够的空间。</li></ul></li><li>存储方式<ul><li>VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。  </li><li>CHAR适合存储很短的字符串，或所有值都接近同一个长度，例如存储密码的 MD5 值。对于经常变更的数据，CHAR 也比 VARCHAR更好，因为定长的 CHAR 不容易产生碎片。</li></ul></li><li>占用字节<ul><li>CHAR的存储方式是，对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。</li><li>VARCHAR的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节，两者的存储数据都是非unicode的字符数据。</li></ul></li><li>存贮效率<ul><li>CHAR的存取速度比VARCHAR要快得多，因为其长度固定，方便程序的存储与查找；但是CHAR也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，是以空间换取时间效率 。</li><li>VARCHAR是以空间效率为首位的。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压缩工具类</title>
      <link href="/archives/d09c1821.html"/>
      <url>/archives/d09c1821.html</url>
      
        <content type="html"><![CDATA[<p><em><strong>用于文件的压缩工具类</strong></em></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 压缩方法</span></span><br><span class="line"><span class="comment"> * （可以压缩空的子目录）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcPath     压缩源路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> zipFileName 目标压缩文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">zip</span><span class="params">(String srcPath, String zipFileName)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">    <span class="comment">// 扫描所有要压缩的文件</span></span><br><span class="line">    List&lt;File&gt; fileList = getAllFiles(srcFile);</span><br><span class="line">    <span class="comment">// 缓冲器</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">512</span>];</span><br><span class="line">    <span class="type">ZipEntry</span> <span class="variable">zipEntry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 每次读出来的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">readLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ZipOutputStream</span> <span class="variable">zipOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(zipFileName));</span><br><span class="line">        <span class="keyword">for</span> (File file : fileList) &#123;</span><br><span class="line">            <span class="comment">// 若是文件，则压缩这个文件</span></span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                zipEntry = <span class="keyword">new</span> <span class="title class_">ZipEntry</span>(getRelativePath(srcPath, file));</span><br><span class="line">                zipEntry.setSize(file.length());</span><br><span class="line">                zipEntry.setTime(file.lastModified());</span><br><span class="line">                zipOutputStream.putNextEntry(zipEntry);</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">                <span class="keyword">while</span> ((readLength = inputStream.read(buffer, <span class="number">0</span>, BUFFER)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    zipOutputStream.write(buffer, <span class="number">0</span>, readLength);</span><br><span class="line">                &#125;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//若是目录（即空目录）则将这个目录写入zip条目</span></span><br><span class="line">                zipEntry = <span class="keyword">new</span> <span class="title class_">ZipEntry</span>(getRelativePath(srcPath, file) + <span class="string">&quot;/&quot;</span>);</span><br><span class="line">                zipOutputStream.putNextEntry(zipEntry);</span><br><span class="line">                LogUtil.debug(LogType.Server,<span class="string">&quot;dir compressed: &quot;</span> + file.getCanonicalPath() + <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        zipOutputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取的给定源目录下的所有文件及空的子目录</span></span><br><span class="line"><span class="comment"> * 递归实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title function_">getAllFiles</span><span class="params">(File srcFile)</span> &#123;</span><br><span class="line">    List&lt;File&gt; fileList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    File[] tmp = srcFile.listFiles();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp[i].isFile()) &#123;</span><br><span class="line">            fileList.add(tmp[i]);</span><br><span class="line">            System.out.println(<span class="string">&quot;add file: &quot;</span> + tmp[i].getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp[i].isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 若不是空目录，则递归添加其下的目录和文件</span></span><br><span class="line">            <span class="keyword">if</span> (tmp[i].listFiles().length != <span class="number">0</span>) &#123;</span><br><span class="line">                fileList.addAll(getAllFiles(tmp[i]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若是空目录，则添加这个目录到fileList</span></span><br><span class="line">                fileList.add(tmp[i]);</span><br><span class="line">                System.out.println(<span class="string">&quot;add empty dir: &quot;</span> + tmp[i].getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fileList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取相对路径</span></span><br><span class="line"><span class="comment"> * 依据文件名和压缩源路径得到文件在压缩源路径下的相对路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dirPath 压缩源路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 相对路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getRelativePath</span><span class="params">(String dirPath, File file)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dirPath);</span><br><span class="line">    <span class="type">String</span> <span class="variable">relativePath</span> <span class="operator">=</span> file.getName();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(relativePath);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        file = file.getParentFile();</span><br><span class="line">        <span class="keyword">if</span> (file == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (file.equals(dir)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(file.getName()).append(<span class="string">&quot;/&quot;</span>).append(relativePath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis为什么这么快</title>
      <link href="/archives/8b544b71.html"/>
      <url>/archives/8b544b71.html</url>
      
        <content type="html"><![CDATA[<h2 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在日常开发中，为了保证数据的一致性，我们一般都选择关系型数据库来存储数据，如 MySQL，Oracle 等，因为关系型数据库有着事务的特性。然而在并发量比较大的业务场景，关系型数据库却又往往会成为系统瓶颈，无法完全满足我们的需求，所以就需要使用到缓存，而非关系型数据库，即 NoSQL 数据库往往又会成为最佳选择。</p><p>NoSQL 数据库最常见的解释是 non-relational，也有人解释为 Not Only SQL。非关系型数据库不保证事务，也就是不具备事务 ACID 特性，这也是非关系型数据库和关系型数据库最大的区别，而我们即将介绍的 Redis 就属于 NoSQL 数据库的一种。</p><h3 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis?"></a>什么是Redis?</h3><p>Redis 全称是：REmote DIctionary Service，即远程字典服务。Redis 是一个开源的（遵守 BSD 协议）、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库。<br>Redis 具有以下<strong>特性</strong>：</p><ul><li>支持丰富的数据类型：字符串（strings），散列（hashes），列表（lists），集合（sets），有序集合（sorted sets），位图等。</li><li>功能丰富：提供了持久化机制，过期策略，订阅&#x2F;发布等功能。</li><li>高性能，高可用且支持集群。</li><li>提供了多种语言的 API。</li></ul><h3 id="Redis到底有多快？"><a href="#Redis到底有多快？" class="headerlink" title="Redis到底有多快？"></a>Redis到底有多快？</h3><p>大家可能都知道 Redis 很快，可是 Redis 到底能有多快呢，比如 Redis 的吞吐量能达到多少？我想这就不是每一个人都能说的上来一个具体的数字了。</p><p>Redis 官方提供了一个测试脚本，可以供我们测试 Redis 的 吞吐量。</p><ul><li>redis-benchmark -q -n 100000 可以测试常用命令的吞吐量。</li><li>redis-benchmark -t set,lpush -n 100000 -q 测试 Redis 处理 set 和 lpush 命令的吞吐量。</li><li>redis-benchmark -n 100000 -q script load “redis.call(‘set’,’foo’,’bar’)” 测试 Redis 处理 Lua 脚本等吞吐量。</li></ul><p>比如执行第一条命令来测试结果，可以看到大部分命令的吞吐量都可以达到 4 万以上，也就是说每秒钟可以处理 4 万次以上请求。<br>但是如果你以为这就是 Redis 的真实吞吐量，那就错了。实际上，Redis 官方的测试结果是可以达到 10 万的吞吐量，下图就是官方提供的一个基准测试结果（纵坐标就是吞吐量，横坐标是连接数）：<br>  <img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/tec/img.png" alt="image.png"></p><h3 id="Redis-是单线程还是多线程"><a href="#Redis-是单线程还是多线程" class="headerlink" title="Redis 是单线程还是多线程"></a>Redis 是单线程还是多线程</h3><p>这个问题比较经典，因为在很多人的认知里，Redis 就是单线程的。然而 Redis 从 4.0 版本开始就有了多线程的概念，虽然处理命令请求的核心模块确实是保证了单线程执行，然而在其他许多地方已经有了多线程，比如：在后台删除对象，通过 Redis 模块实现阻塞命令，生成 dump 文件，以及 6.0 版本中网络 I&#x2F;O 实现了多线程等，而且在未来 Redis 应该会有越来越多的模块实现多线程。</p><p>所谓的单线程，只是说 Redis 的处理客户端的请求（即执行命令）时，是单线程去执行的，并不是说整个 Redis 都是单线程。</p><h3 id="Redis-为什么选择使用单线程来执行请求"><a href="#Redis-为什么选择使用单线程来执行请求" class="headerlink" title="Redis 为什么选择使用单线程来执行请求"></a>Redis 为什么选择使用单线程来执行请求</h3><p>Redis 为什么会选择使用单线程呢？这是因为 CPU 成为 Redis 瓶颈的情况并不常见，成为 Redis 瓶颈的通常是内存或网络带宽。例如，在一个普通的 Linux 系统上使用 pipelining 命令，Redis 可以每秒完成 100 万个请求，所以如果我们的应用程序主要使用 O(N) 或 O(log(N)) 复杂度的命令，它几乎不会使用太多的 CPU。</p><p>那么既然 CPU 不会成为瓶颈，理所当然的就没必要去使用多线程来执行命令，我们需要明确的一个问题就是多线程一定比单线程快吗？答案是不一定。因为多线程也是有代价的，最直接的两个代价就是线程的创建和销毁线程（当然可以通过线程池来一定程度的减少频繁的创建线程和销毁线程）以及线程的上下文切换。</p><p>在我们的日常系统中，主要可以区分为两种：CPU 密集型 和 IO 密集型。</p><ul><li><strong>CPU 密集型</strong>：这种系统就说明 CPU 的利用率很高，那么使用多线程反而会增加上下文切换而带来额外的开销，所以使用多线程效率可能会不升反降。举个例子：假如你现在在干活，你一直不停的在做一件事，需要 1 分钟可以做完，但是你中途总是被人打断，需要花 1 秒钟时间步行到旁边去做另一件事，假如这件事也需要 1 分钟，那么你因为反复切换做两件事，每切换一次就要花 1 秒钟，最后做完这 2 件事的时间肯定大于 2 分钟（取决于中途切换的次数），但是如果中途不被打断，你做完一件事再去做另一件事，那么你最多只需要切换 1 次，也就是 2 分 1 秒就能做完。</li><li><strong>IO 密集型</strong>：IO 操作也可以分为磁盘 IO 和网络 IO 等操作。大部分 IO 操作的特点是比较耗时且 CPU 利用率不高，所以 Redis 6.0 版本网络 IO 会改进为多线程。至于磁盘 IO，因为 Redis 中的数据都存储在内存（也可以持久化），所以并不会过多的涉及到磁盘操作。举个例子：假如你现在给树苗浇水，你每浇完一次水之后就需要等别人给你加水之后你才能继续浇，那么假如这个等待过程需要 5 秒钟，也就是说你浇完一次水就可以休息 5 秒钟，而你切换去做另一件事来回只需要 2 秒，那么你完全可以先去做另一件事，做完之后再回来，这样就可以充分利用你空闲的 5 秒钟时间，从而提升了效率。<br>使用多线程还会带来一个问题就是数据的安全性，所以多线程编程都会涉及到锁竞争，由此也会带来额外的开销。</li></ul><h3 id="什么是IO多路复用"><a href="#什么是IO多路复用" class="headerlink" title="什么是IO多路复用"></a>什么是IO多路复用</h3><p>I&#x2F;O 指的是网络 I&#x2F;O， 多路指的是多个 TCP 连接（如 Socket），复用指的是复用一个或多个线程。I&#x2F;O 多路复用的核心原理就是不再由应用程序自己来监听连接，而是由服务器内核替应用程序监听。</p><p>在 Redis 中，其多路复用有多种实现，如：select，epoll，evport，kqueue 等。</p><p>我们用去餐厅吃饭为的例子来解释一下 I&#x2F;O 多路复用机制（点餐人相当于客户端，餐厅的厨房相当于服务器，厨师就是线程）。</p><ul><li><strong>阻塞 IO</strong>：张三去餐厅吃饭，点了一道菜，这时候他啥事也不干了，就是一直等，等到厨师炒好菜，他就把菜端走开始吃饭了。也就是在菜被炒好之前，张三被阻塞了，这就是 BIO（阻塞 IO），效率会非常低下。</li><li><strong>非阻塞 IO</strong>：张三去餐厅吃饭，点了一道菜，这时候张三他不会一直等，找了个位置坐下，刷刷抖音，打打电话，做点其他事，然后每隔一段时间就去厨房问一下自己的菜好了没有。这种就属于非阻塞 IO，这种方式虽然可以提高性能，但是如果有大量 IO 都来定期轮询，也会给服务器造成非常大的负担。</li><li><strong>事件驱动机制</strong>：张三去餐厅吃饭，点了一道菜，这时候他找了个位置坐下来等：</li><li>厨房那边菜做好了就会把菜端出来了，但是并不知道这道菜是谁的，于是就挨个询问顾客，这就是多路复用中的 select 模型，不过 select 模型最多只能监听 1024 个 socket（poll 模型解决了这个限制问题）。</li><li>厨房做好了菜直接把菜放在窗口上，大喊一声，某某菜做好了，是谁的快过来拿，这时候听到通知的人就会自己去拿，这就是多路复用中的 epoll 模型。<br>需要注意的是在 IO 多路复用机制下，客户端可以阻塞也可以选择不阻塞（大部分场景下是阻塞 IO），这个要具体情况具体分析，但是在多路复用机制下，服务端就可以通过多线程（上面示例中可以多几个厨师同时炒菜）来提升并发效率。</li></ul><h3 id="Redis-中-I-O-多路复用的应用"><a href="#Redis-中-I-O-多路复用的应用" class="headerlink" title="Redis 中 I&#x2F;O 多路复用的应用"></a>Redis 中 I&#x2F;O 多路复用的应用</h3><p>Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：文件事件和时间事件。</p><ul><li>文件事件：Redis 服务器和客户端（或其他服务器）进行通信会产生相应的文件事件，然后服务器通过监听并处理这些事件来完成一系列的通信操作。</li><li>时间事件：Redis 内部的一些在给定时间之内需要进行的操作。</li></ul><p>Redis 的文件事件处理器以单线程的方式运行，其内部使用了 I&#x2F;O 多路复用程序来同时监听多个套接字（Socket）连接，提升了性能的同时又保持了内部单线程设计的简单性。下图就是文件事件处理器的示意图：<br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/tec/img_1.png" alt="image.png"><br>  I&#x2F;O 多路复用程序虽然会同时监听多个 Socket 连接，但是其会将监听的 Socket 都放到一个队列里面，然后通过这个队列有序的，同步的将每个 Socket 对应的事件传送给文件事件分派器，再由文件事件分派器分派给对应的事件处理器进行处理，只有当一个 Socket 所对应的事件被处理完毕之后，I&#x2F;O多路复用程序才会继续向文件事件分派器传送下一个 Socket 所对应的事件，这也可以验证上面的结论，处理客户端的命令请求是单线程的方式逐个处理，但是事件处理器内并不是只有一个线程。</p><h2 id="总结Redis快的原因"><a href="#总结Redis快的原因" class="headerlink" title="总结Redis快的原因"></a>总结Redis快的原因</h2><p>Redis 为什么这么快的原因前面已经基本提到了，现在我们再进行总结一下：</p><ul><li>Redis 是一款纯内存结构，避免了磁盘 I&#x2F;O 等耗时操作。</li><li>Redis 命令处理的核心模块为单线程，减少了锁竞争，以及频繁创建线程和销毁线程的代价，减少了线程上下文切换的消耗。</li><li>采用了 I&#x2F;O 多路复用机制，大大提升了并发效率。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秒杀项目</title>
      <link href="/archives/3c7f8ec3.html"/>
      <url>/archives/3c7f8ec3.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、项目介绍"><a href="#1、项目介绍" class="headerlink" title="1、项目介绍"></a>1、项目介绍</h1><p> 本项目基于Springboot+Mysql+Redis+RibbitMQ+MyBatis-Plus等技术，保证了在高并发的情况下秒杀活动的 顺利进行。</p><h1 id="2、项目总结"><a href="#2、项目总结" class="headerlink" title="2、项目总结"></a>2、项目总结</h1><ul><li>首先基本秒杀功能实现</li><li>用redis进行优化，页面缓存，user对象缓存</li><li>解决复购和超卖</li><li>优化秒杀，逐步减少直接操作DB，操作reids</li><li>解决秒杀安全问题</li></ul><h1 id="3、项目功能实现"><a href="#3、项目功能实现" class="headerlink" title="3、项目功能实现"></a>3、项目功能实现</h1><h2 id="分布式会话-Session"><a href="#分布式会话-Session" class="headerlink" title="分布式会话&#x2F;Session"></a>分布式会话&#x2F;Session</h2><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><h4 id="用户登录-基础功能"><a href="#用户登录-基础功能" class="headerlink" title="用户登录-基础功能"></a>用户登录-基础功能</h4><p><strong>需求说明</strong><br>完成用户登录<br><strong>表结构设计</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `seckill_user` (</span><br><span class="line">`id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户 ID, 设为主键, 唯一手机号&#x27;</span>,  <span class="comment">--是手机号</span></span><br><span class="line">`nickname` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">`password` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;MD5(MD5(pass 明文+固定salt)+salt)&#x27;</span>, </span><br><span class="line">`slat` <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">`head` <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;头像&#x27;</span>, </span><br><span class="line">`register_date` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;注册时间&#x27;</span>, </span><br><span class="line">`last_login_date` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;最后一次登录时间&#x27;</span>, </span><br><span class="line">`login_count` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;登录次数&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p><strong>密码的设计：两次加盐</strong></p><ul><li>客户端—-md5(password 明文+<strong>salt1</strong>)–&gt; 后端(** md5(md5(password 明文+salt1)+salt2)** &#x3D;&#x3D;db中存放的 password 是否一致 ?)</li><li>通过在原始密码（字符串）的前后加上一个字符来生成 md5 加密后的密码（进行两次操作）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.seckill.util;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.DigestUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MD5Util: 工具类，根据前面密码设计方案提供相应的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MD5Util</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最基本的md5加密</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">md5</span><span class="params">(String src)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DigestUtils.md5Hex(src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备一个salt [前端使用盐]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SALT</span> <span class="operator">=</span> <span class="string">&quot;4tIY5VcX&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加密加盐, 完成的任务就是 md5(password明文+salt1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">inputPassToMidPass</span><span class="params">(String inputPass)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SALT.charAt(0)-&gt;&quot;</span> + SALT.charAt(<span class="number">0</span>));<span class="comment">//c</span></span><br><span class="line">        System.out.println(<span class="string">&quot;SALT.charAt(6)-&gt;&quot;</span> + SALT.charAt(<span class="number">6</span>));<span class="comment">//T</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> SALT.charAt(<span class="number">0</span>) + inputPass + SALT.charAt(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">return</span> md5(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加密加盐, 完成的任务就是把(MidPass +salt2) 转成DB中的密码</span></span><br><span class="line">    <span class="comment">// md5(md5(password明文+salt1)+salt2)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">midPassToDBPass</span><span class="params">(String midPass, String salt)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;salt.charAt(1)-&gt;&quot;</span> + salt.charAt(<span class="number">1</span>));<span class="comment">//L</span></span><br><span class="line">        System.out.println(<span class="string">&quot;salt.charAt(5)-&gt;&quot;</span> + salt.charAt(<span class="number">5</span>));<span class="comment">//m</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> salt.charAt(<span class="number">1</span>) + midPass + salt.charAt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> md5(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，可以将password明文，直接转成DB中的密码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">inputPassToDBPass</span><span class="params">(String inputPass, String salt)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">midPass</span> <span class="operator">=</span> inputPassToMidPass(inputPass);</span><br><span class="line">        <span class="type">String</span> <span class="variable">dbPass</span> <span class="operator">=</span> midPassToDBPass(midPass, salt);</span><br><span class="line">        <span class="keyword">return</span> dbPass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>登录信息、秒杀商品信息设计</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LoginVo: 接收用户登录时，发送的信息(mobile,password)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginVo</span> &#123;</span><br><span class="line">    <span class="comment">//对LoginVo的属性值进行，约束</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@IsMobile</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length(min = 32)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GoodsVo: 对应就是显示再秒杀商品列表的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsVo</span> <span class="keyword">extends</span> <span class="title class_">Goods</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal seckillPrice;<span class="comment">//秒杀价格</span></span><br><span class="line">    <span class="keyword">private</span> Integer stockCount;<span class="comment">//秒杀商品库存</span></span><br><span class="line">    <span class="keyword">private</span> Date startDate;<span class="comment">//秒杀开始时间</span></span><br><span class="line">    <span class="keyword">private</span> Date endDate;<span class="comment">//秒杀结束时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>请求返回信息设计</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RespBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> code;<span class="comment">//状态码</span></span><br><span class="line">    <span class="keyword">private</span> String message;  <span class="comment">//返回的信息</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;  <span class="comment">//返回的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功后-同时携带数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title function_">success</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RespBean</span>(RespBeanEnum.SUCCESS.getCode(), RespBeanEnum.SUCCESS.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功后-不携带数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RespBean</span>(RespBeanEnum.SUCCESS.getCode(), RespBeanEnum.SUCCESS.getMessage(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//失败各有不同-返回失败信息时，不携带数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title function_">error</span><span class="params">(RespBeanEnum respBeanEnum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RespBean</span>(respBeanEnum.getCode(), respBeanEnum.getMessage(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//失败各有不同-返回失败信息时，同时携带数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title function_">error</span><span class="params">(RespBeanEnum respBeanEnum, Object data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RespBean</span>(respBeanEnum.getCode(), respBeanEnum.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RespBeanEnum: 枚举类如何开发，java基础讲过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RespBeanEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通用</span></span><br><span class="line">    SUCCESS(<span class="number">200</span>,<span class="string">&quot;SUCCESS&quot;</span>),</span><br><span class="line">    ERROR(<span class="number">500</span>,<span class="string">&quot;服务端异常&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//登录</span></span><br><span class="line">    LOGIN_ERROR(<span class="number">500210</span>,<span class="string">&quot;用户id或者密码错误&quot;</span>),</span><br><span class="line">    BING_ERROR(<span class="number">500212</span>,<span class="string">&quot;参数绑定异常~&quot;</span>),</span><br><span class="line">    MOBILE_ERROR(<span class="number">500211</span>, <span class="string">&quot;手机号码格式不正确&quot;</span>),</span><br><span class="line">    MOBILE_NOT_EXIST(<span class="number">500213</span>,<span class="string">&quot;手机号码不存在&quot;</span>),</span><br><span class="line">    PASSWROD_UPDATE_FAIL(<span class="number">500214</span>,<span class="string">&quot;密码更新失败&quot;</span>),</span><br><span class="line">    <span class="comment">//其它我们在开发过程中，灵活增加即可</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀模块-返回的信息</span></span><br><span class="line">    ENTRY_STOCK(<span class="number">500500</span>,<span class="string">&quot;库存不足&quot;</span>),</span><br><span class="line">    REPEAT_ERROR(<span class="number">500501</span>,<span class="string">&quot;该商品每人限购一件&quot;</span>),</span><br><span class="line">    REQUEST_ILLEGAL(<span class="number">500502</span>,<span class="string">&quot;请求非法&quot;</span>),</span><br><span class="line">    SESSION_ERROR(<span class="number">500503</span>,<span class="string">&quot;用户信息有误..&quot;</span>),</span><br><span class="line">    SEK_KILL_WAIT(<span class="number">500504</span>,<span class="string">&quot;排队中...&quot;</span>),</span><br><span class="line">    CAPTCHA_ERROR(<span class="number">500505</span>,<span class="string">&quot;验证码错误...&quot;</span>),</span><br><span class="line">    ACCESS_LIMIT_REACHED(<span class="number">500506</span>,<span class="string">&quot;访问频繁,请待会再试...&quot;</span>),</span><br><span class="line">    SEC_KILL_RETRY(<span class="number">500507</span>,<span class="string">&quot;本次抢购失败,请继续抢购..&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>手机号码格式校验</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ValidatorUtil: 完成一些校验工作,比如手机号码格式是否正确..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class ValidatorUtil &#123;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>校验手机号码的正则表达式</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="number">13300000000</span> 合格</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="number">11000000000</span> 不合格</span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Pattern</span> mobile_pattern <span class="operator">=</span> Pattern.compile(&quot;^[1][3-9][0-9]&#123;9&#125;$&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>编写方法, 如果满足规则，返回T, 否则返回F</span><br><span class="line">    public <span class="keyword">static</span> <span class="type">boolean</span> isMobile(String mobile) &#123;</span><br><span class="line">        if(<span class="operator">!</span>StringUtils.hasText(mobile)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>进行正则表达式校验<span class="operator">-</span>java基础讲过</span><br><span class="line">        Matcher matcher <span class="operator">=</span> mobile_pattern.matcher(mobile);</span><br><span class="line">        <span class="keyword">return</span> matcher.matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="自定义校验注解"><a href="#自定义校验注解" class="headerlink" title="自定义校验注解"></a>自定义校验注解</h4><p>具体实现</p><h4 id="记录登录用户Session"><a href="#记录登录用户Session" class="headerlink" title="记录登录用户Session"></a>记录登录用户Session</h4><p>有一个CookieUtil，便于操作Cookie，直接拿来使用就行<br><strong>doLogin</strong></p><ul><li>在 UserServiceImpl  中根据 LoginVo 到数据库中查</li><li>查到后用 java.util.UUID 工具类生成票据 Ticket 用来区分 user，存入session中request.getSession().setAttribute**(ticket, user)**;</li><li>将票据存放到Cookie中 <strong>（”userTicket”, ticket）</strong></li></ul><p><strong>获取商品列表</strong></p><ul><li>有了 Cookie 和 Session 就可以在获取商品列表时进行判断了</li><li>先通过判断请求是否有userTicket，没有则返回登录</li><li>有则从Session中通过ticket（这个ticket就是userTicket）获取user</li><li>将user放入到Model传给下一个页面使用（user中包含了user的所有信息）</li></ul><h3 id="分布式Session共享"><a href="#分布式Session共享" class="headerlink" title="分布式Session共享"></a>分布式Session共享</h3><p><strong>需求说明</strong><br>Nginx对请求负载均衡到不同的Tomcat，当第二次请求到不同的Tomcat时，Tomcat会认为该用户是第一次购买，就会出现重复购买的问题。所以要进行Session共享。<br><strong>解决方案：</strong></p><ul><li>Session绑定&#x2F;粘滞</li><li>Session复制</li><li>前端存储</li><li>后端集中存储</li></ul><h4 id="SpringSession-实现分布式-Session"><a href="#SpringSession-实现分布式-Session" class="headerlink" title="SpringSession 实现分布式 Session"></a>SpringSession 实现分布式 Session</h4><p> <strong>描述：</strong>将用户 Session 不再存放到各自登录的 Tomcat 服务器，而是统一存在Redis  </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring data redis 依赖, 即 spring 整合 redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--pool2 对象池依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--实现分布式 session, 即将 Session 保存到指定的 Redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.200</span><span class="number">.130</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10000ms</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span>  <span class="comment">#最大连接数，默认是8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">10000ms</span> <span class="comment">#最大连接等待时间，默认是-1 一直等待</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">200</span>  <span class="comment">#最大空闲连接，高并发的情况下会来回切换连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">5</span>  <span class="comment">#最小空闲连接数，默认是0</span></span><br></pre></td></tr></table></figure><p>将user保存到session中改为保存到redis中： </p><ul><li>配置完后执行这句话 request.getSession().setAttribute(ticket, user); 就把session保存到redis中了</li><li>是以<strong>原始的形式</strong>保存的（保存的有session过期时间，最后访问时间等）</li></ul><h4 id="直接将用户信息统一放到Redis"><a href="#直接将用户信息统一放到Redis" class="headerlink" title="直接将用户信息统一放到Redis"></a>直接将用户信息统一放到Redis</h4><p>**描述： **前面将 Session 统一存放指定 Redis, 是以原生的形式存放, 在操作时, 还需要反序列化，不方便，我们可以直接将登录用户信息统一存放到 Redis, 利于操作<br>注销掉上面引入的spring-session-data-redis</p><ul><li><strong>使用 redisTemplate.opsForValue().set(“user:” + ticket, user);</strong></li><li>在Redis中key是 user: ticket 的格式</li><li>实现根据userTicket票据的Cookie 到 Redis中获取 user对象</li><li>刷新Cookie重新计算userTicket的过期时间</li></ul><p>GoodController中的toList方法改为直接从redis中获取user，然后放到Model中供下面使用</p><h4 id="WebMvcConfiger优化登录"><a href="#WebMvcConfiger优化登录" class="headerlink" title="WebMvcConfiger优化登录"></a>WebMvcConfiger优化登录</h4><h2 id="秒杀基本功能开发"><a href="#秒杀基本功能开发" class="headerlink" title="秒杀基本功能开发"></a>秒杀基本功能开发</h2><h3 id="商品列表"><a href="#商品列表" class="headerlink" title="商品列表"></a>商品列表</h3><p><strong>需求说明</strong><br>登录成功后可以看到商品列表<br><strong>表结构设计</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_goods` (</span><br><span class="line">`id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;商品 id&#x27;</span>, </span><br><span class="line">`goods_name` <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">`goods_title` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;商品标题&#x27;</span>, </span><br><span class="line">`goods_img` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;商品图片&#x27;</span>, </span><br><span class="line">`goods_detail` LONGTEXT <span class="keyword">not</span> <span class="keyword">null</span> COMMENT <span class="string">&#x27;商品详情&#x27;</span>,</span><br><span class="line">`goods_price` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0.00&#x27;</span> COMMENT <span class="string">&#x27;商品价格&#x27;</span>, </span><br><span class="line">`goods_stock` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;商品库存&#x27;</span>, </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>重点是id、库存</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_seckill_goods` (</span><br><span class="line">`id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">`goods_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">`seckill_price` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0.00&#x27;</span>, </span><br><span class="line">`stock_count` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">`start_date` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">`end_date` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>goods_id就是 t_goods 的主键<br><strong>设计GoodsVo</strong>，继承了Goods</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsVo</span> <span class="keyword">extends</span> <span class="title class_">Goods</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal seckillPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer stockCount;</span><br><span class="line">    <span class="keyword">private</span> Date startDate;</span><br><span class="line">    <span class="keyword">private</span> Date endDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询GoodsVo商品逻辑</strong><br><strong>把从Redis中查询到的user放model中后，再把从数据库中查出的商品放到model中</strong><br>model.addAttribute(“goodsList”, goodsService.findGoodsVo());</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findGoodsVo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hspedu.seckill.vo.GoodsVo&quot;</span>&gt;</span></span><br><span class="line">    SELECT g.id,</span><br><span class="line">           g.goods_name,</span><br><span class="line">           g.goods_title,</span><br><span class="line">           g.goods_img,</span><br><span class="line">           g.goods_detail,</span><br><span class="line">           g.goods_price,</span><br><span class="line">           g.goods_stock,</span><br><span class="line">           sg.seckill_price,</span><br><span class="line">           sg.stock_count,</span><br><span class="line">           sg.start_date,</span><br><span class="line">           sg.end_date</span><br><span class="line">    FROM t_goods g</span><br><span class="line">    LEFT JOIN t_seckill_goods sg</span><br><span class="line">    ON g.id = sg.goods_id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>商品表左连接秒杀商品表</p><h3 id="商品详情页"><a href="#商品详情页" class="headerlink" title="商品详情页"></a>商品详情页</h3><p><strong>需求说明</strong><br>在商品列表中点击查看详情会看到秒杀商品详情页<br><strong>实现逻辑</strong><br>在GoodsMapper中增加通过商品id获取GoodVo</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findGoodsVoByGoodsId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hspedu.seckill.vo.GoodsVo&quot;</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        g.id,</span><br><span class="line">        g.goods_name,</span><br><span class="line">        g.goods_title,</span><br><span class="line">        g.goods_img,</span><br><span class="line">        g.goods_detail,</span><br><span class="line">        g.goods_price,</span><br><span class="line">        g.goods_stock,</span><br><span class="line">        sg.seckill_price,</span><br><span class="line">        sg.stock_count,</span><br><span class="line">        sg.start_date,</span><br><span class="line">        sg.end_date</span><br><span class="line">    FROM t_goods g</span><br><span class="line">    LEFT JOIN t_seckill_goods sg</span><br><span class="line">    ON g.id = sg.goods_id</span><br><span class="line">    WHERE g.id=#&#123;goodsId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接入前端，根据秒杀开始时间和结束时间，在前端秒杀商品详情页有不同的显示：</p><ul><li>秒杀倒计时</li><li>秒杀进行中</li><li>秒杀结束</li></ul><h3 id="秒杀基本实现"><a href="#秒杀基本实现" class="headerlink" title="秒杀基本实现"></a>秒杀基本实现</h3><p><strong>需求说明</strong></p><ul><li>点击进行秒杀，更新库存，保存普通订单，秒杀订单</li><li>秒杀完成后进入秒杀订单页</li><li>只是最基本的功能，高并发下存在超卖的问题</li></ul><h4 id="功能1-秒杀倒计时"><a href="#功能1-秒杀倒计时" class="headerlink" title="功能1-秒杀倒计时"></a>功能1-秒杀倒计时</h4><p>在GoodsController的 toDetail 加入<br>根据查到的GoodVo的开始结束时间来鉴定秒杀状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回秒杀商品详情的同时返回该商品秒杀的状态和秒杀剩余的时间</span></span><br><span class="line"><span class="comment">//为了配合前端展示秒杀商品的状态 - 这里依然有一个业务设计</span></span><br><span class="line"><span class="comment">//1. 变量 secKillStatus 秒杀状态 0:秒杀未开始 1: 秒杀进行中 2: 秒杀已经结束</span></span><br><span class="line"><span class="comment">//2. 变量 remainSeconds 剩余秒数: &gt;0: 表示还有多久开始秒杀: 0: 秒杀进行中 -1: 表示秒杀已经结束</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">startDate</span> <span class="operator">=</span> goodsVo.getStartDate();</span><br><span class="line"><span class="type">Date</span> <span class="variable">endDate</span> <span class="operator">=</span> goodsVo.getEndDate();</span><br><span class="line"><span class="type">Date</span> <span class="variable">nowDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">//秒杀状态</span></span><br><span class="line"><span class="type">int</span> <span class="variable">secKillStatus</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//秒杀距离开始的剩余时间（单位是秒）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">remainSeconds</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nowDate.before(startDate)) &#123;</span><br><span class="line">    secKillStatus = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//得到还有多少秒开始秒杀</span></span><br><span class="line">    remainSeconds = (<span class="type">int</span>) ((startDate.getTime() - nowDate.getTime()) / <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nowDate.after(endDate)) &#123;</span><br><span class="line">    secKillStatus = <span class="number">2</span>;</span><br><span class="line">    remainSeconds = -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    secKillStatus = <span class="number">1</span>;</span><br><span class="line">    remainSeconds = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将secKillStatus 和 remainSeconds放入到model ,携带给模板页使用</span></span><br><span class="line">model.addAttribute(<span class="string">&quot;secKillStatus&quot;</span>, secKillStatus);</span><br><span class="line">model.addAttribute(<span class="string">&quot;remainSeconds&quot;</span>, remainSeconds);</span><br></pre></td></tr></table></figure><h4 id="功能2-秒杀按钮"><a href="#功能2-秒杀按钮" class="headerlink" title="功能2-秒杀按钮"></a>功能2-秒杀按钮</h4><p>前端实现的，就是按钮不到秒杀期间不能点</p><h4 id="功能3-点击按钮可以秒杀"><a href="#功能3-点击按钮可以秒杀" class="headerlink" title="功能3-点击按钮可以秒杀"></a>功能3-点击按钮可以秒杀</h4><p>秒杀成功后秒杀按钮变为立即支付，<strong>重复秒杀</strong>，<strong>库存不足</strong>都会秒杀失败（判断复购，库存）<br><strong>表设计</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_order` (</span><br><span class="line">`id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">`user_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">`goods_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">`delivery_addr_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">`goods_name` <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">`goods_count` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">`goods_price` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0.00&#x27;</span>, </span><br><span class="line">`order_channel` TINYINT(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;订单渠道1pc，2Android，3ios&#x27;</span>, </span><br><span class="line">`status` TINYINT(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;订单状态：0 新建未支付1已支付2 已发货 3 已收货 4 已退款 5 已完成&#x27;</span>,</span><br><span class="line">`create_date` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, `pay_date` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">600</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_seckill_order` (</span><br><span class="line">`id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">`user_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">`order_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">`goods_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY `seckill_uid_gid` (`user_id`,`goods_id`) <span class="keyword">USING</span> BTREE COMMENT <span class="string">&#x27; 用户id，商品 id 的唯一索引，解决同一个用户多次抢购&#x27;</span> ) </span><br><span class="line">ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">300</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p><strong>秒杀逻辑</strong><br> <strong>用户id，商品 id 的唯一索引，解决同一个用户多次抢购’  **<br>SeckillController 中的 doSeckill 方法</strong>版本1**：</p><ul><li><p>由商品列表页带来的user，供后面保存订单来使用</p></li><li><p>根据商品id直接从数据库中取出商品，看商品库存是否大于0</p></li><li><p>根据商品id和userId到数据库秒杀商品表中查询，进而判断该用户是否已经秒杀了该商品</p></li><li><p>通过了上面两个判断之后进入**orderService.seckill(user, goodsVo)**秒杀商品，生成订单</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理用户抢购请求/秒杀</span></span><br><span class="line"><span class="comment">//说明：我们先完成一个V1.0版本，后面在高并发的情况下, 还要做优化</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/doSeckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doSeckill</span><span class="params">(Model model, User user, Long goodsId)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------秒杀V1.0 开始-------&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;<span class="comment">//用户没有登录</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将user放入到model, 下一个模板可以使用</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="comment">//获取到goodsVo</span></span><br><span class="line">    <span class="type">GoodsVo</span> <span class="variable">goodsVo</span> <span class="operator">=</span> goodsService.findGoodsVoByGoodsId(goodsId);</span><br><span class="line">    <span class="comment">//判断库存</span></span><br><span class="line">    <span class="keyword">if</span> (goodsVo.getStockCount() &lt; <span class="number">1</span>) &#123;<span class="comment">//没有库存</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断用户是否复购-判断当前购买用户id和购买商品id是否已经在 商品秒杀表存在了</span></span><br><span class="line">    <span class="type">SeckillOrder</span> <span class="variable">seckillOrder</span> <span class="operator">=</span> seckillOrderService.getOne(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;SeckillOrder&gt;().eq(<span class="string">&quot;user_id&quot;</span>, user.getId())</span><br><span class="line">                    .eq(<span class="string">&quot;goods_id&quot;</span>, goodsId));</span><br><span class="line">    <span class="keyword">if</span> (seckillOrder != <span class="literal">null</span>) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.REPEAT_ERROR.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抢购</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.seckill(user, goodsVo);</span><br><span class="line">    <span class="keyword">if</span> (order == <span class="literal">null</span>) &#123; <span class="comment">//有可能执行过程中出错</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入到订单页</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;order&quot;</span>, order);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;goods&quot;</span>, goodsVo);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------秒杀V1.0 结束-------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;orderDetail&quot;</span>; <span class="comment">//进入订单详情页</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<strong>seckill</strong>方法是用来更新库存，保存普通订单，商品订单的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">seckill</span><span class="params">(User user, GoodsVo goodsVo)</span> &#123;</span><br><span class="line">    <span class="comment">//认为能进到这个代码中就是可以秒杀</span></span><br><span class="line">    <span class="comment">//查询秒杀商品的库存,并-1</span></span><br><span class="line">    <span class="type">SeckillGoods</span> <span class="variable">seckillGoods</span> <span class="operator">=</span> seckillGoodsService.</span><br><span class="line">            getOne(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;SeckillGoods&gt;().eq(<span class="string">&quot;goods_id&quot;</span>, goodsVo.getId()));</span><br><span class="line">    <span class="comment">//完成一个基本的秒杀操作[这块不具原子性],后面在高并发的情况下,还会优化, 不用急</span></span><br><span class="line">    seckillGoods.setStockCount(seckillGoods.getStockCount() - <span class="number">1</span>);</span><br><span class="line">    seckillGoodsService.updateById(seckillGoods);</span><br></pre></td></tr></table></figure><p><strong>版本1的问题</strong></p></li><li><p>从数据库拿出秒杀商品，减库存后更新到数据库，<strong>这两步操作不具备原子性</strong></p></li><li><p>查用户，查秒杀订单判断是否复购<strong>都是从数据库中查的</strong></p></li></ul><h2 id="秒杀压测Jmeter"><a href="#秒杀压测Jmeter" class="headerlink" title="秒杀压测Jmeter"></a>秒杀压测Jmeter</h2><h3 id="多用户测试"><a href="#多用户测试" class="headerlink" title="多用户测试"></a>多用户测试</h3><p><strong>测试方法</strong><br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/seckill/img1.png" alt="image.png"><br><strong>生成多用户测试脚本</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserUtil: 生成多用户测试脚本</span></span><br><span class="line"><span class="comment"> * 1. 创建多个用户,保存到seckill_user表</span></span><br><span class="line"><span class="comment"> * 2. 模拟http请求,生成jmeter压测的脚本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//生成多用户工具类</span></span><br><span class="line"><span class="comment">//创建用户，并且去登录得到userticket，得到的userTicket写入到config.txt文件内</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(<span class="type">int</span> count)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(count);</span><br><span class="line">        <span class="comment">//count表示你要创建的用户个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setId(<span class="number">13300000100L</span> + i);</span><br><span class="line">            user.setNickname(<span class="string">&quot;user&quot;</span> + i);</span><br><span class="line">            <span class="comment">//小伙伴也可以生成不同的盐,这里老师就是有一个</span></span><br><span class="line">            user.setSlat(<span class="string">&quot;ptqtXy16&quot;</span>);<span class="comment">//用户数据表的slat,由程序员设置</span></span><br><span class="line">            <span class="comment">//?是用户原始密码,比如12345 , hello等</span></span><br><span class="line">            <span class="comment">//小伙伴也可以生成不同的密码</span></span><br><span class="line">            user.setPassword(MD5Util.inputPassToDBPass(<span class="string">&quot;12345&quot;</span>, user.getSlat()));</span><br><span class="line">            users.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;create user&quot;</span>);</span><br><span class="line">        <span class="comment">//将插入数据库-seckill_user</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> getConn();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into seckill_user(nickname,slat,password,id) values(?,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; users.size(); i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> users.get(i);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, user.getNickname());</span><br><span class="line">            preparedStatement.setString(<span class="number">2</span>, user.getSlat());</span><br><span class="line">            preparedStatement.setString(<span class="number">3</span>, user.getPassword());</span><br><span class="line">            preparedStatement.setLong(<span class="number">4</span>, user.getId());</span><br><span class="line">            preparedStatement.addBatch();</span><br><span class="line">        &#125;</span><br><span class="line">        preparedStatement.executeBatch();</span><br><span class="line">        preparedStatement.clearParameters();<span class="comment">//关闭</span></span><br><span class="line">        connection.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;insert to do&quot;</span>);</span><br><span class="line">        <span class="comment">//模拟登录,发出登录拿到userTicket</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">urlStr</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8080/login/doLogin&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aHspJava\\projects\\iSecKill\\tool\\temp\\config.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        raf.seek(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; users.size(); i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> users.get(i);</span><br><span class="line">            <span class="comment">//请求</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(urlStr);</span><br><span class="line">            <span class="comment">//使用HttpURLConnection 发出http请求</span></span><br><span class="line">            <span class="type">HttpURLConnection</span> <span class="variable">co</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">            co.setRequestMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">            <span class="comment">//设置输入网页密码（相当于输出到页面）</span></span><br><span class="line">            co.setDoOutput(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> co.getOutputStream();</span><br><span class="line">            <span class="type">String</span> <span class="variable">params</span> <span class="operator">=</span> <span class="string">&quot;mobile=&quot;</span> + user.getId() + <span class="string">&quot;&amp;password=&quot;</span> + MD5Util.inputPassToMidPass(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">            outputStream.write(params.getBytes());</span><br><span class="line">            outputStream.flush();</span><br><span class="line">            <span class="comment">//获取网页输出，（得到输入流，把结果得到，再输出到ByteArrayOutputStream内）</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> co.getInputStream();</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                bout.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            inputStream.close();</span><br><span class="line">            bout.close();</span><br><span class="line">            <span class="comment">//把ByteArrayOutputStream内的东西转换为respBean对象</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bout.toByteArray());</span><br><span class="line">            <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">            <span class="type">RespBean</span> <span class="variable">respBean</span> <span class="operator">=</span> mapper.readValue(response, RespBean.class);</span><br><span class="line">            <span class="comment">//得到userTicket</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">userTicket</span> <span class="operator">=</span> (String) respBean.getObj();</span><br><span class="line">            System.out.println(<span class="string">&quot;create userTicket&quot;</span> + userTicket);</span><br><span class="line">            <span class="type">String</span> <span class="variable">row</span> <span class="operator">=</span> user.getId() + <span class="string">&quot;,&quot;</span> + userTicket;</span><br><span class="line">            <span class="comment">//写入指定文件</span></span><br><span class="line">            raf.seek(raf.length());</span><br><span class="line">            raf.write(row.getBytes());</span><br><span class="line">            raf.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;write to file:&quot;</span> + user.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        raf.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">getConn</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/seckill?useSSL=false&amp;useUnicode=false&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;19419&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        create(<span class="number">2000</span>);<span class="comment">//这里创建了2000个用户.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用Jmeter模拟多用户并发请求，发现出现超卖–后续解决</strong></p><h2 id="页面优化"><a href="#页面优化" class="headerlink" title="页面优化"></a>页面优化</h2><h3 id="redis页面缓存"><a href="#redis页面缓存" class="headerlink" title="redis页面缓存"></a>redis页面缓存</h3><p><strong>需求说明</strong></p><ul><li><a href="#xHjJs">在2.1 2.2中</a>， 多用户在查看<strong>商品列表</strong>和<strong>商品详情页</strong>的时候, 每一个用户都需要到DB 查询  </li><li>对 DB 查询的压力很大  </li><li>但是我们商品信息并不会频繁的变化, 所以你查询回来的结果都是一样的  </li><li>我们可以通过 Redis 缓存页面来进行优化, 这样可以将 1 分钟内多次查询DB, 优化成1次查询, 减少 DB 压力</li></ul><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/seckill/img2.png"><br><strong>WebContext就是上下文内容，当作一个常规的用法，知道怎么去使用就行</strong><br>设置过期时间60s</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入到商品列表单-改进的到redis中查询</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/toList&quot;, produces = &quot;text/html;charset=utf-8&quot;)</span> <span class="comment">//返回的编码</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toList</span><span class="params">(Model model, User user, HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果redis中有就直接返回，没有的话再继续往下走</span></span><br><span class="line">        <span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line">        <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> (String) valueOperations.get(<span class="string">&quot;goodsList&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(html))&#123;</span><br><span class="line">            <span class="keyword">return</span> html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将user放入到model，给下一个模板使用</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="comment">//将商品列表信息,放入到model,携带该下一个模板使用</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;goodsList&quot;</span>, goodsService.findGoodsVo());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果从redis中没有获取到页面，就手动渲染然后存到redis中 WebContext就是上下文内容，当作一个常规的用法，知道怎么去使用就行</span></span><br><span class="line">        <span class="comment">//说白了就是把WebContext上下文获取到，并且把model传进去</span></span><br><span class="line">        <span class="type">WebContext</span> <span class="variable">webContext</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WebContext</span>(request, response, request.getServletContext(), request.getLocale(), model.asMap());</span><br><span class="line">        <span class="comment">//处理了一个模板页，取了个名称叫goodsList，内容是从webContext中来的</span></span><br><span class="line">        <span class="comment">//上面没从redis中拿到html，就从这里给html赋值</span></span><br><span class="line">        <span class="comment">//goodsList来自templates中的goodsList.html，之前是走流程渲染的，现在是手动渲染到goodsList.html页面</span></span><br><span class="line">        html = thymeleafViewResolver.getTemplateEngine().process(<span class="string">&quot;goodsList&quot;</span>, webContext);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(html))&#123;  <span class="comment">//有内容说明渲染成功</span></span><br><span class="line">            <span class="comment">//将页面保存到redis，设置没60秒更新一次，该页面60秒失效，redis会清除这个页面，因为期间页面可能会变化</span></span><br><span class="line">            <span class="comment">//这个goodsList代表在redis中缓存的时候给key取得名称</span></span><br><span class="line">            valueOperations.set(<span class="string">&quot;goodsList&quot;</span>, html, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> html;</span><br><span class="line"><span class="comment">//        return &quot;goodsList&quot;;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入商品详情页-根据goodsId</span></span><br><span class="line"><span class="comment">//user是从自定义参数解析器完成带来的</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/toDetail/&#123;goodsId&#125;&quot;, produces = &quot;text/html;charset=utf-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toDetail</span><span class="params">(Model model, User user, <span class="meta">@PathVariable(&quot;goodsId&quot;)</span> Long goodsId,</span></span><br><span class="line"><span class="params">                       HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果redis中有就直接返回，没有的话再继续往下走</span></span><br><span class="line">    <span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line">    <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> (String) valueOperations.get(<span class="string">&quot;goodsDetail:&quot;</span> + goodsId);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.hasText(html))&#123;</span><br><span class="line">        <span class="keyword">return</span> html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放到model中，带给前端页面会用</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="type">GoodsVo</span> <span class="variable">goodsVo</span> <span class="operator">=</span> goodsService.findGoodsVoByGoodsId(goodsId);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;goods&quot;</span>, goodsVo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回秒杀商品详情的同时返回该商品秒杀的状态和秒杀剩余的时间</span></span><br><span class="line">    <span class="comment">//为了配合前端展示秒杀商品的状态 - 这里依然有一个业务设计</span></span><br><span class="line">    <span class="comment">//1. 变量 secKillStatus 秒杀状态 0:秒杀未开始 1: 秒杀进行中 2: 秒杀已经结束</span></span><br><span class="line">    <span class="comment">//2. 变量 remainSeconds 剩余秒数: &gt;0: 表示还有多久开始秒杀: 0: 秒杀进行中 -1: 表示秒杀已经结束</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">startDate</span> <span class="operator">=</span> goodsVo.getStartDate();</span><br><span class="line">    <span class="type">Date</span> <span class="variable">endDate</span> <span class="operator">=</span> goodsVo.getEndDate();</span><br><span class="line">    <span class="type">Date</span> <span class="variable">nowDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//秒杀状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">secKillStatus</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//秒杀距离开始的剩余时间（单位是秒）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainSeconds</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nowDate.before(startDate)) &#123;</span><br><span class="line">        secKillStatus = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//得到还有多少秒开始秒杀</span></span><br><span class="line">        remainSeconds = (<span class="type">int</span>) ((startDate.getTime() - nowDate.getTime()) / <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nowDate.after(endDate)) &#123;</span><br><span class="line">        secKillStatus = <span class="number">2</span>;</span><br><span class="line">        remainSeconds = -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        secKillStatus = <span class="number">1</span>;</span><br><span class="line">        remainSeconds = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将secKillStatus 和 remainSeconds放入到model ,携带给模板页使用</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;secKillStatus&quot;</span>, secKillStatus);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;remainSeconds&quot;</span>, remainSeconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果从redis中没有获取到页面，就手动渲染商品详情页然后存到redis中</span></span><br><span class="line">    <span class="comment">//说白了就是把WebContext上下文获取到，并且把model传进去</span></span><br><span class="line">    <span class="type">WebContext</span> <span class="variable">webContext</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">WebContext</span>(request, response, request.getServletContext(), request.getLocale(), model.asMap());</span><br><span class="line">    <span class="comment">//上面没从redis中拿到html，就从这里给html赋值</span></span><br><span class="line">    html = thymeleafViewResolver.getTemplateEngine().process(<span class="string">&quot;goodsDetail&quot;</span>, webContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.hasText(html))&#123;  <span class="comment">//有内容说明渲染成功</span></span><br><span class="line">        <span class="comment">//将页面保存到redis，设置没60秒更新一次，该页面60秒失效，redis会清除这个页面，因为期间页面可能会变化</span></span><br><span class="line">        <span class="comment">//这个goodsList代表在redis中缓存的时候给key取得名称</span></span><br><span class="line">        valueOperations.set(<span class="string">&quot;goodsDetail:&quot;</span> + goodsId, html, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象缓存"><a href="#对象缓存" class="headerlink" title="对象缓存"></a>对象缓存</h3><p><strong>需求说明</strong></p><ul><li><a href="#uRGjD">1.2.2</a>中当用户登录成功后, 就会将用户对象缓存到 Redis  </li><li>好处是解决了分布式架构下的 Session 共享问题  </li><li>但是也带来新问题, 如果用户信息改变, DB用户信息和Redis 缓存用户对象不一致问题-也就是对象缓存问题</li></ul><p><strong>解决思路</strong></p><ul><li>编写方法, 当用户信息变化时, 就更新用户在 DB 的信息, 同时删除该用户在Redis的缓存对象  </li><li>这样用户就需要使用新密码重新登录, 从而更新用户在 Redis 对应的缓存对象</li></ul><h2 id="复购和超卖"><a href="#复购和超卖" class="headerlink" title="复购和超卖"></a>复购和超卖</h2><h3 id="超卖"><a href="#超卖" class="headerlink" title="超卖"></a>超卖</h3><p><strong>需求说明</strong><br><a href="#fnMe4">解决2.3.3中</a>doSeckill 方法版本1的超卖问题<br><strong>出现超卖问题的原因</strong></p><ul><li>在SeckillController 中判断复购，库存之后就进入到OrderServiceImpl中的seckill方法进行秒杀</li><li>而在高并发下可能同时200个请求同时执行判断库存的语句，都通过了库存判断</li><li>然后都冲入到OrderServiceImpl中的seckill方法，而该方法中<strong>减库存的操作不具备原子性</strong></li><li>可能多个请求才减去1个商品，而冲到seckill中的请求都会生成订单</li></ul><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/seckill/img3.png" alt="image.png"><br><strong>解决思路</strong></p><ul><li>Mysql在默认的事务隔离级别（可重复读）下，执行update语句时,会在事务中锁定要更新的行</li><li>这可以防止其他会话在同一行上执行 <strong>UPDATE</strong> 或DELETE操作  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">seckill</span><span class="params">(User user, GoodsVo goodsVo)</span> &#123;</span><br><span class="line">    <span class="comment">//认为能进到这个代码中就是可以秒杀</span></span><br><span class="line">    <span class="comment">//查询秒杀商品的库存,并-1</span></span><br><span class="line">    <span class="type">SeckillGoods</span> <span class="variable">seckillGoods</span> <span class="operator">=</span> seckillGoodsService.</span><br><span class="line">            getOne(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;SeckillGoods&gt;().eq(<span class="string">&quot;goods_id&quot;</span>, goodsVo.getId()));</span><br><span class="line">    <span class="comment">//完成一个基本的秒杀操作[这块不具原子性],后面在高并发的情况下,还会优化, 不用急</span></span><br><span class="line"><span class="comment">//        seckillGoods.setStockCount(seckillGoods.getStockCount() - 1);</span></span><br><span class="line"><span class="comment">//        seckillGoodsService.updateById(seckillGoods);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. Mysql在默认的事务隔离级[REPEATABLE-READ]别下</span></span><br><span class="line">    <span class="comment">//2. 执行update语句时,会在事务中锁定要更新的行</span></span><br><span class="line">    <span class="comment">//3. 这样可以防止其它会话在同一行执行update,delete</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行update==&gt;&quot;</span> + user.getId());</span><br><span class="line">    <span class="comment">//只要在更新成功时,返回true,否则返回false, 即更新后，受影响的行数&gt;=1为T</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">update</span> <span class="operator">=</span> seckillGoodsService.update(<span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;SeckillGoods&gt;()</span><br><span class="line">            .setSql(<span class="string">&quot;stock_count=stock_count-1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;goods_id&quot;</span>, goodsVo.getId()).gt(<span class="string">&quot;stock_count&quot;</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!update) &#123;<span class="comment">//如果更新失败,说明已经没有库存了</span></span><br><span class="line">        <span class="comment">//把这个秒杀失败的信息-记录到Redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;seckillFail:&quot;</span> + user.getId() + <span class="string">&quot;:&quot;</span> + goodsVo.getId(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成普通订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    order.setUserId(user.getId());</span><br><span class="line">    order.setGoodsId(goodsVo.getId());</span><br><span class="line">    order.setDeliveryAddrId(<span class="number">0L</span>);<span class="comment">//老师就设置一个初始值</span></span><br><span class="line">    order.setGoodsName(goodsVo.getGoodsName());</span><br><span class="line">    order.setGoodsCount(<span class="number">1</span>);</span><br><span class="line">    order.setGoodsPrice(seckillGoods.getSeckillPrice());  <span class="comment">//秒杀的价格</span></span><br><span class="line">    order.setOrderChannel(<span class="number">1</span>);<span class="comment">//老师就设置一个初始值</span></span><br><span class="line">    order.setStatus(<span class="number">0</span>);<span class="comment">//老师就设置一个初始值-未支付</span></span><br><span class="line">    order.setCreateDate(<span class="keyword">new</span> <span class="title class_">Date</span>());<span class="comment">//设置成now</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存order</span></span><br><span class="line">    orderMapper.insert(order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成秒杀商品订单-</span></span><br><span class="line">    <span class="type">SeckillOrder</span> <span class="variable">seckillOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillOrder</span>();</span><br><span class="line">    seckillOrder.setGoodsId(goodsVo.getId());</span><br><span class="line">    <span class="comment">//这里秒杀商品订单对应的order_id 是从上面添加 order后获取到的</span></span><br><span class="line">    seckillOrder.setOrderId(order.getId());</span><br><span class="line">    seckillOrder.setUserId(user.getId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存seckillOrder 用mapper也行</span></span><br><span class="line">    seckillOrderService.save(seckillOrder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将生成的秒杀订单，存入到Redis, 这样在查询某个用户是否已经秒杀了这个商品时，</span></span><br><span class="line">    <span class="comment">//直接到Redis中查询，起到优化效果</span></span><br><span class="line">    <span class="comment">//设计秒杀订单的key =&gt; order:用户id:商品id</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;order:&quot;</span> + user.getId() + <span class="string">&quot;:&quot;</span> + goodsVo.getId(), seckillOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>使用update代替下面原来减库存的语句（Mybatis-plus）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeckillGoodsServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;SeckillGoodsMapper, SeckillGoods&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">SeckillGoodsService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">update</span> <span class="operator">=</span> seckillGoodsService.update(<span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;SeckillGoods&gt;()</span><br><span class="line">                .setSql(<span class="string">&quot;stock_count=stock_count-1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;goods_id&quot;</span>, goodsVo.getId()).gt(<span class="string">&quot;stock_count&quot;</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>这样减库存的操作就是串行执行的了，库存小于1会更新失败，也不会生成订单了<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!update) &#123;</span><br><span class="line">    <span class="comment">//如果更新失败,说明已经没有库存了，把这个秒杀失败的信息-记录到Redis</span></span><br><span class="line">    redisTemplate.opsForValue()</span><br><span class="line">    .set(<span class="string">&quot;seckillFail:&quot;</span> + user.getId() + <span class="string">&quot;:&quot;</span> + goodsVo.getId(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当然了，这样解决仍有大量的请求进入seckill然后到DB中执行sql，后面会优化</li></ul><h3 id="复购"><a href="#复购" class="headerlink" title="复购"></a>复购</h3><p><strong>需求说明</strong></p><ul><li><a href="#fnMe4">对版本1进行优化</a>，不去数据库看是否存在该用户对此商品的秒杀订单</li><li>而是把生成的订单放到redis中，后面直接从redis中判断是否复购</li><li>就是seckill最后生成秒杀订单后设置到redis中</li></ul><h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><h3 id="预减库存-Decrement"><a href="#预减库存-Decrement" class="headerlink" title="预减库存+Decrement"></a>预减库存+Decrement</h3><p><strong>目的就是减少去到数据库中的操作</strong><br><strong>需求说明</strong></p><ul><li><a href="#fnMe4">在2.3.3中</a>防止超卖，SeckillController 是直接到数据库查出商品的 goodsService.findGoodsVoByGoodsId(goodsId);    初步判断的库存，并发下不准确</li><li>大量的并发请求都去<strong>到数据库中尝试减库存的操作</strong>，虽然控制了超卖，但容易把数据库压垮</li></ul><p><strong>解决思路</strong></p><ul><li>使用 Redis 完成<strong>预减库存</strong>，如果没有库存了, 直接返回, 减小对DB的压力  </li><li><strong>如果预减库存后，库存小于0就不再去orderService.seckill()中了</strong></li><li><strong>结果就是库存有多少就进去几个请求</strong></li><li><strong>依赖decrement具有原子性</strong>，redisTemplate.opsForValue().<strong>decrement(“seckillGoods:” + goodsId);</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//库存预减, 如果在Redis中预减库存，发现秒杀商品已经没有了，就直接返回</span></span><br><span class="line"><span class="comment">//从而减少去执行 orderService.seckill() 请求,防止线程堆积, 优化秒杀/高并发</span></span><br><span class="line"><span class="comment">// decrement()是具有原子性!!</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">decrement</span> <span class="operator">=</span> redisTemplate.opsForValue().decrement(<span class="string">&quot;seckillGoods:&quot;</span> + goodsId);</span><br><span class="line"><span class="keyword">if</span> (decrement &lt; <span class="number">0</span>) &#123;<span class="comment">//说明这个商品已经没有库存</span></span><br><span class="line">    <span class="comment">//恢复库存为0</span></span><br><span class="line">    redisTemplate.opsForValue().increment(<span class="string">&quot;seckillGoods:&quot;</span> + goodsId);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>**前奏：SeckillController的初始化方法，从数据库查出所有的秒杀商品，然后存到redis中 seckillGoods : id **<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个方法是在类的所有属性，都初始化后，自动执行的</span></span><br><span class="line"><span class="comment">//这里把所有秒杀商品的库存量加载到redis</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//查询所有的秒杀商品</span></span><br><span class="line">    List&lt;GoodsVo&gt; list = goodsService.findGoodsVo();</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历List，然后将秒杀商品的库存量放入到redis</span></span><br><span class="line">    <span class="comment">//秒杀商品库存量对应key: seckillGoods:商品id</span></span><br><span class="line">    list.forEach(goodsVo -&gt; &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;seckillGoods:&quot;</span> + goodsVo.getId(), goodsVo.getStockCount());</span><br><span class="line">        <span class="comment">//初始化map</span></span><br><span class="line">        <span class="comment">//如果goodsId : false 表示有库存</span></span><br><span class="line">        <span class="comment">//如果goodsId : true 表示没有库存</span></span><br><span class="line">        entryStockMap.put(goodsVo.getId(), <span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="加入内存标记"><a href="#加入内存标记" class="headerlink" title="加入内存标记"></a>加入内存标记</h3><p><strong>目的就是减少到redis中预减库存</strong><br><strong>需求说明</strong></p><ul><li>如果某个商品库存已经为空了，我们仍然是到 Redis 去查询的，还可以进行优化  </li><li>给商品进行内存标记，如果库存为空，直接返回，避免总是到Redis 查询库存</li></ul><p><strong>解决思路</strong><br><strong>操作本机JVM快于操作Redis</strong><br><strong>添加属性    private HashMap&lt;Long, Boolean&gt; entryStockMap &#x3D; new HashMap&lt;&gt;();</strong></p><ul><li>在到redis中预减库存之前，先查看entryStockMap，如果标记为true，则表示redis中的库存已经为0</li><li>不再去redis中预减</li><li>如果是redis中库存<strong>第一次</strong>不足，预减后设置标记为true<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理用户抢购请求/秒杀</span></span><br><span class="line"><span class="comment">//说明：我们先完成一个V4.0版本，加入内存标记优化秒杀</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/doSeckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doSeckill</span><span class="params">(Model model, User user, Long goodsId)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------秒杀V4.0 开始-------&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    </span><br><span class="line">    <span class="type">GoodsVo</span> <span class="variable">goodsVo</span> <span class="operator">=</span> goodsService.findGoodsVoByGoodsId(goodsId);</span><br><span class="line">    <span class="comment">//判断库存</span></span><br><span class="line">    <span class="keyword">if</span> (goodsVo.getStockCount() &lt; <span class="number">1</span>) &#123;<span class="comment">//没有库存</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断用户是否复购</span></span><br><span class="line">    <span class="type">SeckillOrder</span> <span class="variable">seckillOrder</span> <span class="operator">=</span> (SeckillOrder) redisTemplate.opsForValue().get(<span class="string">&quot;order:&quot;</span> + user.getId() + <span class="string">&quot;:&quot;</span> + goodsId);</span><br><span class="line">    <span class="keyword">if</span> (seckillOrder != <span class="literal">null</span>) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.REPEAT_ERROR.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对map进行判断[内存标记],如果商品在map已经标记为没有库存，则直接返回，无需进行Redis预减</span></span><br><span class="line">    <span class="keyword">if</span> (entryStockMap.get(goodsId)) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//库存预减, 如果在Redis中预减库存，发现秒杀商品已经没有了，就直接返回</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">decrement</span> <span class="operator">=</span> redisTemplate.opsForValue().decrement(<span class="string">&quot;seckillGoods:&quot;</span> + goodsId);</span><br><span class="line">    <span class="keyword">if</span> (decrement &lt; <span class="number">0</span>) &#123;<span class="comment">//说明这个商品已经没有库存</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//就是在这设置了内存标记之后，相当于直接告诉后来的请求说已经没有库存了，不用再去redis中预减了。截断的效果</span></span><br><span class="line">        entryStockMap.put(goodsId, <span class="literal">true</span>);  <span class="comment">//定义的true是代表没有库存了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//恢复库存为0</span></span><br><span class="line">        redisTemplate.opsForValue().increment(<span class="string">&quot;seckillGoods:&quot;</span> + goodsId);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抢购</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.seckill(user, goodsVo);</span><br><span class="line">    <span class="keyword">if</span> (order == <span class="literal">null</span>) &#123; <span class="comment">//有可能执行过程中出错</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入到订单页</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;order&quot;</span>, order);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;goods&quot;</span>, goodsVo);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------秒杀V4.0 结束-------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;orderDetail&quot;</span>; <span class="comment">//进入订单详情页</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="加入消息队列，秒杀异步请求"><a href="#加入消息队列，秒杀异步请求" class="headerlink" title="加入消息队列，秒杀异步请求"></a>加入消息队列，秒杀异步请求</h3><p><strong>目的是把执行seckill交给消息队列，赶紧返回客户端消息，防止线程堆积</strong><br><strong>需求说明</strong></p><ul><li>前面秒杀, 没有实现异步机制, 是<strong>完成下订单后, 再返回</strong>的</li><li>当有大并发请求下订单操作时, 数据库来不及响应, 容易造成<strong>线程堆积</strong></li></ul><p><strong>解决思路</strong></p><ul><li>加入消息队列，实现秒杀的异步请求  </li><li>接收到客户端秒杀请求后，<strong>服务器立即返回 正在秒杀中..</strong>, 有利于流量削峰  </li><li>客户端进行轮询秒杀结果, 接收到秒杀结果后，在客户端页面显示即可</li></ul><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/seckill/img4.png" alt="秒杀加入消息队列逻辑"><br><strong>使用的是RabbotMQ的Topic主题模式</strong>（Direct路由模式下的一种扩展）<br>把秒杀操作seckill移到消息消费者，然后消费者执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SeckillMessage: 秒杀消息对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeckillMessage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="keyword">private</span> Long goodsId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>秒杀消息组成：</p><ul><li>用户 user</li><li>商品id goodsId<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQSeckillConfig: 配置类，创建消息队列和交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQSeckillConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义消息队列名和交换机名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE</span> <span class="operator">=</span> <span class="string">&quot;seckillQueue&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;seckillExchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue_seckill</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建交换机-Topic</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TopicExchange <span class="title function_">topicExchange_seckill</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将队列绑定到交换机，并指定路由</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding_seckill</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue_seckill())</span><br><span class="line">        .to(topicExchange_seckill()).with(<span class="string">&quot;seckill.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MQSenderMessage: 消息的生产者/发送者[秒杀消息]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQSenderMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装配RabbitTemplate</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法：发送秒杀消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSeckillMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;发送消息--&gt;&quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;seckillExchange&quot;</span>, <span class="string">&quot;seckill.message&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>发送的是String<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MQReceiverMessage: 消息的接收者/消费者, 这里调用seckill方法()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQReceiverMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装配需要的组件/对象</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> GoodsService goodsService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息，并完成下单</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;seckillQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queue</span><span class="params">(String message)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;接收到的消息是--&gt;&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解读，这里我们从队列中取出的是string</span></span><br><span class="line">        <span class="comment">//但是我们需要的是SeckillMessage, 因此需要一个工具类JSONUtil</span></span><br><span class="line">        <span class="comment">//在hutool依赖</span></span><br><span class="line">        <span class="type">SeckillMessage</span> <span class="variable">seckillMessage</span> <span class="operator">=</span></span><br><span class="line">                JSONUtil.toBean(message, SeckillMessage.class);</span><br><span class="line">        <span class="comment">//秒杀用户对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> seckillMessage.getUser();</span><br><span class="line">        <span class="comment">//秒杀的商品id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">goodsId</span> <span class="operator">=</span> seckillMessage.getGoodsId();</span><br><span class="line">        <span class="comment">//通过商品id,得到对应的GoodsVo</span></span><br><span class="line">        <span class="type">GoodsVo</span> <span class="variable">goodsVo</span> <span class="operator">=</span> goodsService.findGoodsVoByGoodsId(goodsId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下单操作</span></span><br><span class="line">        orderService.seckill(user, goodsVo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>用工具类JSONUtil把String转为SeckillMessage<br>SeckillController 中抢购的代码变化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抢购</span></span><br><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.seckill(user, goodsVo);</span><br><span class="line"><span class="keyword">if</span> (order == <span class="literal">null</span>) &#123; <span class="comment">//有可能执行过程中出错</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抢购,向消息队列发送秒杀请求,实现了秒杀异步请求</span></span><br><span class="line"><span class="comment">//这里我们发送秒杀消息后，立即快速返回结果[临时结果] - &quot;比如排队中..&quot;</span></span><br><span class="line"><span class="comment">//客户端可以通过轮询，获取到最终结果</span></span><br><span class="line"><span class="comment">//创建SeckillMessage</span></span><br><span class="line"><span class="type">SeckillMessage</span> <span class="variable">seckillMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillMessage</span>(user, goodsId);</span><br><span class="line">mqSenderMessage.sendSeckillMessage(JSONUtil.toJsonStr(seckillMessage));</span><br><span class="line">model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, <span class="string">&quot;排队中...&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="秒杀安全"><a href="#秒杀安全" class="headerlink" title="秒杀安全"></a>秒杀安全</h2><h3 id="秒杀接口地址隐藏"><a href="#秒杀接口地址隐藏" class="headerlink" title="秒杀接口地址隐藏"></a>秒杀接口地址隐藏</h3><p><strong>需求说明</strong></p><ul><li>前面我们处理高并发, 是按照正常业务逻辑处理的, 也就是用户正常抢购  </li><li>还需要考虑抢购安全性, 当前程序, <strong>抢购接口是固定, 如果泄露, 会有安全隐患</strong>, 比如抢购未开始或者已结束, 还可以使用脚本发起抢购</li></ul><p><strong>解决思路</strong></p><ul><li>隐藏抢购接口  </li><li>用户抢购时, 先<strong>生成一个唯一的抢购路径, 返回给客户端</strong>  </li><li>客户端抢购时会携带生成的抢购路径, <strong>服务端做校验</strong>, 如果校验成功, 才走下一步, 否则直接返回</li></ul><p><strong>解决过程</strong><br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/seckill/img5.png" alt="image.png"><br><strong>OrderServiceImpl生成的秒杀路径放到redis中，便于后面到redis中校验</strong><br>set(“<strong>seckillPath:”+ user.getId() + “:” + goodsId</strong>，<strong>path</strong>, 60, TimeUnit.SECONDS);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法: 生成秒杀路径/值(唯一)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">createPath</span><span class="params">(User user, Long goodsId)</span> &#123;</span><br><span class="line">    <span class="comment">//生成秒杀路径/值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> MD5Util.md5(UUIDUtil.uuid());</span><br><span class="line">    <span class="comment">//将随机生成的路径保存到Redis, 设置一个超时时间60s</span></span><br><span class="line">    <span class="comment">//key的设计: seckillPath:userId:goodsId</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;seckillPath:&quot;</span>+ user.getId() + <span class="string">&quot;:&quot;</span> + goodsId,</span><br><span class="line">            path, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法: 对秒杀路径进行校验</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPath</span><span class="params">(User user, Long goodsId, String path)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || goodsId &lt; <span class="number">0</span> || !StringUtils.hasText(path)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出该用户秒杀该商品的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">redisPath</span> <span class="operator">=</span> (String) redisTemplate.opsForValue()</span><br><span class="line">                        .get(<span class="string">&quot;seckillPath:&quot;</span> + user.getId() + <span class="string">&quot;:&quot;</span> + goodsId);</span><br><span class="line">    <span class="keyword">return</span> path.equals(redisPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在OrderController中增加getPath，createPath后返回给客户端</strong><br>然后客户端带着新路径再次发出秒杀请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法：获取秒杀路径</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/path&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@AccessLimit(second = 5, maxCount = 5, needLogin = true)</span></span><br><span class="line"><span class="keyword">public</span> RespBean <span class="title function_">getPath</span><span class="params">(User user, Long goodsId, String captcha, HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || goodsId &lt; <span class="number">0</span> || !StringUtils.hasText(captcha)) &#123;</span><br><span class="line">        <span class="keyword">return</span> RespBean.error(RespBeanEnum.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> orderService.createPath(user, goodsId);</span><br><span class="line">    <span class="keyword">return</span> RespBean.success(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在SeckillController做地址校验，路径正确了再忘下一步走</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理用户抢购请求/秒杀</span></span><br><span class="line"><span class="comment">//说明：我们先完成一个V6.0版本，加入秒杀安全，直接返回RespBean，不再去下一个页面了</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&#123;path&#125;/doSeckill&quot;)</span>  <span class="comment">//每一个秒杀的路径都不一样</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> RespBean <span class="title function_">doSeckill</span><span class="params">(<span class="meta">@PathVariable</span> String path, Model model, User user, Long goodsId)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------秒杀V6.0 开始-------&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;<span class="comment">//用户没有登录</span></span><br><span class="line">        <span class="keyword">return</span> RespBean.error(RespBeanEnum.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里增加一个逻辑，校验用户携带的path是否正确</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">checkPath</span> <span class="operator">=</span> orderService.checkPath(user, goodsId, path);</span><br><span class="line">    <span class="keyword">if</span>(!checkPath)&#123;</span><br><span class="line">        <span class="keyword">return</span> RespBean.error(RespBeanEnum.REQUEST_ILLEGAL);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="验证码防止脚本攻击"><a href="#验证码防止脚本攻击" class="headerlink" title="验证码防止脚本攻击"></a>验证码防止脚本攻击</h3><p><strong>需求说明</strong></p><ul><li>在一些抢购活动中, 可以通过验证码的方式, 防止脚本攻击, 比如12306</li></ul><p><strong>解决思路</strong></p><ul><li>使用验证码 happyCaptcha  ![image.png.&#x2F;.&#x2F;duskimg&#x2F;seckill&#x2F;img6.png)</li></ul><p><strong>解决过程</strong><br><strong>在SeckillController中增加方法生成验证码，保存到reids，便于后面校验</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成验证码-happyCaptcha</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/captcha&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">happyCaptcha</span><span class="params">(HttpServletRequest request, HttpServletResponse response, User user, Long goodsId)</span> &#123;</span><br><span class="line">    <span class="comment">//生成验证码，并输出</span></span><br><span class="line">    <span class="comment">//注意，该验证码，默认就保存到session中, key是 happy-captcha</span></span><br><span class="line">    HappyCaptcha.require(request, response)</span><br><span class="line">            .style(CaptchaStyle.ANIM)               <span class="comment">//设置展现样式为动画</span></span><br><span class="line">            .type(CaptchaType.NUMBER)               <span class="comment">//设置验证码内容为数字</span></span><br><span class="line">            .length(<span class="number">6</span>)                              <span class="comment">//设置字符长度为6</span></span><br><span class="line">            .width(<span class="number">220</span>)                             <span class="comment">//设置动画宽度为220</span></span><br><span class="line">            .height(<span class="number">80</span>)                             <span class="comment">//设置动画高度为80</span></span><br><span class="line">            .font(Fonts.getInstance().zhFont())     <span class="comment">//设置汉字的字体</span></span><br><span class="line">            .build().finish();                      <span class="comment">//生成并输出验证码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//把验证码的值，保存Redis [考虑项目分布式], 设置了验证码的失效时间100s</span></span><br><span class="line">    <span class="comment">//key: captcha:userId:goodsId</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;captcha:&quot;</span> + user.getId() + <span class="string">&quot;:&quot;</span> + goodsId</span><br><span class="line">            , (String) request.getSession().getAttribute(<span class="string">&quot;happy-captcha&quot;</span>), <span class="number">100</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在OrderServiceImpl中增加校验验证码的方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法: 验证用户输入的验证码是否正确</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkCaptcha</span><span class="params">(User user, Long goodsId, String captcha)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || goodsId &lt; <span class="number">0</span> || !StringUtils.hasText(captcha)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从Redis取出验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">redisCaptcha</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;captcha:&quot;</span> + user.getId() + <span class="string">&quot;:&quot;</span> + goodsId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> captcha.equals(redisCaptcha);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="秒杀接口限流-防刷"><a href="#秒杀接口限流-防刷" class="headerlink" title="秒杀接口限流-防刷"></a>秒杀接口限流-防刷</h3><p><strong>需求说明</strong></p><ul><li>完成接口限流-防止某个用户频繁的请求秒杀接口  </li><li>比如在短时间内，频繁点击立即秒杀</li></ul><p><strong>解决思路</strong><br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/seckill/img7.png" alt="image.png"><br><strong>解决过程</strong></p><h4 id="简单接口限流"><a href="#简单接口限流" class="headerlink" title="简单接口限流"></a>简单接口限流</h4><ul><li>使用简单的 Redis 计数器, 完成接口限流防刷 </li><li>除了计数器算法，也有其它的算法来进行接口限流, 比如漏桶算法和令牌桶算法  </li><li>添加在获取路径代码之前<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加业务逻辑: 加入Redis计数器, 完成对用户的限流防刷</span></span><br><span class="line"><span class="comment">//比如:5秒内访问次数超过了5次, 我们就认为是刷接口</span></span><br><span class="line"><span class="comment">//这里先把代码写在方法中，后面我们使用注解提高使用的通用性</span></span><br><span class="line"><span class="comment">//uri就是 localhost:8080/seckill/path 的 /seckill/path</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line"><span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> uri + <span class="string">&quot;:&quot;</span> + user.getId();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> (Integer) valueOperations.get(key);</span><br><span class="line"><span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//说明还没有key,就初始化，值为1, 过期时间为5秒</span></span><br><span class="line">    valueOperations.set(key, <span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; <span class="number">5</span>) &#123;<span class="comment">//说明正常访问</span></span><br><span class="line">    valueOperations.increment(key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//说明用户在刷接口</span></span><br><span class="line">    <span class="keyword">return</span> RespBean.error(RespBeanEnum.ACCESS_LIMIT_REACHED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="通过接口限流"><a href="#通过接口限流" class="headerlink" title="通过接口限流"></a>通过接口限流</h4><ul><li>自定义注解@AccessLimit, 提高接口限流功能通用性 , 减少冗余代码, 同时也减少业务代码入侵</li></ul><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/seckill/img8.png" alt="image.png"><br>自定义注解@AccessLimit，时间范围，访问最大次数，是否登录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AccessLimit: 自定义的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AccessLimit &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">second</span><span class="params">()</span>;<span class="comment">//时间范围</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxCount</span><span class="params">()</span>;<span class="comment">//访问的最大次数</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">needLogin</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;<span class="comment">//是否登录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写到getPath方法里</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法：获取秒杀路径</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/path&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@AccessLimit</span>(second = 5,maxCount = 5,needLogin = true)</span></span><br><span class="line"><span class="comment"> * 1. 使用注解的方式完成对用户的限流防刷-通用性和灵活性提高</span></span><br><span class="line"><span class="comment"> * 2. second = 5,maxCount = 5 说明是在5秒内可以访问的最大次数是5次</span></span><br><span class="line"><span class="comment"> * 3. needLogin = true 表示用户是否需要登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AccessLimit(second = 5, maxCount = 5, needLogin = true)</span></span><br><span class="line"><span class="keyword">public</span> RespBean <span class="title function_">getPath</span><span class="params">(User user, Long goodsId, String captcha, HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || goodsId &lt; <span class="number">0</span> || !StringUtils.hasText(captcha)) &#123;</span><br><span class="line">        <span class="keyword">return</span> RespBean.error(RespBeanEnum.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //增加业务逻辑: 加入Redis计数器, 完成对用户的限流防刷</span></span><br><span class="line"><span class="comment">//        //比如:5秒内访问次数超过了5次, 我们就认为是刷接口</span></span><br><span class="line"><span class="comment">//        //这里先把代码写在方法中，后面我们使用注解提高使用的通用性</span></span><br><span class="line"><span class="comment">//        //uri就是 localhost:8080/seckill/path 的 /seckill/path</span></span><br><span class="line"><span class="comment">//        String uri = request.getRequestURI();</span></span><br><span class="line"><span class="comment">//        ValueOperations valueOperations = redisTemplate.opsForValue();</span></span><br><span class="line"><span class="comment">//        String key = uri + &quot;:&quot; + user.getId();</span></span><br><span class="line"><span class="comment">//        Integer count = (Integer) valueOperations.get(key);</span></span><br><span class="line"><span class="comment">//        if (count == null) &#123;//说明还没有key,就初始化，值为1, 过期时间为5秒</span></span><br><span class="line"><span class="comment">//            valueOperations.set(key, 1, 5, TimeUnit.SECONDS);</span></span><br><span class="line"><span class="comment">//        &#125; else if (count &lt; 5) &#123;//说明正常访问</span></span><br><span class="line"><span class="comment">//            valueOperations.increment(key);</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;//说明用户在刷接口</span></span><br><span class="line"><span class="comment">//            return RespBean.error(RespBeanEnum.ACCESS_LIMIT_REACHED);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个业务逻辑-校验用户输入的验证码是否正确</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">check</span> <span class="operator">=</span> orderService.checkCaptcha(user, goodsId, captcha);</span><br><span class="line">    <span class="keyword">if</span> (!check) &#123;<span class="comment">//如果校验失败</span></span><br><span class="line">        <span class="keyword">return</span> RespBean.error(RespBeanEnum.CAPTCHA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> orderService.createPath(user, goodsId);</span><br><span class="line">    <span class="keyword">return</span> RespBean.success(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用来存储拦截器获取的 user 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个线程都有自己的ThreadLocal, 把共享数据存放到这里，保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; userHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userHolder.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属实看不懂这个拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AccessLimitInterceptor: 自定义的拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessLimitInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装配需要的组件/对象</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法完成1. 得到user对象，并放入到ThreadLoacl 2. 去处理@Accesslimit</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">            <span class="comment">//这里我们就先获取到登录的user对象</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getUser(request, response);</span><br><span class="line">            <span class="comment">//存入到ThreadLocal</span></span><br><span class="line">            UserContext.setUser(user);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把handler 转成 HandlerMethod</span></span><br><span class="line">            <span class="type">HandlerMethod</span> <span class="variable">hm</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">            <span class="comment">//获取到目标方法的注解</span></span><br><span class="line">            <span class="type">AccessLimit</span> <span class="variable">accessLimit</span> <span class="operator">=</span> hm.getMethodAnnotation(AccessLimit.class);</span><br><span class="line">            <span class="keyword">if</span> (accessLimit == <span class="literal">null</span>) &#123;<span class="comment">//如果目标方法没有@AccessLimit说明该接口并没有处理限流防刷</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//继续</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取注解的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> accessLimit.second();<span class="comment">//获取到时间范围</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> accessLimit.maxCount();<span class="comment">//获取到最大的访问次数</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">needLogin</span> <span class="operator">=</span> accessLimit.needLogin();<span class="comment">//获取是否需要登录</span></span><br><span class="line">            <span class="keyword">if</span> (needLogin) &#123;<span class="comment">//说明用户必须登录才能访问目标方法/接口</span></span><br><span class="line">                <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;<span class="comment">//说明用户没有登录</span></span><br><span class="line">                    <span class="comment">//返回一个用户信息错误的提示...一会再单独处理...</span></span><br><span class="line">                    render(response, RespBeanEnum.SESSION_ERROR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> uri + <span class="string">&quot;:&quot;</span> + user.getId();</span><br><span class="line">            <span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> (Integer) valueOperations.get(key);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//说明还没有key,就初始化，值为1, 过期时间为5秒</span></span><br><span class="line">                valueOperations.set(key, <span class="number">1</span>, second, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; maxCount) &#123;<span class="comment">//说明正常访问</span></span><br><span class="line">                valueOperations.increment(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明用户在刷接口</span></span><br><span class="line">                <span class="comment">//返回一个频繁访问的的提示...一会再单独处理...</span></span><br><span class="line">                render(response,RespBeanEnum.ACCESS_LIMIT_REACHED);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法：构建返回对象-以流的形式返回</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(HttpServletResponse response,</span></span><br><span class="line"><span class="params">                        RespBeanEnum respBeanEnum)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="comment">//构建RespBean</span></span><br><span class="line">        <span class="type">RespBean</span> <span class="variable">error</span> <span class="operator">=</span> RespBean.error(respBeanEnum);</span><br><span class="line">        out.write(<span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(error));</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单独编写方法，得到登录的user对象-userTicket</span></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">getUser</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ticket</span> <span class="operator">=</span> CookieUtil.getCookieValue(request, <span class="string">&quot;userTicket&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(ticket)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//说明该用户没有登录，直接返回null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserByCookie(ticket, request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装配</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserArgumentResolver userArgumentResolver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AccessLimitInterceptor accessLimitInterceptor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    注册自定义拦截器，这样就可以生效</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(accessLimitInterceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态资源加载</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/static/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里加入我们自定义的解析器到 HandlerMethodArgumentResolver列表中</span></span><br><span class="line">    <span class="comment">//这样自定义的解析器工作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> &#123;</span><br><span class="line">        resolvers.add(userArgumentResolver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserArgumentResolver: 自定义的一个解析器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装配UserService</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断你当前要解析的参数类型是不是你需要的?</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">        <span class="comment">//获取参数是不是user类型</span></span><br><span class="line">        Class&lt;?&gt; aClass = parameter.getParameterType();</span><br><span class="line">        <span class="comment">//如果为t, 就执行resolveArgument</span></span><br><span class="line">        <span class="keyword">return</span> aClass == User.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果上面supportsParameter,返回T,就执行下面的resolveArgument方法</span></span><br><span class="line">    <span class="comment">//到底怎么解析，是由程序员根据业务来编写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span></span><br><span class="line"><span class="comment">//        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        String ticket = CookieUtil.getCookieValue(request, &quot;userTicket&quot;);</span></span><br><span class="line"><span class="comment">//        if (!StringUtils.hasText(ticket)) &#123;</span></span><br><span class="line"><span class="comment">//            return null;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        //从Redis来获取用户</span></span><br><span class="line"><span class="comment">//        User user = userService.getUserByCookie(ticket, request, response);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        return user;</span></span><br><span class="line">        <span class="keyword">return</span> UserContext.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Component 和 @Configuration 的区别</title>
      <link href="/archives/ae991c2b.html"/>
      <url>/archives/ae991c2b.html</url>
      
        <content type="html"><![CDATA[<h2 id="Component-和-Configuration-的区别"><a href="#Component-和-Configuration-的区别" class="headerlink" title="Component 和 @Configuration 的区别"></a>Component 和 @Configuration 的区别</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ul><li><p>Component类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">   * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Configguration类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>从定义来看， @Configuration 注解本质上还是 @Component，因此 @ComponentScan 能扫描到@Configuration 注解的类。</li><li>@Configuration 中所有带 @Bean 注解的方法都会被动态代理，因此调用该方法返回的都是同一个实例。</li><li>调用@Configuration类中的@Bean注解的方法，返回的是同一个示例；而调用@Component类中的@Bean注解的方法，返回的是一个新的实例。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper</title>
      <link href="/archives/b829b66a.html"/>
      <url>/archives/b829b66a.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906195412.png"></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Zookeeper是一个开源的分布式的，为分布式应用提供协调的Apache项目。</p><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>Zookeeper从设计模式⻆度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。</p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906201028.png"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906201107.png"></p><ol><li>Zookeeper：一个领导者(Leader)，多个跟随者(Follower)组成的集群；</li><li>集群中只要有半数以上节点存活，Zookeeper集群就能正常服务；</li><li>全局数据一致：每个Server保存一份相同的数据副本，client无论连接到哪个S erver，数据都是一致的；</li><li>更新请求顺序进行，来自同一个Client的更新请求按其发送顺序依次执行；</li><li>数据更新原子性，一次数据更新要么成功，要么失败；</li><li>实时性，在一定时间范围内，Client能得到最新数据；</li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Zookeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一颗树，每个节点称作一个 ZNode。每一个ZNode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。</p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906201148.png"></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>提供的服务包括:统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p><p><strong>统一命名服务：</strong></p><p>在分布式环境下，经常需要对应用&#x2F;服务进行统一命名，便于识别。<br>例如：IP不容易记住，而域名容易记住。</p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906201240.png"></p><p><strong>统一配置管理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906201356.png"></p><ol><li>分布式环境下，配置文件同步非常常⻅。</li></ol><ul><li>a. 一般要求一个集群中，所有节点的配置信息是一致的，比如kafka集群；</li><li>b. 对配置文件修改后，希望能够快速同步到各个节点上；</li></ul><ol start="2"><li>配置管理可交由Zookeeper实现。</li></ol><ul><li>a. 可将配置信息写入Zookeeper上的一个Znode.；</li><li>b. 各个客戶端服务器监听这个Znode；</li><li>c. 一旦Znode中的数据被修改，Zookeeper将通知各个客戶端服务器。</li></ul><p><strong>统一集群管理</strong></p><p>分布式环境中，实时掌握每个节点的状态是必要的，可根据节点实时状态做出一些调整。<br>ZooKeeper可以实现实时监控节点状态变化：</p><ul><li>可将节点信息写入ZooKeeper上的一个ZNode。</li><li>监听这个ZNode可获取它的实时状态变化。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906201428.png"></p><p><strong>服务器动态上下线</strong></p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906201529.png"></p><p>客戶端实时洞察服务上下线变化</p><p><strong>负载均衡</strong><br>在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客戶端请求。</p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906201621.png"></p><h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906201810.png"></p><p>（ 1 ）Serverid（或sid）：服务器ID<br>比如有三台服务器，编号分别是1,2,3。编号越大在选择算法中的权重越大，比如初始化启动时就是根据服务器ID进行比较。<br>（ 2 ）Zxid：事务ID<br>服务器中存放的数据的事务ID，值越大说明数据越新，在选举算法中数据越新权重越大。<br>（ 3 ）Epoch：逻辑时钟<br>也叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的，每投完一次票这个数据就会增加。<br>（ 4 ）Server状态：选举状态<br>LOOKING，竞选状态。<br>FOLLOWING，随从状态，同步leader状态，参与投票。<br>OBSERVING，观察状态,同步leader状态，不参与投票。<br>LEADING，主状态。</p><p><strong>全新集群选举</strong></p><p>a.server1启动<br>触发一次选举，server1投给自己一票，但是总共 5 台服务器未达到半数 3 台，所以选举无法完成。<br>投票结果：server1： 1 票<br>状态：server1:LOOKING</p><p>b.server2启动<br>触发选举，server1和 2 分别投自己一票，但是server1发现 2 的id比自己大，就更改选票投给server2，<br>此时未达半数，还是LOOKING状态<br>投票结果：server1： 0 票server2： 2 票<br>状态：server1:LOOKINGserver2:LOOKING</p><p>c.server3启动<br>触发选举，server1和 2 和 3 分别投自己一票，但是server1和 2 发现 3 的id比自己大，就更改选票投给<br>server3，此时达半数投票，server3当选leader<br>投票结果：server1： 0 票server1： 0 票server3： 3 票<br>状态：server1:FOLLOWERserver2:FOLLOWERserver3:LEADER</p><p>d.server4启动<br>触发选举，server1、 2 、 3 已经不是LOOKING，不会更改选票信息，只会交换选票信息<br>投票结果：server1： 0 票server1： 0 票server3： 3 票server4： 1 票<br>状态：server1:FOLLOWERserver2:FOLLOWERserver3:LEADERserver4:FOLLOWER</p><p>e.server5启动<br>和server4一样投票给自己，但是已经有leader了就结束选举<br>投票结果：server1： 0 票server1： 0 票server3： 3 票server4： 1 票server5： 1 票<br>状态：server1:FOLLOWERserver2:FOLLOWERserver3:LEADERserver4:FOLLOWER<br>server5:FOLLOWER</p><p>总结：服务器 3 选为leader，其余是follower，一般集群中间的机器当选leader</p><p><strong>非全新集群选举</strong></p><p>运行期选举与初始状态投票过程基本类似，大致可以分为以下几个步骤：<br>（ 1 ）状态变更。Leader故障后，余下的非 Observer服务器都会将自己的服务器状态变更为 LOOKING，然后开始进入Leader选举过程。<br>（ 2 ）每个Server会发出投票。<br>（ 3 ）接收来自各个服务器的投票，如果其他服务器的数据比自己的新会改投票。<br>（ 4 ）处理和统计投票，每一轮投票结束后都会统计投票，超过半数即可当选。<br>（ 5 ）改变服务器的状态，宣布当选。</p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906201922.png"></p><p>（ 1 ）次投票，每台机器都会将票投给自己。<br>（ 2 ）接着每台机器都会将自己的投票发给其他机器，如果发现其他机器的zxid比自己大，那么就需要改投票重新投一次。比如server1收到了三张票，发现server2的xzid为 102 ，pk一下发现自己输了，后面果断改投票选server2为老大。</p><blockquote><ol><li>EPOCH大的直接胜出</li><li>EPOCH相同，事务id大的胜出</li><li>事务id相同，服务器id大的胜出</li></ol></blockquote><h3 id="Znode的分类"><a href="#Znode的分类" class="headerlink" title="Znode的分类"></a>Znode的分类</h3><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906201959.png"></p><ul><li>持久性的znode,这样的znode在创建之后即使发生Zookeeper集群宕机,或者Client宕机也不会丢失</li><li>临时性的znode,Client宕机或者Client在指定的timeout时间内没有给Zookeeper集群发消息,这样的znode就会消失 znode也可以是顺序性的。每一个顺序性的znode关联一个唯一的单调递增整数。这个单调递增整数是znode名字的后缀。</li><li>持久顺序性的znode</li><li>临时顺序性的znode</li></ul><p>FIY：在分布式系统中，顺序号可以被用于为所有事件进行全局排序，这样客戶端可以通过顺序号推断时间的顺序。</p><h3 id="监听器原理"><a href="#监听器原理" class="headerlink" title="监听器原理"></a>监听器原理</h3><p>客戶端注册监听它关心的目录节点，当目录节点发生变化(数据改变、节点删除、子目录节点增加删除)时，ZooKeeper会通知客戶端。监听机制保证ZooKeeper保存的任何的数据的任何改变都能快速的响应到监听了该节点的应用程序。</p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906202156.png"></p><p>1 、监听原理详解<br>（ 1 ）首先要有一个main()线程<br>（ 2 ）在main线程中创建Zookeeper客戶端，这时就会创建两个线程，一个负责网络连接通信(connect)，一个负责监听(listener)。<br>（ 3 ）通过connect线程将注册的监听事件发送给Zookeeper。<br>（ 4 ）在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中。<br>（ 5 ）Zookeeper监听到有数据或路径变化，就会将这个消息发送给listener线程。<br>（ 6 ）listener线程内部调用了process()方法。<br>2 、常⻅的监听<br>（ 1 ）监听节点数据的变化 getpath[watch]<br>（ 2 ）监听子节点增减的变化 lspath[watch]</p><h3 id="客戶端向服务端写数据流程"><a href="#客戶端向服务端写数据流程" class="headerlink" title="客戶端向服务端写数据流程"></a>客戶端向服务端写数据流程</h3><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906202257.png"><br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906202320.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HA高可用</title>
      <link href="/archives/ca5bd729.html"/>
      <url>/archives/ca5bd729.html</url>
      
        <content type="html"><![CDATA[<h2 id="HA高可用"><a href="#HA高可用" class="headerlink" title="HA高可用"></a>HA高可用</h2><h3 id="HA概述"><a href="#HA概述" class="headerlink" title="HA概述"></a>HA概述</h3><ol><li>所谓HA（HighAvailable），即高可用（7*24小时不中断服务）。</li><li>实现高可用最关键的策略是消除单点故障。HA严格来说应该分成各个组件的HA机制：Hadoop2.之前，在HDFS集群中NameNode存在单点故障（SPOF）。</li><li>NameNode主要在以下两个方面影响HDFS集群<br>NameNode机器发生意外，如宕机，集群将无法使用，直到管理员重启<br>NameNode机器需要升级，包括软件、硬件升级，此时集群也将无法使用</li></ol><p>HDFSHA功能通过配置Active&#x2F;Standby两个NameNodes实现在集群中对NameNode的热备来解决上述问题。如果出现故障，如机器崩溃或机器需要升级维护，这时可通过此种方式将NameNode很快的切换到另外一台机器。</p><h3 id="工作要点"><a href="#工作要点" class="headerlink" title="工作要点"></a>工作要点</h3><p><strong>1.元数据管理方式需要改变</strong></p><p>内存中各自保存一份元数据；<br>Edits日志只有Active状态的NameNode节点可以做写操作；<br>两个NameNode都可以读取Edits；<br>共享的Edits放在一个共享存储中管理（qjournal和NFS两个主流实现）；</p><p><strong>2. 需要一个状态管理功能模块</strong><br>实现了一个zkfailover，常驻在每一个namenode所在的节点，每一个zkfailover负责监控自己所在NameNode节点，利用zk进行状态标识，当需要进行状态切换时，由zkfailover来负责切换，切换时需要防止brainsplit现象的发生。<br>3. 必须保证两个NameNode之间能够ssh无密码登录<br>4. 隔离（Fence），即同一时刻仅仅有一个NameNode对外提供服务。<br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906194734.png"></p><h3 id="自动故障转移工作机制"><a href="#自动故障转移工作机制" class="headerlink" title="自动故障转移工作机制"></a>自动故障转移工作机制</h3><p>自动故障转移为HDFS部署增加了两个新组件：ZooKeeper和ZKFailoverController（ZKFC）进程。ZooKeeper是维护少量协调数据，通知客戶端这些数据的改变和监视客戶端故障的高可用服务。<br>HA的自动故障转移依赖于ZooKeeper的以下功能：<br><strong>1 ）故障检测：</strong> 集群中的每个NameNode在ZooKeeper中维护了一个持久会话，如果机器崩溃，ZooKeeper中的会话将终止，ZooKeeper通知另一个NameNode需要触发故障转移。<br><strong>2 ）现役NameNode选择：</strong> ZooKeeper提供了一个简单的机制用于唯一的选择一个节点为active状态。如果目前现役NameNode崩溃，另一个节点可能从ZooKeeper获得特殊的排外锁以表明它应该成为现役NameNode。</p><p><strong>ZKFC</strong> 是自动故障转移中的另一个新组件，是ZooKeeper的客戶端，也监视和管理NameNode的状态。每个运行NameNode的主机也运行了一个ZKFC进程，ZKFC负责：<br><strong>1 ）健康监测：</strong> ZKFC使用一个健康检查命令定期地ping与之在相同主机的NameNode，只要该NameNode及时地回复健康状态，ZKFC认为该节点是健康的。如果该节点崩溃，冻结或进入不健康状态，健康监测器标识该节点为非健康的。<br><strong>2 ）ZooKeeper会话管理：</strong> 当本地NameNode是健康的，ZKFC保持一个在ZooKeeper中打开的会话。如果本地NameNode处于active状态，ZKFC也保持一个特殊的znode锁，该锁使用了ZooKeeper对短暂节点的支持，如果会话终止，锁节点将自动删除。<br><strong>3 ）基于ZooKeeper的选择：</strong> 如果本地NameNode是健康的，且ZKFC发现没有其它的节点当前持有 znode锁，它将为自己获取该锁。如果成功，则它已经赢得了选择，并负责运行故障转移进程以使它的本地NameNode为Active。故障转移首先如果必要保护之前的现役NameNode，然后本地 NameNode转换为Active状态。</p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906194810.png"></p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906194843.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NameNode的工作机制</title>
      <link href="/archives/78dc0ee1.html"/>
      <url>/archives/78dc0ee1.html</url>
      
        <content type="html"><![CDATA[<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>NameNode中元数据的存储介质？<br>磁盘？内存？<br>如果存储在NameNode节点的磁盘中，因为经常需要进行随机访问，还有响应客戶请求，必然是效率过低。因此，元数据需要存放在内存中。但如果只存在内存中，一旦断电，元数据丢失，整个集群就无法工作了。因此产生在磁盘中备份元数据的FsImage。</p><p>这样又会带来新的问题，当在内存中的元数据更新时，如果更新FsImage，就会导致效率过低，但如 果不更新，就会发生一致性问题，一旦NameNode节点断电，就会产生数据丢失。因此，引入Edits文 件(只进行追加操作，效率高)。每当元数据有更新或者添加元数据时，修改内存中的元数据并追加到 Edits中。这样，一旦NameNode节点断电，可以通过FsImage和Edits的合并，合成元数据。</p><p>但是，如果⻓时间添加到Edits中，会导致该文件数据过大，效率降低，而且一旦断电，恢复元数据需要的时间很⻓。因此，需要定期进行FsImage和Edits的合并，如果这个操作由NameNode节点完成，又回效率过低。因此引入一个新的节点SecondearyNamenode，专⻔用于FsImage和Edits的合并。</p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906194233.png"></p><p>Fsimage:NameNode内存中元数据序列化后形成的文件。<br>Edits:记录客戶端更新元数据信息的每一步操作(可通过Edits运算出元数据)。</p><p><strong>第一阶段：NameNode启动</strong></p><ol><li>第一次启动NameNode格式化后，创建Fsimage和Edits文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存。</li><li>客戶端对元数据进行增删改的请求。</li><li>NameNode记录操作日志，更新滚动日志。</li><li>NameNode在内存中对元数据进行增删改。</li></ol><p><strong>第二阶段：SecondaryNameNode工作</strong></p><ol><li>SecondaryNameNode询问NameNode是否需要CheckPoint。直接带回NameNode是否检查结果。</li><li>SecondaryNameNode请求执行CheckPoint。</li><li>NameNode滚动正在写的Edits日志。</li><li>将滚动前的编辑日志和镜像文件拷⻉到SecondaryNameNode。</li><li>SecondaryNameNode加载编辑日志和镜像文件到内存，并合并。</li><li>生成新的镜像文件fsimage.chkpoint。</li><li>拷⻉fsimage.chkpoint到NameNode。</li><li>NameNode将fsimage.chkpoint重新命名成fsimage。</li></ol><p><strong>FsImage和Edits解析</strong></p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906194459.png"></p><p>Fsimage文件：HDFS文件系统元数据的一个永久性的检查点，其中包含HDFS文件系统的所有目录和文件inode的序列化信息。<br>Edits文件：存放HDFS文件系统的所有更新的路径，文件系统客戶端执行的所有写操作首先会被记录到Edits文件中。<br>seen_txid文件保存的是一个数字，就是最后一个edits_的数字<br>每次NameNode启动的时候都会将Fsimage文件读入内存，加载Edits里面的更新操作，保证内存中的元数据信息是最新的、同步的，可以看成NameNode启动的时候就将Fsimage和Edits文件进行了合并。<br>查看fsimage<br>查看edits</p><h3 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h3><p>DataNode机制：</p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906194525.png"></p><ol><li>一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的⻓度，块数据的校验和，以及时间戳。</li><li>DataNode启动后向NameNode注册，通过后，周期性的向NameNode上报所有的块信息。</li><li>心跳是每 3 秒一次，心跳返回结果带有NameNode给该DataNode的命令如复制块数据到另一台机器，或删除某个数据块。如果超过 10 分钟没有收到某个DataNode的心跳，则认为该节点不可用。</li><li>集群运行中可以安全加入和退出一些机器。</li></ol><p><strong>数据完整性</strong></p><p>  思考：如果电脑磁盘里面存储的数据是控制信号灯的红灯信号（ 1 ）和绿灯信号（ 0 ），但是存储该数据的磁盘坏了，一直显示是绿灯，是否很危险？同理DataNode节点上的数据损坏了，却没有发现，是否也很危险，那么如何解决呢？如下是DataNode节点保证数据完整性的方法。</p><ol><li>当DataNode读取Block的时候，它会计算CheckSum。</li><li>如果计算后的CheckSum，与Block创建时值不一样，说明Block已经损坏。</li><li>Client读取其他DataNode上的Block。</li><li>常⻅的校验算法crc（ 32 ），md5（ 128 ），sha1（ 160 ）</li><li>DataNode在其文件创建后周期验证CheckSum。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906194605.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdfs架构及读写数据流程</title>
      <link href="/archives/d60b854b.html"/>
      <url>/archives/d60b854b.html</url>
      
        <content type="html"><![CDATA[<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906132156.png" alt="image.png"></p><p>Namenode是HDFS集群主节点，负责管理整个文件系统的元数据，以树形结构维护者集群中所有的文件和目录，所有的读写请求都要经过Namenode。</p><ul><li>a. 处理客戶端请求（读，写，管理）；</li><li>b. 管理数据块映射信息；</li><li>c. 管理HDFS的映射空间；</li></ul><p>Datanode将HDFS数据以文件的形式存储在本地的文件系统中，它并不知道有关HDFS文件的信息。它把每个HDFS数据块存储在本地文件系统的一个单独的文件中。</p><ul><li>a. 存储实际的数据块；</li><li>b. 进行数据块读写操作；</li></ul><p><strong>Client:客戶端</strong></p><ul><li>a. 文件切分。文件上传HDFS的时候，client将文件切成一个个Block,然后进行上传；</li><li>b. 和NameNode交互，获取文件的位置信息；</li><li>c. 和datanode交互，读写数据；</li><li>d. client提供命令来管理HDFS，例如进入安全模式、退出安全模式，格式化等；</li></ul><p>SecondaryNameNode:不是NameNode的热备节点，当NameNode退出服务状态时，并不替换NameNode提供服务。</p><ul><li>a. 分担NameNode工作量，定期合并Fsimage和EditsLog，并推送给NameNode;</li><li>b. 可辅助恢复NameNode;</li></ul><h3 id="数据分块"><a href="#数据分块" class="headerlink" title="数据分块"></a>数据分块</h3><p><strong>HDFS文件块大小</strong></p><p>HDFS中的文件在物理上是分块存储（Block），块的大小可以通过配置参数（dfs.blocksize）来规定，默认大小在Hadoop2.x和Hadoop3.x版本中是128M，老版本Hadoop1.x中是 64M。</p><p><strong>设置原理</strong></p><p>HDFS文件块大小设置主要取决于磁盘传输速率，目前进行寻址的时间约为10ms，即查找到目标block的时间为10ms。<br>寻址时间为传输时间的1%时，为最佳状态。<br>因此，传输时间为10ms&#x2F;0.01&#x3D;1000ms&#x3D;1s<br>目前磁盘的传输速率普遍为100MB&#x2F;s<br>因此，block大小为1s*100MB&#x2F;s&#x3D;100MB<br>因为电脑底层数据采用二进制存储，所以目前的block块官方大小设置为128MB。</p><p><strong>总结</strong>：HDFS文件块大小设置主要取决于磁盘传输速率，生产中采用高速磁盘作为存储介质的可以考虑在HDFS的配置文件中设置dfs.blocksize参数调整block块大小。</p><p>思考：块设置太大或太小或怎样？<br>HDFS的块设置太小，会增加寻址时间，程序一直在找块的开始位置；<br>如果块设置的太大，从磁盘传输数据的时间会明显大于定位这个块开始位置所需的时间。导致程序在处理这块数据时，会非常慢，并行度也降低。</p><h3 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h3><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906132943.png" alt="image.png"></p><ol><li>客戶端通过DFS向NN请求上传文件，NN进行检查（权限，文件是否已存在）；</li><li>NN返回是否可以上传；</li><li>client请求第一个Block上传到哪几个DN上；</li><li>NN返回 3 个DN节点；</li><li>客戶端通过FSDataOutputStream请求DN1上传数据，dn1收到请求会继续调用dn2，然后dn2调用dn3，将这个通信管道建立完成；</li><li>dn1、dn2、dn3逐级应答客戶端；</li><li>客戶端开始上传第一个block（先从磁盘读取数据放到一个本地内存缓存），以packet为单位，<br>dn1收到一个packet就会传给dn2，dn2传给dn3，dn1每传一个packet会放入一个应答队列等待应答；</li><li>当一个block传输完成后，客戶端再次请求NN上传第二个blcok的服务器；（重复执行 3 -7步骤）</li></ol><ul><li>网络拓扑节点距离计算<ul><li>在HDFS写数据的过程中，NN会选择距离待上传数据最近距离的DN接受数据。</li><li>如何计算这个最近距离呢？</li><li>节点距离：两个节点到达最近的共同祖先的距离总和。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906133749.png" alt="image.png"></p><p>distance(&#x2F;d1&#x2F;r1&#x2F;n0,&#x2F;d1&#x2F;r1&#x2F;n0)&#x3D;0(相同节点)<br>distance(&#x2F;d1&#x2F;r1&#x2F;n1,&#x2F;d1&#x2F;r1&#x2F;n2)&#x3D;2（相同机架，不同节点）<br>distance(&#x2F;d1&#x2F;r2&#x2F;n0,&#x2F;d1&#x2F;r3&#x2F;n1)&#x3D;4（相同数据中心，不同机架）<br>distance(&#x2F;d1&#x2F;r2&#x2F;n1,&#x2F;d2&#x2F;r4&#x2F;n1)&#x3D;6（不同数据中心）</p><p>机架感知-副本节点选择<br><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html">https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906134001.png" alt="image.png"></p><p>第一副本：放置在上传文件的DN上（就是执行‘hadoopfs-put文件名’上传文件命令的机器上，本<br>地文件上传到同一台机器自然要快一点），如果是集群外提交，则随机挑选一台；<br>第二副本：放置在第一副本不同机架的不同节点上；<br>第三副本，放置在第二副本相同机架的不同节点上；其他更多副本：随机放置在节点中。</p><h3 id="读数据流程"><a href="#读数据流程" class="headerlink" title="读数据流程"></a>读数据流程</h3><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/blog/20230906134140.png" alt="image.png"></p><ol><li>客戶端通过DFS(DistributedFileSystem)向NameNode请求下载文件，NameNode通过查询元数<br>据，找到文件块所在的DN地址；</li><li>选取一台DN（就近原则，然后随机）服务器，请求读取数据；</li><li>DN开始传输数据给客戶端（从磁盘里读取数据输入流，以Packet为单位来做校验）；</li><li>客戶端以Packet为单位接收。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> fs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdfs的产生</title>
      <link href="/archives/97af9faf.html"/>
      <url>/archives/97af9faf.html</url>
      
        <content type="html"><![CDATA[<h3 id="HDFS产生背景"><a href="#HDFS产生背景" class="headerlink" title="HDFS产生背景"></a>HDFS产生背景</h3><p>HDFS（Hadoop分布式文件系统）是Apache  Hadoop项目的一个重要组成部分，用于存储和处理大规模数据集。<br>在过去的几十年中，数据量呈指数级增⻓，传统的存储和处理方法已经无法应对这些大规模数据的挑战。在此背景下，Google公司在 2003 年发表了一篇关于Google文件系统（GFS）的论文，介绍了他们自主开发的分布式文件系统。这篇论文引起了广泛的关注，并促进了分布式文件系统研究的发展。<br>随后，Apache软件基金会在 2006 年创建了Hadoop项目，旨在实现可靠、可扩展、高效的分布式计算平台，其中包括了HDFS作为其默认的分布式文件系统。HDFS受到GFS的启发，在设计上采用了类似的思想和架构。</p><p><strong>HDFS的产生背景主要有以下几个方面：</strong></p><ul><li>数据爆炸：随着互联网的普及和各种应用程序的快速发展，人们创造和收集的数据量不断增加。从社交媒体、移动应用到物联网设备，各种渠道都在不断产生大量的数据。传统的存储系统已经无法满足如此庞大的数据规模和处理需求。</li><li>数据分析：大数据分析已经成为企业和科研机构的重要工具。传统的数据存储和处理方法无法满足对大规模数据集进行高效处理和分析的需求。HDFS提供了高吞吐量的数据访问方式，能够满足大规模数据处理的需求。</li><li>分布式环境：随着计算资源的不断增加，采用分布式计算架构可以更好地利用这些资源。HDFS作为分布式文件系统，能够将数据存储在多个节点上，实现数据冗余和高可用性，并通过并行处理技术来提高数据处理效率。</li></ul><p>总之，HDFS的产生背景是由于传统的存储和处理方法无法应对大规模数据的挑战，而HDFS作为一种可靠、可扩展、高效的分布式文件系统，能够满足大规模数据存储和处理的需求。</p><h3 id="HDFS的定义"><a href="#HDFS的定义" class="headerlink" title="HDFS的定义"></a>HDFS的定义</h3><p>HDFS是一种可靠、可扩展、高吞吐量的分布式文件系统，通过目录树来定位文件，旨在存储和处 理大规模数据集。</p><p>思考：HDFS采用了什么方式达到了高吞吐的？</p><p>HDFS具有高吞吐量的特点主要因为以下几个原因：</p><ul><li>数据切块和分布复制：HDFS将大文件切分成多个固定大小的数据块，并将这些数据块复制到集群 中的多个节点上。这样可以实现数据的并行操作，提高了整体的数据传输速度和处理能力。</li><li>流式数据访问：HDFS采用了流式数据访问方式，即一次性连续读写大量数据而不是频繁的随机读写。这种设计避免了磁盘寻道时间的开销，使得数据的传输更加高效。</li><li>数据本地性优化：尽可能地将计算任务分配给存储数据的节点进行处理，以减少数据传输的开销。 这样可以最大限度地利用节点上的本地数据，提高数据的访问速度和处理效率。</li><li>写入优化：HDFS的写入操作采用了追加写入（append）的方式，即可以在已有数据的末尾进行写 入，而无需移动或重写已有的数据。这种写入方式可以提高写入的效率，适用于一次性写入大量数据的场景。</li></ul><p>总之，HDFS通过数据切块、分布复制、流式数据访问和数据本地性优化等策略来提高吞吐量。这些设 计和优化使得HDFS能够并行处理大规模数据集，实现高效的数据读写和传输，从而实现了高吞吐量的操作。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>一次写入，多次读取，不支持文件修改，适合数据分析。</li><li>不适合低延迟访问，不适合小文件存储。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储架构的发展</title>
      <link href="/archives/dbff2cfe.html"/>
      <url>/archives/dbff2cfe.html</url>
      
        <content type="html"><![CDATA[<h2 id="存储架构的发展"><a href="#存储架构的发展" class="headerlink" title="存储架构的发展"></a>存储架构的发展</h2><h3 id="单机存储"><a href="#单机存储" class="headerlink" title="单机存储"></a>单机存储</h3><p>单机存储是最早的存储方式，将数据保存在单个计算机的本地存储设备中，如硬盘或固态硬盘。</p><ul><li>优点：存取速度快，简单易用。</li><li>缺点：容量有限，可靠性低，不具备横向扩展能力。</li></ul><h3 id="集中式存储"><a href="#集中式存储" class="headerlink" title="集中式存储"></a>集中式存储</h3><p>随着数据量的增⻓，人们开始将数据集中存储在专用服务器或存储设备上。通过网络连接，多个客戶端可以同时访问和共享存储设备上的数据。</p><ul><li><p>优点：提供了更高的存储容量和可靠性，实现了更好的数据管理和共享。</p></li><li><p>缺点：单点故障⻛险较高，不适合大规模分布式应用。</p></li></ul><h3 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h3><p>分布式存储将数据分散存储在多个节点上，每个节点都具有自己的存储资源。 数据可以通过分片和冗余备份来提高可靠性和容错性。 通过分布式协调和数据一致性机制，实现数据的高可用性和负载均衡。</p><ul><li><p>优点：具备良好的可扩展性、容错性和性能。</p></li><li><p>缺点：复杂度较高，需要解决一致性、并发和故障处理等挑战。</p></li></ul><h3 id="云存储"><a href="#云存储" class="headerlink" title="云存储"></a>云存储</h3><p>云存储是一种基于云计算模式的存储方式，将数据存储在云服务提供商的服务器上，并通过网络进行访问。 用戶可以根据需求弹性地扩展存储容量，并享受高可用性、灵活性和成本效益等优势。提供了多种存储服务模型，如对象存储、块存储和文件存储，满足不同应用场景的需求。</p><h3 id="云原生存储"><a href="#云原生存储" class="headerlink" title="云原生存储"></a>云原生存储</h3><p>云原生存储是一种将存储与容器编排平台紧密集成的新兴存储方式，以支持动态、可移植和弹性的应 用程序部署。 提供了存储卷管理、数据持久化和多租戶支持等高级功能。</p><ul><li>优点：更好地适应容器化环境，提供了更高的灵活性和可操作性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql的存储引擎</title>
      <link href="/archives/7d88daa0.html"/>
      <url>/archives/7d88daa0.html</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL-支持哪些存储引擎"><a href="#MySQL-支持哪些存储引擎" class="headerlink" title="MySQL 支持哪些存储引擎?"></a>MySQL 支持哪些存储引擎?</h3><ul><li>MySQL 支持的引擎包括：InnoDB、MyISAM、MEMORY、Archive、Federate、CSV、BLACKHOLE 等；</li><li>MySQL5.5 之前的默认存储引擎是 MyISAM，5.5 之后就改为了 InnoDB。</li></ul><h3 id="MyISAM-和-InnoDB-的区别有哪些？"><a href="#MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="MyISAM 和 InnoDB 的区别有哪些？"></a>MyISAM 和 InnoDB 的区别有哪些？</h3><p><strong>MyISAM 存储引擎：</strong></p><ul><li>特点：不支持事务和外键；</li><li>索引：MyISAM 是非聚簇索引，索引文件和数据文件是分离的，索引保存的是数据的地址；</li><li>检索：MyISAM 支持全文索引，查询效率上 InnoDB 要高；</li><li>锁：MyISAM 支持表级锁，每次操作对整个表加锁，一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限；</li><li>存贮方式：  存贮表的总行数，执行 select count(*) from table 时只需要读出该变量即可，速度很快；</li><li>应用场景：查询和插入操作为主，只有很少更新和删除操作，并对事务的完整性、并发性要求不高。 因为MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。</li></ul><p><strong>InnoDB 存储引擎：</strong></p><ul><li>特点：支持事务和外键操作，支持并发控制；</li><li>索引：InnoDB 是聚簇索引，索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快；</li><li>检索：Innodb 不支持全文索引，执行 select count(*) from table 时需要全表扫描；</li><li>锁：Innodb 支持行级锁和表级锁，默认为行级锁；</li><li>存贮方式：不存贮表的总行数，MyISAM 用一个变量保存了整个表的行数，执行 select count(*) from table 时只需要读出该变量即可，速度很快；</li><li>应用场景：MySQL 5.5版本后默认，对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，读写频繁的操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库的三范式</title>
      <link href="/archives/b3d7f795.html"/>
      <url>/archives/b3d7f795.html</url>
      
        <content type="html"><![CDATA[<p><strong>三大范式</strong></p><p>数据库范式是设计数据库时，需要遵循的一些规范。各种范式是条件递增的联系，越高的范式数据库冗余越小。常用的数据库三大范式为：</p><ol><li>第一范式（1NF）：每个列都不可以再拆分，强调的是列的原子性，即数据库表的每一列都是不可分割的原 子数据项。</li><li>第二范式（2NF）：在满足第一范式的基础上，非主属性完全依赖于主码（主关键字、主键），消除非主属性对主码的部分函数依赖。</li><li>第三范式（3NF）：在满足第二范式的基础上，表中的任何属性不依赖于其它非主属性，消除传递依赖。简而言之，非主键都直接依赖于主键，而不是通过其它的键来间接依赖于主键。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/archives/7af799fd.html"/>
      <url>/archives/7af799fd.html</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>在开发代码时，我们通常明确使用关键字new创建对象，然后调用对象的某个具体方法，这种方式在<br>程序运行前就已经确定了对象的类型、方法、字段等。有些功能场景下，需要动态获取并修改对象运<br>行时行为，这就是Java反射的作用，通过Java反射，可以动态获取对象的方法(包括构造方法)、属<br>性、注解、修饰符等，任何东西在反射面前都是透明的。</p><p><strong>反射的一些缺点</strong></p><ul><li>性能相对较低：没有经过编译优化，需要动态即时解析。</li><li>有安全⻛险：私有方法或属性，可通过反射强制进入。</li><li>难以维护：修改类的方法或字段时，部分反射代码功能错误在编译时无法检查</li></ul><p>虽然反射有一些缺点，但是它的应用场景也非常广泛。</p><ul><li>动态代理，字节码增强</li><li>框架设计，解耦、提升扩展性</li><li>序列化与反序列化</li><li>JavaBean</li><li>IDE工具</li></ul><p>java.lang.reflect包提供了大量的反射API，主要的一些核心类包括Method、Field、Constructor等。<br>JVM给每个对象提供了一个java.lang.Class实例，相同类型的实例对象得到的是同一个Class对象，<br>Class是反射API操作的入口。</p><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><p>Java提供了三种方式获取Class对象</p><h4 id="Object-getClass"><a href="#Object-getClass" class="headerlink" title="Object.getClass()"></a>Object.getClass()</h4><h4 id="class-语法"><a href="#class-语法" class="headerlink" title=".class 语法"></a>.class 语法</h4><p>当有一个有效的类型，但是并没有对应的类型实例时，直接在类型实例后面增加.class语法，即可获取Class对象。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean b;</span><br><span class="line">Class c = b.getClass(); // 编译错误</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class c = boolean.class; // 正确</span><br></pre></td></tr></table></figure><p>获取Integer的Class对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class c = java.lang.Integer.class;</span><br></pre></td></tr></table></figure><h4 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName()"></a>Class.forName()</h4><p>这种方式必须知道类的全类名，然后通过Class的静态方法forName()获取，全类名不存在，则会抛出ClassNotFoundException异常，不能使用这种方式获取Java原始类型的Class对象。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clz = Class.forName(&quot;java.lang.Integer&quot;);</span><br></pre></td></tr></table></figure><p>Class.forName经常用于让JVM主动加载某个Class，如加载MySQL的驱动类。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure><p>这种方式作用是什么？<br>类加载之后，接着会进行初始化，其中包括类的静态代码块的执行，MySQL的Driver类就是通过静态代码块，完成了一个非常重要的操作，即把MySQL的驱动注册到JDBC驱动管理器中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">try &#123;</span><br><span class="line">DriverManager.registerDriver(new Driver());</span><br><span class="line">&#125; catch (SQLException var1) &#123;</span><br><span class="line">throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span><br></pre></td></tr></table></figure><h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p>构造方法用于创建一个Class的实例对象，反射API可以获取构造方法，包括方法的修饰符、参数类型、注解以及是否抛出异常等，构造方法不能继承。</p><h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><p>在反射API中，一个Field对象代表的是一个字段信息，通过java.lang.reflect.Field可以获取字段的名称、类型、修饰符、注解等，Filed可能是一个Java原始类型，也可能是对象引用类型。</p><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>一个Method对象代表的是一个可被调用的普通方法(包括静态方法)，java.lang.reflect.Method类提供<br>了获取方法的修饰符、返回值类型、参数类型、注解以及已经声明的抛出异常等信息。</p>]]></content>
      
      
      <categories>
          
          <category> Java知识点 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>缓冲流</title>
      <link href="/archives/86115b8e.html"/>
      <url>/archives/86115b8e.html</url>
      
        <content type="html"><![CDATA[<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>Java非缓冲流的每次读写都需要进行本地方法调用，交给底层操作系统进行处理，工作效率非常低， 因为每次请求可能都会触发磁盘读写、网络活动以及其它一些开销昂贵的操作。为了减少操作系统的负载，Java提供了IO缓冲流，缓冲流内部提供了缓冲区(buffer)进行读写，大部分缓冲流的buffer默认 大小为 8192 字节(8KB)。</p><ul><li>缓冲输入流从内存区域的buffer读取数据，当buffer数据为空时，Java本地输入方法才会进行调<br>用。</li><li>缓冲输出流将数据写入到内存区域的buffer，当buffer写满时，Java本地输出方法才会进行调用。</li></ul><p>Java程序可以通过包装方式将非缓冲流构造成为一个缓冲流，BufferedInputStream、 BufferedOutputStream用于构造缓冲字节流，BufferedReader、BufferedWriter用于构造缓冲字符流。</p><h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><p>字节缓冲流主要包括缓冲输入流BufferedInputStream，缓冲输出流BufferedOutputStreamWriter。</p><ul><li>BufferedInputStream通过非缓冲字节流FileInputStream进行一次磁盘IO，一次性读取多个字节<br>数据到内存buffer(字节数组)，后续程序只需从内存中的buffer数组中读取字节数据，减少IO操作次<br>数。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStreamDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://test/source.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">int</span> c;</span><br><span class="line">            <span class="comment">// 从内存buffer中读取字节数据，如果buffer为空，才会进行IO操作</span></span><br><span class="line">            <span class="keyword">while</span>((c = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BufferedInputStream通过FileInputStream提供的本地方法readBytes，可以通过一次IO操作读取多个字节数据。</p><ul><li>BufferedOutputStream通过非缓冲字节流FileOutputStream进行一次磁盘IO，将内存缓冲区<br>buffer中的多个字节数据一次性写入文件中，减少IO操作次数。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedOutputStreamDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://test/target.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="comment">// 写入字符 &#x27;2&#x27; 到内存buffer</span></span><br><span class="line">            bos.write(<span class="number">50</span>);</span><br><span class="line">            <span class="comment">// 写入字符 &#x27;0&#x27; 到内存buffer</span></span><br><span class="line">            bos.write(<span class="number">48</span>);</span><br><span class="line">            <span class="comment">// 写入字符 &#x27;2&#x27; 到内存buffer </span></span><br><span class="line">            bos.write(<span class="number">50</span>);</span><br><span class="line">            <span class="comment">// 写入字符 &#x27;3&#x27; 到内存buffer</span></span><br><span class="line">            bos.write(<span class="number">51</span>);</span><br><span class="line"><span class="comment">// 可在此 sleep 10s，去检测文件内容， 10s后调用了flush方法文件内容才写入         </span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(10000);</span></span><br><span class="line"><span class="comment">//        &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">            <span class="comment">// 刷新输出流，将内存buffer数据写到文件中</span></span><br><span class="line">            <span class="comment">// 缓冲流的close方法调用时，会先自动调用一次flush方法，强制将数据写出</span></span><br><span class="line">            <span class="comment">// 但是明确后续没有数据可写时，最好养成良好习惯，手动调用一次flush方法</span></span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BufferedOutputStream此时依赖的方法是非缓冲字节流FileOutputStream提供的本地方法writeBytes。</p><h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><p>字符缓冲流主要包括缓冲输入流BufferedReader，缓冲输出流BufferedWriter。</p><ul><li>BufferedReader可基于InputStreamReader、FileReader等非字符缓冲流构造。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D://test/source.txt&quot;</span>))) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="comment">// 按行读取，自动处理回车换行符</span></span><br><span class="line">            <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于FileReader构造BufferedReader</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;D://test/source.txt&quot;))</span><br></pre></td></tr></table></figure><ul><li>BufferedWriter可基于OutputStreamReader、FileWriter等非字符缓冲流构造。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriterDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://test/target.txt&quot;</span>)))) &#123;</span><br><span class="line">            bw.write(<span class="string">&quot;2023&quot;</span>);</span><br><span class="line">            <span class="comment">// windows换行符</span></span><br><span class="line">            <span class="comment">// bw.write(&quot;\r\n&quot;);</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.write(<span class="string">&quot;2023&quot;</span>);</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于FileWriter构造BufferedWriter</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;D://test/target.txt&quot;))</span><br></pre></td></tr></table></figure><p>基于PrintWriter构造BufferedWriter</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 BufferedWriter bw = new BufferedWriter(new PrintWriter(new FileWriter(&quot;D://test/</span><br></pre></td></tr></table></figure><p>flush方法是属于输出流的方法，调用非缓冲流的flush方法不会产生任何作用。</p>]]></content>
      
      
      <categories>
          
          <category> Java知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符流</title>
      <link href="/archives/f57b30c8.html"/>
      <url>/archives/f57b30c8.html</url>
      
        <content type="html"><![CDATA[<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>Java采用Unicode规范处理字符，字符流IO自动将Java内部字符格式与本地字符集进行转换，自动解<br>码编码，因此比起直接使用IO字节流，字符流操作相对更简单高效，所有的字符操作流都是从抽象类<br>Reader以及Writer继承而来。</p><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>字符都有编码，读写字符时的编码不一致，则容易出现乱码，因此首先需要简单了解下常⻅的字符编<br>码规则。</p><p><strong>ASCII码</strong></p><p>ASCII是American Standard Code for Information Interchange缩写，称为美国信息交换标准代码。<br>ASCII一共定义了 128 个字符，其中 33 个字符是不可显示的控制字符， 95 个可显示的字符。</p><p>一个字节占 8 位，2^8&#x3D;256，即一个字节可表示 256 个字符(0<del>255)，而ASCII字符只有 128 个，因此一个字节的低 7 位，2^7&#x3D;128，足以表达全部的ASCII字符(0</del>127)，128~255则预留扩展其它字符，但 128 位根本不足以表示其它国家的字符。</p><p><strong>GBK</strong></p><ul><li>GBK全称汉字内码扩展规范，GBK一共收集了^2 万多汉字与字符，一个中文字符编码成两个字节进<br>行存储。</li><li>GBK兼容了ASCII字符集</li></ul><p>GBK是从GB2312编码规范上扩展的，而中国的汉字与符号有数十万，显然GBK也是不够的，因此又出现了GB18030, 按照字符集表示范围GB18030 &gt; GBK &gt; GB2312。</p><p><strong>Unicode</strong></p><p>各个国家都有自己的编码，当计算机信息在国际上进行交换时，就会出现问题，如用GBK编码的字节<br>数据发送给A国家，A国家采用A国码解码肯定就出现了乱码，此时国际标准组织就制定了一套通用的字<br>符集Unicode，即统一码，也叫万国码。</p><ul><li>Unicode字符集收纳了世界上所有文字、符号，统一进行编号</li></ul><p><strong>UTF-8</strong></p><p>Unicode只是一种字符集，并不是编码方案，没有编码方案则无法存储。Unicode字符集出现最早的编<br>码方案是UTF-32，它规定所有的字符都采用固定的 4 个字节来表示， 4 个字节3 2位，可以表示 42 亿字<br>符，足以支撑Unicode字符集。即使只需一个字节的ASCII字符a(二进制0110 0001 )，也必须用 4 个字<br>节表示，前三字节直接补 0 。</p><p>UTF-32采用固定字节编码，程序处理简单，但是占用空间太大，基本很少使用，此时国际标准组织推出了Unicode编码方案UTF-8。</p><ul><li>UTF-8针对Unicode字符集采取可变⻓编码方案，共分为四个⻓度区，1~4个字节</li><li>英文、数字等只占用一个字节(兼容标准的ASCII编码)，汉字字符占用^3 个字节</li></ul><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p>Reader读取字符流，子类必须实现read、close方法，大部分子类会覆盖Reader中方法，提供更高效<br>的操作或者一些额外的功能。</p><p>Reader提供的方法</p><p>1.4.3 Writer</p><p>Writer用于将字符写入到字符流中，子类必须实现write、flush、close方法，大部分子类会覆盖Writer<br>中方法，提供更高效的操作或者一些额外的功能。Note: 下图中少了一个常用的PrintWriter</p><h4 id="操作使用"><a href="#操作使用" class="headerlink" title="操作使用"></a>操作使用</h4><p>一个字符流通常包装一个字节流，通过字节流去实现底层物理IO操作，字符流处理字符与字节之间的数据转换。在Java中有两个通用的字节到字符的桥接流，InputStreamReader与 OutputStreamReader。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyCharacters</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://test/source.txt&quot;</span>));</span><br><span class="line">             <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(</span><br><span class="line">                     <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://test/target.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">int</span> c;</span><br><span class="line">            <span class="keyword">while</span>((c=isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(c);</span><br><span class="line">                osw.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字符流编码"><a href="#字符流编码" class="headerlink" title="字符流编码"></a>字符流编码</h5><p>上述main方法在构造字符输入输出流时，未明确指定读写字符编码，字符流最终采用的是系统平台默<br>认编码。</p><ul><li>Windows中文系统默认是GBK</li><li>Linux系统默认是UTF-8</li></ul><p>Java在安装时，根据系统编码自动设置Java系统属性，通过如下命令查看Java系统属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 java -XshowSettings:property -version</span><br></pre></td></tr></table></figure><p>Java系统属性值中有 2 个与编码相关的属性</p><ul><li><strong>file.encoding</strong> ：这个非常重要，在Java中读取文件、URLEncode、字符串数据编码等都与此属性<br>有关。</li><li>sun.jnu.encoding：不用关注，用于JVM查找加载class的类名路径编码等</li></ul><p>注意：在Windows下开发时，使用Java命令查看Java系统属性时，file.encoding&#x3D;GBK，当使用IDEA<br>工具开发项目时，通过IDEA给项目又设置了UTF-8编码，最终IDEA运行Java程序时，会通过-Dfile.encoding&#x3D;UTF-8去覆盖默认的编码。当开发过程中遇⻅字符乱码时，需要关注JVM实际运行时的系统属性，也可通过代码获取。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 String fileEncoding = System.getProperty(&quot;file.encoding&quot;)</span><br></pre></td></tr></table></figure><p>指定字符编码构造字符输入输出流</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 指定UTF-8编码读字符数据</span><br><span class="line">new InputStreamReader(new FileInputStream(&quot;D://test/source.txt&quot;), StandardCharse</span><br><span class="line">// 指定UTF-8编码写字符数据</span><br><span class="line">new OutputStreamWriter(new FileOutputStream(&quot;D://test/target.txt&quot;), StandardChar</span><br></pre></td></tr></table></figure><p>读写字符数据时编码必须保持一致，否则会出现字符乱码。<br>在中文Windows上使用记事本新建D:&#x2F;&#x2F;test&#x2F;source.txt文件，写入 2023,星云训练营 ，然后以ANSI编码 保存，在Windows中文系统上ANSI处理中文时就是GBK。</p><h5 id="文件读写字符流"><a href="#文件读写字符流" class="headerlink" title="文件读写字符流"></a>文件读写字符流</h5><p>Java中还提供了FileReader、FileWriter简化了从文件读写字符，其内部自动封装包裹了对应的文件字节流，但是采用FileReader、FileWriter时只能使用JVM默认编码，无法单独设置读取字符的编码，因 此统一编码非常重要。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// InputStreamReader从文件读取字符内容</span><br><span class="line">new InputStreamReader(new FileInputStream(&quot;D://test/source.txt&quot;), StandardCharse</span><br><span class="line">// OutputStreamWriter将字符内容写入文件</span><br><span class="line">new OutputStreamWriter(new FileOutputStream(&quot;D://test/target.txt&quot;), StandardChar</span><br></pre></td></tr></table></figure><p>使用FileReader、FileWriter读写字符内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyFileCharacters</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D://test/source.txt&quot;</span>);</span><br><span class="line">             <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D://test/target.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 查看FileReader读取字符编码</span></span><br><span class="line">            System.out.println(fr.getEncoding());</span><br><span class="line">            <span class="comment">// 查看FileWriter写入字符编码</span></span><br><span class="line">            System.out.println(fw.getEncoding());</span><br><span class="line">            <span class="type">int</span> c;</span><br><span class="line">            <span class="keyword">while</span> ((c = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(c);</span><br><span class="line">                fw.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要追加内容到文件中，请使用FileWriter两个参数的构造方法，第二个参数设置为true</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public FileWriter(File file, boolean append)</span><br><span class="line">// 第二个参数为true，字节内容会从文件末尾开始写入</span><br><span class="line">FileWriter fw = new FileWriter(&quot;D://test/target.txt&quot;, true);</span><br></pre></td></tr></table></figure><p>字符流IO经常会以更大单位读取字符，最常用的就是按行读取字符。一行包括一系列字符组成的字符串以及末尾的行结束符，行结束符可以是回⻋换行符\r\n，也可以是单个回⻋键字符\r，或者单个换行符\n。不同的操作系统，其换行符可能有所不同。</p><ul><li>Dos、Windows采用回⻋+换行符(CR+LF)表示下一行，即字符表现形式\r\n</li><li>Unix、Linux采用换行符(LF)表示下一行，字符表现形式为\n</li><li>Mac采用回⻋符(CR)表示下一行，字符表现形式为\r</li></ul><p>CR回⻋符ascii码十进制为13, 换行符ascii码十进制为 10 。</p><p>支持按行读写的字符流有BufferedReader、BufferedWriter、PrintWriter等，根据操作系统自动处理行结束符。</p>]]></content>
      
      
      <categories>
          
          <category> Java知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节流</title>
      <link href="/archives/65fc60d0.html"/>
      <url>/archives/65fc60d0.html</url>
      
        <content type="html"><![CDATA[<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>字节流的输入输出都是以字节为单位处理数据，一个字节等于 8 个二进制位，即由 8 位 0 或 1 组成的序列，如 01102300 为一个字节。在Java中所有的字节流都是从抽象类InputStream或OutputStream 类继承而来。大部分字节流使用方式相同，只是它们的构造方式可能不一样。</p><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/javabase/img_1.png" alt="image.png"></p><p>InputStream提供的方法</p><table><thead><tr><th>方法名</th><th>签名</th><th>描述</th></tr></thead><tbody><tr><td>read</td><td>public abstract int read()</td><td>这是一个抽象方法，需要子类实现，用于从输入流中读取下一个字节数据。由于一个字节是 8 位，返回值介于0~255之间，如果没有可读数据，即达到了流的末尾，则返回-1。方法会一直阻塞直到有字节数据可读、到达流末尾或者发生IO异常。</td></tr><tr><td>read</td><td>public int read(byte b[])</td><td>从输入流中读取b.length个字节，并储存到字节数组b中，如果b⻓度为 0 ，则不会读取任何字节数据，方法返回 0 。 read(byte b[]) -&gt; read(byte b[], int off, int len) -&gt; read</td></tr><tr><td>read</td><td>public int read(byte b[], int off, int len)</td><td>从输入流中读取最多len个字节，如果len为 0 ，不会读取任何字节数据，直接返回 0 ，读取的字节从数组b的off位置开始存放。 read(byte b[], int off, int len) -&gt; read()</td></tr><tr><td>skip</td><td>public long skip(long n)</td><td>跳过并丢弃输入流中的n个字节数据，通过调用read(byte b[], int off, int len)读取字节并丢弃。</td></tr><tr><td>available</td><td>public int available()</td><td>返回下一次操作时，输入流中预估的可读字节数量</td></tr><tr><td>close</td><td>public void close()</td><td>关闭输入流，释放与流关联的系统资源</td></tr><tr><td>markSupported</td><td>public boolean markSupported()</td><td>用于测试输入流是否支持mark与reset方法</td></tr><tr><td>mark</td><td>public synchronized void mark(int readlimit)</td><td>在输入流中标记当前位置，标记位置后，还可以读取最多readlimit字节，后续可以通过reset方法回到上一次mark的位置，达到重复读取相同字节数据的操作，使用mark方法，则markSupported必须返回true，在关闭的流中调用mark方法，不会有任何效果。</td></tr><tr><td>reset</td><td>public synchronized void reset()</td><td>在流中复位，回到上一次调用mark方法标记的位置，如果未发现任何mark或者上一次mark标记后读取的字节数超过readlimit，则发生IOException，使用reset方法，则markSupported必须返回true。</td></tr></tbody></table><p>InputStream中的方法大部分都是一种规范，最终的字节流子类某些方法可能会有所不同。</p><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><p>OutputStream提供的方法</p><table><thead><tr><th>方法名</th><th>签名</th><th>描述</th></tr></thead><tbody><tr><td>write</td><td>public abstract void write(int b)</td><td>这是一个抽象方法，需要子类实现，用于将指定的字节数据写入到输出流中，在Java中int是 32 位，4个字节，write方法实际写入的只是整型数据b的低 8位，其余 24 位直接忽略。write  public void write(byte b[])  将字节数组b中的数据写入到输出流中，write(byte b[])-&gt;write(byte b[], int off, int len)-&gt;write()</td></tr><tr><td>write</td><td>public void write(byte b[], int off, int len)</td><td>从字节数组b下标为off的位置开始，将len个字节数据写入到输出流中。write(byte b[], int off, int len)-&gt;write()</td></tr><tr><td>flush</td><td>public void flush()</td><td>刷新输出流，强制一些缓冲输出流将内部缓冲的一些字节数据立即写入目标地，如果目标地是磁盘文件，调用flush方法后，并不保证文件⻢上更新，这取决于操作系统。</td></tr><tr><td>close</td><td>public void close()</td><td>关闭输出流，释放与流关联的系统资源</td></tr></tbody></table><h4 id="操作使用"><a href="#操作使用" class="headerlink" title="操作使用"></a>操作使用</h4><p>文件IO字节流FileInputStream、FileOutputStream是使用最广泛的两个类，以这两个类进行操作说明。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyBytes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 文件数据输入流，如果文件不存在或者是一个目录，则发生FileNotFoundException</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://test/source.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 数据输出流，目标文件不存在，大部分系统都会自动创建，如果文件已存在，则覆盖文件中已有内容</span></span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://test/target.txt&quot;</span>);</span><br><span class="line">            <span class="type">int</span> c;</span><br><span class="line">            <span class="comment">// 如果返回-1，表示已经读到流的末端</span></span><br><span class="line">            <span class="keyword">while</span> ((c = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是ascii字符，每个字符对应的整型值一定是0~127，</span></span><br><span class="line">                <span class="comment">// 如果是汉字，而一个汉字由多个字节组成，因此会输出多个整型数据，128~255</span></span><br><span class="line">                System.out.print(c + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                fos.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 从输入流读取数据完成后，一定要关闭流，释放系统资源</span></span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将数据写入输出流完成后，一定要关闭流，释放系统资源</span></span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IO流操作完成后，一定要在finally语句块中进行关闭，Java7开始提供了try-with-resources语法，编<br>译器识别该语法后，在字节码文件中自动生成了对应的finally语句块，并在语句块中关闭对应的流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用try-with-resources语法读写文件代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyBytes2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://test/source.txt&quot;</span>);</span><br><span class="line">             <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://test/target.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> c;</span><br><span class="line">            <span class="comment">// 内容长度(可读取的字节数量)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;内容有效字节数: &quot;</span> + fis.available());</span><br><span class="line">            <span class="keyword">while</span> ((c = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(c + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                fos.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如source.txt文件有如下字符内容：I2023,我 ，文件编码为UTF-8时输出 9 个字节(汉字占用了三个字节)。</p><p>最后三个大于 127 的十进制值则表示汉字 我，其余的对应的是ascii字符。</p><p>FileOutputStream可以控制字节内容写入起始位置</p><ul><li>通过new FileOutputStream(D:&#x2F;&#x2F;test&#x2F;target.txt) 构造输出流</li></ul><p>每次从文件开头写入字节数据，因此会覆盖上一次打开文件时写入的内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://test/target.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2023,Ksyun 星云训练营&quot;</span>;</span><br><span class="line">            <span class="comment">// 调用FileOutputStream的write(byte b[])方法，写入多个字节</span></span><br><span class="line">            fos.write(s.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过new FileOutputStream(D:&#x2F;&#x2F;test&#x2F;target.txt, true) 构造输出流</li></ul><p>每次从文件末尾写入字节数据，相当于向文档中追加数据内容，多次运行上述main方法，会发现<br>D:&#x2F;&#x2F;test&#x2F;target.txt文件内容增加。</p><p>字节流是IO流中最底层的低水平操作流，文件中包含的是字符数据，更高效的方法是通过字符流进行操作。</p>]]></content>
      
      
      <categories>
          
          <category> Java知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件操作</title>
      <link href="/archives/95495db.html"/>
      <url>/archives/95495db.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-文件操作"><a href="#1-1-文件操作" class="headerlink" title="1.1 文件操作"></a>1.1 文件操作</h3><p>java.io.File是Java提供的专⻔针对文件操作的类，File是文件与目录路径的一种抽象表示，用于操作文件与目录，不能操作文件内容。</p><h4 id="构造File对象"><a href="#构造File对象" class="headerlink" title="构造File对象"></a>构造File对象</h4><p>一个File对象通常表示磁盘上一个真实存在的文件或目录，创建File对象时，无论对应的文件与目录是否存在，不会影响File对象的构造。</p><p><strong>常用的三个构造File方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public File(String pathname)</td><td>通过给定的路径名创建指定的File实例</td></tr><tr><td>public File(String parent</td><td>String child)  根据指定的父路径与子路径字符串创建File实例</td></tr><tr><td>public File(File parent</td><td>String child)  根据指定的父路径File与子路径字符串创建新的File实例</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建表示一个目录的File实例</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建表示文件的File实例</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">sourceFile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test&quot;</span>, <span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据父路径File实例创建新的File实例</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">sourceFile2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir, <span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用的判断方法"><a href="#常用的判断方法" class="headerlink" title="常用的判断方法"></a>常用的判断方法</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public boolean exists()</td><td>判断文件或者目录是否存在</td></tr><tr><td>public boolean isDirectory()</td><td>判断File表示的路径是否是一个目录</td></tr><tr><td>public boolean isFile()</td><td>判断File表示的路径是否是一个文件</td></tr><tr><td>public boolean isHidden()</td><td>判断File是否是一个隐藏的文件与路径，即Unix以. 开始命名的文件或目录，Window需要在文件系统中 明确标记是否隐藏。</td></tr><tr><td>public boolean canRead()</td><td>判断是否可读</td></tr><tr><td>public boolean canWrite()</td><td>判断是否可写public boolean canExecute()  判断是否可执行</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">hiddenSshDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test/hidden&quot;</span>);</span><br><span class="line">    System.out.println(hiddenSshDir.isHidden()); <span class="comment">// true</span></span><br><span class="line">    System.out.println(hiddenSshDir.isFile()); <span class="comment">// false</span></span><br><span class="line">    System.out.println(hiddenSshDir.isDirectory()); <span class="comment">//true</span></span><br><span class="line">    System.out.println(hiddenSshDir.exists()); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用的获取属性方法"><a href="#常用的获取属性方法" class="headerlink" title="常用的获取属性方法"></a>常用的获取属性方法</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public String getName()</td><td>获取文件名或目录名，如source.txt</td></tr><tr><td>public String getAbsolutePath()</td><td>获取文件或目录绝对路径</td></tr><tr><td>public String getPath()</td><td>获取文件或目录相对路径，如果构造File时指定的就是绝对路径，则与getAbsolutePath返回内容一致，如果是相对路径，则以系统属性user.dir为目录创建。</td></tr><tr><td>public long length()</td><td>返回文件内容大小，单位字节。如果File表示的是目录，则返回0。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">sourceFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test/dir&quot;</span>); </span><br><span class="line">    System.out.println(sourceFile.getName()); <span class="comment">// dir</span></span><br><span class="line">    System.out.println(sourceFile.getAbsolutePath()); <span class="comment">// D:\workspace\base-star-point\test\dir</span></span><br><span class="line">    System.out.println(sourceFile.getParent()); <span class="comment">// test</span></span><br><span class="line">    System.out.println(sourceFile.getPath()); <span class="comment">// test\dir</span></span><br><span class="line">    System.out.println(sourceFile.length()); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作文件方法"><a href="#操作文件方法" class="headerlink" title="操作文件方法"></a>操作文件方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法  描述 </span><br><span class="line">public boolean createNewFile()  创建文件，如果文件已经存在，则返回false。 </span><br><span class="line">public boolean mkdir()  创建目录 </span><br><span class="line">public boolean mkdirs() </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建目录，父路径中任何一级目录不存在都会自动创</span><br><span class="line">建，类似mkdir -p /data/test/dir 命令 </span><br><span class="line">public boolean delete()  删除文件或目录，如果File是一个目录，并且目录不</span><br><span class="line">为空，则无法删除， 文件或目录正被其他程序使</span><br><span class="line">用，也无法删除。 </span><br><span class="line">public boolean renameTo(File dest)  重命名文件，即移动文件 </span><br></pre></td></tr></table></figure><p>创建文件或目录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test/txt&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">suc</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line">    System.out.println(suc); <span class="comment">// true，创建成功</span></span><br><span class="line">    suc = file.createNewFile();</span><br><span class="line">    System.out.println(suc); <span class="comment">// false, 文件已经存在</span></span><br><span class="line">    suc = file.mkdir();</span><br><span class="line">    System.out.println(suc); <span class="comment">// fasle, 相同路径名的文件已经存在，无法创建同名目录</span></span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test/a/b/c&quot;</span>);</span><br><span class="line">    suc = dir.mkdir();</span><br><span class="line">    System.out.println(suc); <span class="comment">// false，无法创建目录c, 父目录D://test/a/b不存在</span></span><br><span class="line">    suc = dir.mkdirs();</span><br><span class="line">    System.out.println(suc); <span class="comment">// true，整个目录D://test/a/b/c全部创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重命名文件，将D:&#x2F;&#x2F;test&#x2F;source.txt移动到D:&#x2F;&#x2F;test&#x2F;sub目录，并命名为b.txt。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test/source.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test/sub&quot;</span>);</span><br><span class="line">    dir.mkdir();</span><br><span class="line">    <span class="type">File</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test/sub/b.txt&quot;</span>);</span><br><span class="line">    System.out.println(source.renameTo(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建临时文件</p><p>File提供了一个静态方法创建临时文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未指定临时目录，使用系统属性java.io.tmpdir值作为临时目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title function_">createTempFile</span><span class="params">(String prefix, String suffix)</span></span><br><span class="line"><span class="comment">// 指定临时目录创建临时文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title function_">createTempFile</span><span class="params">(String prefix, String suffix, File directory)</span></span><br></pre></td></tr></table></figure><p>创建临时文件时，可以指定系统临时目录，File类默认使用系统属性java.io.tmpdir( java -<br>XshowSettings:properties -version 查看)值作为临时目录，后缀未填写则默认为.tmp。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> System.getProperties();</span><br><span class="line">    properties.forEach((k,v) -&gt; System.out.println(k + <span class="string">&quot;=&quot;</span> + v));</span><br><span class="line">    <span class="comment">// C:\Users\SUNJINFU\AppData\Local\Temp\test-1385972536118005697.log</span></span><br><span class="line">    System.out.println(File.createTempFile(<span class="string">&quot;test-&quot;</span>, <span class="string">&quot;.log&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历文件目录"><a href="#遍历文件目录" class="headerlink" title="遍历文件目录"></a>遍历文件目录</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public String[] list()</td><td>返回目录下子文件与子目录名，不是目录直接返回null</td></tr><tr><td>public String[] list(FilenameFilter filter)</td><td>返回目录下符合文件名条件的子文件与子目录字符串名</td></tr><tr><td>public File[] listFiles()</td><td>与list方法类似，返回类型是File数组</td></tr><tr><td>public File[] listFiles(FilenameFilter filter)</td><td>返回目录下符合文件名条件的子文件或子目录File数组</td></tr><tr><td>public File[] listFiles(FileFilter filter)</td><td>返回目录下符合条件的子文件或子目录File数组</td></tr></tbody></table><p>删除指定目录下的所有.txt文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过name filter过滤出文件名后缀为.txt的文件</span></span><br><span class="line">    File[] files = file.listFiles((dir, name) -&gt; name.endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (files != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            f.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除目录，如果目录不为空，则需先遍历删除子文件、子目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\test&gt;tree /f</span><br><span class="line">│ 1.log</span><br><span class="line">│</span><br><span class="line">├─a</span><br><span class="line">│ a.txt</span><br><span class="line">│</span><br><span class="line">└─b</span><br><span class="line">└─c</span><br><span class="line">c.txt</span><br></pre></td></tr></table></figure><p>删除D:&#x2F;&#x2F;test目录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteDirectoryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test&quot;</span>);</span><br><span class="line">        deleteFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断文件是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是文件，直接删除</span></span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!file.delete()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;failed to delete file: &quot;</span> +  file.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是目录，则先遍历删除目录下文件或者子目录</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(files) &amp;&amp; files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                deleteFile(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后删除目录</span></span><br><span class="line">        <span class="keyword">if</span> (!file.delete()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;failed to delete directory: &quot;</span> +  file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h4><p>从Java7开始，在java.nio.file包下提供了一个文件或者目录操作工具类Files，F iles的方法基本都是静<br>态方法，该类不仅能操作文件，还能结合IO流操作文件内容。与File类相比，Files的很多方法都能明确<br>的返回操作失败的异常信息，而不是只返回简单的true或者false。</p><p>如test目录不存在时直接使用Files创建source.txt</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Exception in thread &quot;main&quot; java.nio.file.NoSuchFileException:</span><br><span class="line">D:\test\source.txt</span><br><span class="line">Files.createFile(Paths.get(&quot;D://test/source.txt&quot;));</span><br></pre></td></tr></table></figure><p>删除不存在的文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Exception in thread &quot;main&quot; java.nio.file.NoSuchFileException: D:\test\1.txt</span><br><span class="line">Files.delete(Paths.get(&quot;D://test/1.txt&quot;));</span><br></pre></td></tr></table></figure><p>Files提供了非常丰富的方法，按功能分为如下几类方法<br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/javabase/img.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java知识点 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tcp重传机制</title>
      <link href="/archives/f0dbbb2a.html"/>
      <url>/archives/f0dbbb2a.html</url>
      
        <content type="html"><![CDATA[<h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。</p><p>显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。</p><p>但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。</p><p>快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。</p><p>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。<br>与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p><h3 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h3><p>死等M3，当发送方发现收不到M3的ack超时后，会重传M3。一旦接收方收到M3后，会ack 回M4——意味着M3和M4都收到了。</p><p>但是，这种方式会有比较严重的问题，那就是因为要死等M3，所以会导致M4和M5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。</p><p>对此有两种选择：</p><ul><li>一种是仅重传timeout的包。也就是第3份数据。</li><li>另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。<br>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp的拥塞控制</title>
      <link href="/archives/eff1f5b6.html"/>
      <url>/archives/eff1f5b6.html</url>
      
        <content type="html"><![CDATA[<h2 id="tcp拥塞控制"><a href="#tcp拥塞控制" class="headerlink" title="tcp拥塞控制"></a>tcp拥塞控制</h2><h3 id="拥塞控制的原理"><a href="#拥塞控制的原理" class="headerlink" title="拥塞控制的原理"></a>拥塞控制的原理</h3><ul><li><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p></li><li><p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p></li></ul><h3 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h3><ul><li>当主机开始发送数据时，如果立即将大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。</li><li>通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</li><li>慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd&#x3D;1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</li></ul><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下：</p><ul><li>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当 cwnd &#x3D; ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。拥塞避免</li></ul><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><ul><li>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</li><li>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</li><li>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</li></ul><h3 id="乘法减小和加法增大"><a href="#乘法减小和加法增大" class="headerlink" title="乘法减小和加法增大"></a>乘法减小和加法增大</h3><ul><li>乘法减小：是指不论在慢开始阶段还是拥塞避免阶段，只要出现超时，就把慢开始门限减半，即设置为当前的拥塞窗口的一半（于此同时，执行慢开始算法）。当网络出现频繁拥塞时，ssthresh值就下降的很快，以大大将小注入到网络中的分组数。</li><li>加法增大：是指执行拥塞避免算法后是拥塞窗口缓慢增大，以防止网络过早出现拥塞。</li></ul><h3 id="拥塞控制和流量控制的差别"><a href="#拥塞控制和流量控制的差别" class="headerlink" title="拥塞控制和流量控制的差别"></a>拥塞控制和流量控制的差别</h3><ul><li>所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。</li><li>拥塞问题是一个全局性的问题,涉及到所有的主机、所有的路由器、以及与降低网络传输性能有关的所有因素。</li><li>流量控制往往指的是点对点通信量的控制，是个端到端的问题。流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp的流量控制</title>
      <link href="/archives/cbdf39b9.html"/>
      <url>/archives/cbdf39b9.html</url>
      
        <content type="html"><![CDATA[<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><h3 id="什么是流量控制"><a href="#什么是流量控制" class="headerlink" title="什么是流量控制"></a>什么是流量控制</h3><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，对发送方发送速率的控制，要让接收方来得及接收。</p><p><strong>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制</strong></p><h3 id="如何控制？"><a href="#如何控制？" class="headerlink" title="如何控制？"></a>如何控制？</h3><p>接收方每次收到数据包，可以在发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，我们也把缓存区的剩余大小称之为接收窗口大小，用变量win来表示接收窗口的大小。<br>发送方收到之后，便会调整自己的发送速率，也就是<strong>调整</strong>自己发送窗口的<strong>大小</strong>，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，<strong>防止出现大量丢包情况的发生</strong>。</p><h3 id="发送方何时再继续发送数据"><a href="#发送方何时再继续发送数据" class="headerlink" title="发送方何时再继续发送数据?"></a>发送方何时再继续发送数据?</h3><p>当发送方收到接受窗口 win &#x3D; 0 时，这时发送方停止发送报文，并且同时开启一个<strong>定时器</strong>（心跳包），每隔一段时间就发个测试报文去询问接收方，打听是否可以继续发送数据了，如果可以，接收方就告诉他此时接受窗口的大小；如果接受窗口大小还是为0，则发送方再次刷新启动定时器。</p><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><ul><li>由于TCP&#x2F;IP支持<strong>全双工传输</strong>，因此通信的双方都拥有两个滑动窗口，一个用于接受数据，称之为<strong>接收窗口</strong>；一个用于发送数据，称之为<strong>拥塞窗口</strong>(即发送窗口)。指出接受窗口大小的通知我们称之为窗口通告。</li><li>在早期的TCP协议中，接受接受窗口的大小确实是固定的，不过随着网络的快速发展，固定大小的窗口太不灵活了，成为TCP性能瓶颈之一，也就是说，在现在的TCP协议中，接受窗口的大小是根据某种算法动态调整的。</li><li>接受窗口如果太小的话，显然是不行的，这会严重浪费链路利用率，增加丢包率。那是否越大越好呢？答否，当接收窗口达到某个值的时候，再增大的话也不怎么会减少丢包率的了，而且还会更加消耗内存。所以接收窗口的大小必须根据网络环境以及发送发的的拥塞窗口来<strong>动态调整</strong>。</li><li>接收方在发送确认报文的时候，会告诉发送发自己的接收窗口大小，而发送方的发送窗口会据此来设置自己的发送窗口，但这并不意味着他们就会相等。首先接收方把确认报文发出去的那一刻，就已经在一边处理堆在自己缓存区的数据了，所以一般情况下<strong>接收窗口</strong> &gt;&#x3D; <strong>发送窗口</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/archives/be82d226.html"/>
      <url>/archives/be82d226.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/archives/4a17b156.html"/>
      <url>/archives/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
