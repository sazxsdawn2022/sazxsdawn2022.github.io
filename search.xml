<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>压缩工具类</title>
      <link href="/2023/04/29/bolg/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2023/04/29/bolg/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><em><strong>用于文件的压缩工具类</strong></em></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 压缩方法</span></span><br><span class="line"><span class="comment"> * （可以压缩空的子目录）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcPath     压缩源路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> zipFileName 目标压缩文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">zip</span><span class="params">(String srcPath, String zipFileName)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">    <span class="comment">// 扫描所有要压缩的文件</span></span><br><span class="line">    List&lt;File&gt; fileList = getAllFiles(srcFile);</span><br><span class="line">    <span class="comment">// 缓冲器</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">512</span>];</span><br><span class="line">    <span class="type">ZipEntry</span> <span class="variable">zipEntry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 每次读出来的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">readLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ZipOutputStream</span> <span class="variable">zipOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(zipFileName));</span><br><span class="line">        <span class="keyword">for</span> (File file : fileList) &#123;</span><br><span class="line">            <span class="comment">// 若是文件，则压缩这个文件</span></span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                zipEntry = <span class="keyword">new</span> <span class="title class_">ZipEntry</span>(getRelativePath(srcPath, file));</span><br><span class="line">                zipEntry.setSize(file.length());</span><br><span class="line">                zipEntry.setTime(file.lastModified());</span><br><span class="line">                zipOutputStream.putNextEntry(zipEntry);</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">                <span class="keyword">while</span> ((readLength = inputStream.read(buffer, <span class="number">0</span>, BUFFER)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    zipOutputStream.write(buffer, <span class="number">0</span>, readLength);</span><br><span class="line">                &#125;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//若是目录（即空目录）则将这个目录写入zip条目</span></span><br><span class="line">                zipEntry = <span class="keyword">new</span> <span class="title class_">ZipEntry</span>(getRelativePath(srcPath, file) + <span class="string">&quot;/&quot;</span>);</span><br><span class="line">                zipOutputStream.putNextEntry(zipEntry);</span><br><span class="line">                LogUtil.debug(LogType.Server,<span class="string">&quot;dir compressed: &quot;</span> + file.getCanonicalPath() + <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        zipOutputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取的给定源目录下的所有文件及空的子目录</span></span><br><span class="line"><span class="comment"> * 递归实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title function_">getAllFiles</span><span class="params">(File srcFile)</span> &#123;</span><br><span class="line">    List&lt;File&gt; fileList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    File[] tmp = srcFile.listFiles();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp[i].isFile()) &#123;</span><br><span class="line">            fileList.add(tmp[i]);</span><br><span class="line">            System.out.println(<span class="string">&quot;add file: &quot;</span> + tmp[i].getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp[i].isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 若不是空目录，则递归添加其下的目录和文件</span></span><br><span class="line">            <span class="keyword">if</span> (tmp[i].listFiles().length != <span class="number">0</span>) &#123;</span><br><span class="line">                fileList.addAll(getAllFiles(tmp[i]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若是空目录，则添加这个目录到fileList</span></span><br><span class="line">                fileList.add(tmp[i]);</span><br><span class="line">                System.out.println(<span class="string">&quot;add empty dir: &quot;</span> + tmp[i].getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fileList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取相对路径</span></span><br><span class="line"><span class="comment"> * 依据文件名和压缩源路径得到文件在压缩源路径下的相对路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dirPath 压缩源路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 相对路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getRelativePath</span><span class="params">(String dirPath, File file)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dirPath);</span><br><span class="line">    <span class="type">String</span> <span class="variable">relativePath</span> <span class="operator">=</span> file.getName();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(relativePath);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        file = file.getParentFile();</span><br><span class="line">        <span class="keyword">if</span> (file == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (file.equals(dir)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(file.getName()).append(<span class="string">&quot;/&quot;</span>).append(relativePath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis为什么这么快</title>
      <link href="/2023/03/31/technology/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/"/>
      <url>/2023/03/31/technology/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在日常开发中，为了保证数据的一致性，我们一般都选择关系型数据库来存储数据，如 MySQL，Oracle 等，因为关系型数据库有着事务的特性。然而在并发量比较大的业务场景，关系型数据库却又往往会成为系统瓶颈，无法完全满足我们的需求，所以就需要使用到缓存，而非关系型数据库，即 NoSQL 数据库往往又会成为最佳选择。</p><p>NoSQL 数据库最常见的解释是 non-relational，也有人解释为 Not Only SQL。非关系型数据库不保证事务，也就是不具备事务 ACID 特性，这也是非关系型数据库和关系型数据库最大的区别，而我们即将介绍的 Redis 就属于 NoSQL 数据库的一种。</p><h3 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis?"></a>什么是Redis?</h3><p>Redis 全称是：REmote DIctionary Service，即远程字典服务。Redis 是一个开源的（遵守 BSD 协议）、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库。<br>Redis 具有以下<strong>特性</strong>：</p><ul><li>支持丰富的数据类型：字符串（strings），散列（hashes），列表（lists），集合（sets），有序集合（sorted sets），位图等。</li><li>功能丰富：提供了持久化机制，过期策略，订阅&#x2F;发布等功能。</li><li>高性能，高可用且支持集群。</li><li>提供了多种语言的 API。</li></ul><h3 id="Redis到底有多快？"><a href="#Redis到底有多快？" class="headerlink" title="Redis到底有多快？"></a>Redis到底有多快？</h3><p>大家可能都知道 Redis 很快，可是 Redis 到底能有多快呢，比如 Redis 的吞吐量能达到多少？我想这就不是每一个人都能说的上来一个具体的数字了。</p><p>Redis 官方提供了一个测试脚本，可以供我们测试 Redis 的 吞吐量。</p><ul><li>redis-benchmark -q -n 100000 可以测试常用命令的吞吐量。</li><li>redis-benchmark -t set,lpush -n 100000 -q 测试 Redis 处理 set 和 lpush 命令的吞吐量。</li><li>redis-benchmark -n 100000 -q script load “redis.call(‘set’,’foo’,’bar’)” 测试 Redis 处理 Lua 脚本等吞吐量。</li></ul><p>比如执行第一条命令来测试结果，可以看到大部分命令的吞吐量都可以达到 4 万以上，也就是说每秒钟可以处理 4 万次以上请求。<br>但是如果你以为这就是 Redis 的真实吞吐量，那就错了。实际上，Redis 官方的测试结果是可以达到 10 万的吞吐量，下图就是官方提供的一个基准测试结果（纵坐标就是吞吐量，横坐标是连接数）：<br>  <img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/tec/img.png" alt="image.png"></p><h3 id="Redis-是单线程还是多线程"><a href="#Redis-是单线程还是多线程" class="headerlink" title="Redis 是单线程还是多线程"></a>Redis 是单线程还是多线程</h3><p>这个问题比较经典，因为在很多人的认知里，Redis 就是单线程的。然而 Redis 从 4.0 版本开始就有了多线程的概念，虽然处理命令请求的核心模块确实是保证了单线程执行，然而在其他许多地方已经有了多线程，比如：在后台删除对象，通过 Redis 模块实现阻塞命令，生成 dump 文件，以及 6.0 版本中网络 I&#x2F;O 实现了多线程等，而且在未来 Redis 应该会有越来越多的模块实现多线程。</p><p>所谓的单线程，只是说 Redis 的处理客户端的请求（即执行命令）时，是单线程去执行的，并不是说整个 Redis 都是单线程。</p><h3 id="Redis-为什么选择使用单线程来执行请求"><a href="#Redis-为什么选择使用单线程来执行请求" class="headerlink" title="Redis 为什么选择使用单线程来执行请求"></a>Redis 为什么选择使用单线程来执行请求</h3><p>Redis 为什么会选择使用单线程呢？这是因为 CPU 成为 Redis 瓶颈的情况并不常见，成为 Redis 瓶颈的通常是内存或网络带宽。例如，在一个普通的 Linux 系统上使用 pipelining 命令，Redis 可以每秒完成 100 万个请求，所以如果我们的应用程序主要使用 O(N) 或 O(log(N)) 复杂度的命令，它几乎不会使用太多的 CPU。</p><p>那么既然 CPU 不会成为瓶颈，理所当然的就没必要去使用多线程来执行命令，我们需要明确的一个问题就是多线程一定比单线程快吗？答案是不一定。因为多线程也是有代价的，最直接的两个代价就是线程的创建和销毁线程（当然可以通过线程池来一定程度的减少频繁的创建线程和销毁线程）以及线程的上下文切换。</p><p>在我们的日常系统中，主要可以区分为两种：CPU 密集型 和 IO 密集型。</p><ul><li><strong>CPU 密集型</strong>：这种系统就说明 CPU 的利用率很高，那么使用多线程反而会增加上下文切换而带来额外的开销，所以使用多线程效率可能会不升反降。举个例子：假如你现在在干活，你一直不停的在做一件事，需要 1 分钟可以做完，但是你中途总是被人打断，需要花 1 秒钟时间步行到旁边去做另一件事，假如这件事也需要 1 分钟，那么你因为反复切换做两件事，每切换一次就要花 1 秒钟，最后做完这 2 件事的时间肯定大于 2 分钟（取决于中途切换的次数），但是如果中途不被打断，你做完一件事再去做另一件事，那么你最多只需要切换 1 次，也就是 2 分 1 秒就能做完。</li><li><strong>IO 密集型</strong>：IO 操作也可以分为磁盘 IO 和网络 IO 等操作。大部分 IO 操作的特点是比较耗时且 CPU 利用率不高，所以 Redis 6.0 版本网络 IO 会改进为多线程。至于磁盘 IO，因为 Redis 中的数据都存储在内存（也可以持久化），所以并不会过多的涉及到磁盘操作。举个例子：假如你现在给树苗浇水，你每浇完一次水之后就需要等别人给你加水之后你才能继续浇，那么假如这个等待过程需要 5 秒钟，也就是说你浇完一次水就可以休息 5 秒钟，而你切换去做另一件事来回只需要 2 秒，那么你完全可以先去做另一件事，做完之后再回来，这样就可以充分利用你空闲的 5 秒钟时间，从而提升了效率。<br>使用多线程还会带来一个问题就是数据的安全性，所以多线程编程都会涉及到锁竞争，由此也会带来额外的开销。</li></ul><h3 id="什么是IO多路复用"><a href="#什么是IO多路复用" class="headerlink" title="什么是IO多路复用"></a>什么是IO多路复用</h3><p>I&#x2F;O 指的是网络 I&#x2F;O， 多路指的是多个 TCP 连接（如 Socket），复用指的是复用一个或多个线程。I&#x2F;O 多路复用的核心原理就是不再由应用程序自己来监听连接，而是由服务器内核替应用程序监听。</p><p>在 Redis 中，其多路复用有多种实现，如：select，epoll，evport，kqueue 等。</p><p>我们用去餐厅吃饭为的例子来解释一下 I&#x2F;O 多路复用机制（点餐人相当于客户端，餐厅的厨房相当于服务器，厨师就是线程）。</p><ul><li><strong>阻塞 IO</strong>：张三去餐厅吃饭，点了一道菜，这时候他啥事也不干了，就是一直等，等到厨师炒好菜，他就把菜端走开始吃饭了。也就是在菜被炒好之前，张三被阻塞了，这就是 BIO（阻塞 IO），效率会非常低下。</li><li><strong>非阻塞 IO</strong>：张三去餐厅吃饭，点了一道菜，这时候张三他不会一直等，找了个位置坐下，刷刷抖音，打打电话，做点其他事，然后每隔一段时间就去厨房问一下自己的菜好了没有。这种就属于非阻塞 IO，这种方式虽然可以提高性能，但是如果有大量 IO 都来定期轮询，也会给服务器造成非常大的负担。</li><li><strong>事件驱动机制</strong>：张三去餐厅吃饭，点了一道菜，这时候他找了个位置坐下来等：</li><li>厨房那边菜做好了就会把菜端出来了，但是并不知道这道菜是谁的，于是就挨个询问顾客，这就是多路复用中的 select 模型，不过 select 模型最多只能监听 1024 个 socket（poll 模型解决了这个限制问题）。</li><li>厨房做好了菜直接把菜放在窗口上，大喊一声，某某菜做好了，是谁的快过来拿，这时候听到通知的人就会自己去拿，这就是多路复用中的 epoll 模型。<br>需要注意的是在 IO 多路复用机制下，客户端可以阻塞也可以选择不阻塞（大部分场景下是阻塞 IO），这个要具体情况具体分析，但是在多路复用机制下，服务端就可以通过多线程（上面示例中可以多几个厨师同时炒菜）来提升并发效率。</li></ul><h3 id="Redis-中-I-O-多路复用的应用"><a href="#Redis-中-I-O-多路复用的应用" class="headerlink" title="Redis 中 I&#x2F;O 多路复用的应用"></a>Redis 中 I&#x2F;O 多路复用的应用</h3><p>Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：文件事件和时间事件。</p><ul><li>文件事件：Redis 服务器和客户端（或其他服务器）进行通信会产生相应的文件事件，然后服务器通过监听并处理这些事件来完成一系列的通信操作。</li><li>时间事件：Redis 内部的一些在给定时间之内需要进行的操作。</li></ul><p>Redis 的文件事件处理器以单线程的方式运行，其内部使用了 I&#x2F;O 多路复用程序来同时监听多个套接字（Socket）连接，提升了性能的同时又保持了内部单线程设计的简单性。下图就是文件事件处理器的示意图：<br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/tec/img_1.png" alt="image.png"><br>  I&#x2F;O 多路复用程序虽然会同时监听多个 Socket 连接，但是其会将监听的 Socket 都放到一个队列里面，然后通过这个队列有序的，同步的将每个 Socket 对应的事件传送给文件事件分派器，再由文件事件分派器分派给对应的事件处理器进行处理，只有当一个 Socket 所对应的事件被处理完毕之后，I&#x2F;O多路复用程序才会继续向文件事件分派器传送下一个 Socket 所对应的事件，这也可以验证上面的结论，处理客户端的命令请求是单线程的方式逐个处理，但是事件处理器内并不是只有一个线程。</p><h2 id="总结Redis快的原因"><a href="#总结Redis快的原因" class="headerlink" title="总结Redis快的原因"></a>总结Redis快的原因</h2><p>Redis 为什么这么快的原因前面已经基本提到了，现在我们再进行总结一下：</p><ul><li>Redis 是一款纯内存结构，避免了磁盘 I&#x2F;O 等耗时操作。</li><li>Redis 命令处理的核心模块为单线程，减少了锁竞争，以及频繁创建线程和销毁线程的代价，减少了线程上下文切换的消耗。</li><li>采用了 I&#x2F;O 多路复用机制，大大提升了并发效率。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>秒杀项目</title>
      <link href="/2023/03/30/bolg/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/03/30/bolg/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1、项目介绍"><a href="#1、项目介绍" class="headerlink" title="1、项目介绍"></a>1、项目介绍</h1><p> 本项目基于Springboot+Mysql+Redis+RibbitMQ+MyBatis-Plus等技术，保证了在高并发的情况下秒杀活动的 顺利进行。</p><h1 id="2、项目总结"><a href="#2、项目总结" class="headerlink" title="2、项目总结"></a>2、项目总结</h1><ul><li>首先基本秒杀功能实现</li><li>用redis进行优化，页面缓存，user对象缓存</li><li>解决复购和超卖</li><li>优化秒杀，逐步减少直接操作DB，操作reids</li><li>解决秒杀安全问题</li></ul><h1 id="3、项目功能实现"><a href="#3、项目功能实现" class="headerlink" title="3、项目功能实现"></a>3、项目功能实现</h1><h2 id="分布式会话-Session"><a href="#分布式会话-Session" class="headerlink" title="分布式会话&#x2F;Session"></a>分布式会话&#x2F;Session</h2><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><h4 id="用户登录-基础功能"><a href="#用户登录-基础功能" class="headerlink" title="用户登录-基础功能"></a>用户登录-基础功能</h4><p><strong>需求说明</strong><br>完成用户登录<br><strong>表结构设计</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `seckill_user` (</span><br><span class="line">`id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户 ID, 设为主键, 唯一手机号&#x27;</span>,  <span class="comment">--是手机号</span></span><br><span class="line">`nickname` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">`password` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;MD5(MD5(pass 明文+固定salt)+salt)&#x27;</span>, </span><br><span class="line">`slat` <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">`head` <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;头像&#x27;</span>, </span><br><span class="line">`register_date` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;注册时间&#x27;</span>, </span><br><span class="line">`last_login_date` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;最后一次登录时间&#x27;</span>, </span><br><span class="line">`login_count` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;登录次数&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p><strong>密码的设计：两次加盐</strong></p><ul><li>客户端—-md5(password 明文+<strong>salt1</strong>)–&gt; 后端(** md5(md5(password 明文+salt1)+salt2)** &#x3D;&#x3D;db中存放的 password 是否一致 ?)</li><li>通过在原始密码（字符串）的前后加上一个字符来生成 md5 加密后的密码（进行两次操作）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.seckill.util;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.DigestUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MD5Util: 工具类，根据前面密码设计方案提供相应的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MD5Util</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最基本的md5加密</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">md5</span><span class="params">(String src)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DigestUtils.md5Hex(src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备一个salt [前端使用盐]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SALT</span> <span class="operator">=</span> <span class="string">&quot;4tIY5VcX&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加密加盐, 完成的任务就是 md5(password明文+salt1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">inputPassToMidPass</span><span class="params">(String inputPass)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SALT.charAt(0)-&gt;&quot;</span> + SALT.charAt(<span class="number">0</span>));<span class="comment">//c</span></span><br><span class="line">        System.out.println(<span class="string">&quot;SALT.charAt(6)-&gt;&quot;</span> + SALT.charAt(<span class="number">6</span>));<span class="comment">//T</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> SALT.charAt(<span class="number">0</span>) + inputPass + SALT.charAt(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">return</span> md5(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加密加盐, 完成的任务就是把(MidPass +salt2) 转成DB中的密码</span></span><br><span class="line">    <span class="comment">// md5(md5(password明文+salt1)+salt2)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">midPassToDBPass</span><span class="params">(String midPass, String salt)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;salt.charAt(1)-&gt;&quot;</span> + salt.charAt(<span class="number">1</span>));<span class="comment">//L</span></span><br><span class="line">        System.out.println(<span class="string">&quot;salt.charAt(5)-&gt;&quot;</span> + salt.charAt(<span class="number">5</span>));<span class="comment">//m</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> salt.charAt(<span class="number">1</span>) + midPass + salt.charAt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> md5(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，可以将password明文，直接转成DB中的密码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">inputPassToDBPass</span><span class="params">(String inputPass, String salt)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">midPass</span> <span class="operator">=</span> inputPassToMidPass(inputPass);</span><br><span class="line">        <span class="type">String</span> <span class="variable">dbPass</span> <span class="operator">=</span> midPassToDBPass(midPass, salt);</span><br><span class="line">        <span class="keyword">return</span> dbPass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>登录信息、秒杀商品信息设计</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LoginVo: 接收用户登录时，发送的信息(mobile,password)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginVo</span> &#123;</span><br><span class="line">    <span class="comment">//对LoginVo的属性值进行，约束</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@IsMobile</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length(min = 32)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GoodsVo: 对应就是显示再秒杀商品列表的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsVo</span> <span class="keyword">extends</span> <span class="title class_">Goods</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal seckillPrice;<span class="comment">//秒杀价格</span></span><br><span class="line">    <span class="keyword">private</span> Integer stockCount;<span class="comment">//秒杀商品库存</span></span><br><span class="line">    <span class="keyword">private</span> Date startDate;<span class="comment">//秒杀开始时间</span></span><br><span class="line">    <span class="keyword">private</span> Date endDate;<span class="comment">//秒杀结束时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>请求返回信息设计</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RespBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> code;<span class="comment">//状态码</span></span><br><span class="line">    <span class="keyword">private</span> String message;  <span class="comment">//返回的信息</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;  <span class="comment">//返回的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功后-同时携带数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title function_">success</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RespBean</span>(RespBeanEnum.SUCCESS.getCode(), RespBeanEnum.SUCCESS.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功后-不携带数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RespBean</span>(RespBeanEnum.SUCCESS.getCode(), RespBeanEnum.SUCCESS.getMessage(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//失败各有不同-返回失败信息时，不携带数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title function_">error</span><span class="params">(RespBeanEnum respBeanEnum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RespBean</span>(respBeanEnum.getCode(), respBeanEnum.getMessage(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//失败各有不同-返回失败信息时，同时携带数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RespBean <span class="title function_">error</span><span class="params">(RespBeanEnum respBeanEnum, Object data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RespBean</span>(respBeanEnum.getCode(), respBeanEnum.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RespBeanEnum: 枚举类如何开发，java基础讲过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RespBeanEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通用</span></span><br><span class="line">    SUCCESS(<span class="number">200</span>,<span class="string">&quot;SUCCESS&quot;</span>),</span><br><span class="line">    ERROR(<span class="number">500</span>,<span class="string">&quot;服务端异常&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//登录</span></span><br><span class="line">    LOGIN_ERROR(<span class="number">500210</span>,<span class="string">&quot;用户id或者密码错误&quot;</span>),</span><br><span class="line">    BING_ERROR(<span class="number">500212</span>,<span class="string">&quot;参数绑定异常~&quot;</span>),</span><br><span class="line">    MOBILE_ERROR(<span class="number">500211</span>, <span class="string">&quot;手机号码格式不正确&quot;</span>),</span><br><span class="line">    MOBILE_NOT_EXIST(<span class="number">500213</span>,<span class="string">&quot;手机号码不存在&quot;</span>),</span><br><span class="line">    PASSWROD_UPDATE_FAIL(<span class="number">500214</span>,<span class="string">&quot;密码更新失败&quot;</span>),</span><br><span class="line">    <span class="comment">//其它我们在开发过程中，灵活增加即可</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀模块-返回的信息</span></span><br><span class="line">    ENTRY_STOCK(<span class="number">500500</span>,<span class="string">&quot;库存不足&quot;</span>),</span><br><span class="line">    REPEAT_ERROR(<span class="number">500501</span>,<span class="string">&quot;该商品每人限购一件&quot;</span>),</span><br><span class="line">    REQUEST_ILLEGAL(<span class="number">500502</span>,<span class="string">&quot;请求非法&quot;</span>),</span><br><span class="line">    SESSION_ERROR(<span class="number">500503</span>,<span class="string">&quot;用户信息有误..&quot;</span>),</span><br><span class="line">    SEK_KILL_WAIT(<span class="number">500504</span>,<span class="string">&quot;排队中...&quot;</span>),</span><br><span class="line">    CAPTCHA_ERROR(<span class="number">500505</span>,<span class="string">&quot;验证码错误...&quot;</span>),</span><br><span class="line">    ACCESS_LIMIT_REACHED(<span class="number">500506</span>,<span class="string">&quot;访问频繁,请待会再试...&quot;</span>),</span><br><span class="line">    SEC_KILL_RETRY(<span class="number">500507</span>,<span class="string">&quot;本次抢购失败,请继续抢购..&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>手机号码格式校验</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ValidatorUtil: 完成一些校验工作,比如手机号码格式是否正确..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class ValidatorUtil &#123;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>校验手机号码的正则表达式</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="number">13300000000</span> 合格</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="number">11000000000</span> 不合格</span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Pattern</span> mobile_pattern <span class="operator">=</span> Pattern.compile(&quot;^[1][3-9][0-9]&#123;9&#125;$&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>编写方法, 如果满足规则，返回T, 否则返回F</span><br><span class="line">    public <span class="keyword">static</span> <span class="type">boolean</span> isMobile(String mobile) &#123;</span><br><span class="line">        if(<span class="operator">!</span>StringUtils.hasText(mobile)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>进行正则表达式校验<span class="operator">-</span>java基础讲过</span><br><span class="line">        Matcher matcher <span class="operator">=</span> mobile_pattern.matcher(mobile);</span><br><span class="line">        <span class="keyword">return</span> matcher.matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="自定义校验注解"><a href="#自定义校验注解" class="headerlink" title="自定义校验注解"></a>自定义校验注解</h4><p>具体实现</p><h4 id="记录登录用户Session"><a href="#记录登录用户Session" class="headerlink" title="记录登录用户Session"></a>记录登录用户Session</h4><p>有一个CookieUtil，便于操作Cookie，直接拿来使用就行<br><strong>doLogin</strong></p><ul><li>在 UserServiceImpl  中根据 LoginVo 到数据库中查</li><li>查到后用 java.util.UUID 工具类生成票据 Ticket 用来区分 user，存入session中request.getSession().setAttribute**(ticket, user)**;</li><li>将票据存放到Cookie中 <strong>（”userTicket”, ticket）</strong></li></ul><p><strong>获取商品列表</strong></p><ul><li>有了 Cookie 和 Session 就可以在获取商品列表时进行判断了</li><li>先通过判断请求是否有userTicket，没有则返回登录</li><li>有则从Session中通过ticket（这个ticket就是userTicket）获取user</li><li>将user放入到Model传给下一个页面使用（user中包含了user的所有信息）</li></ul><h3 id="分布式Session共享"><a href="#分布式Session共享" class="headerlink" title="分布式Session共享"></a>分布式Session共享</h3><p><strong>需求说明</strong><br>Nginx对请求负载均衡到不同的Tomcat，当第二次请求到不同的Tomcat时，Tomcat会认为该用户是第一次购买，就会出现重复购买的问题。所以要进行Session共享。<br><strong>解决方案：</strong></p><ul><li>Session绑定&#x2F;粘滞</li><li>Session复制</li><li>前端存储</li><li>后端集中存储</li></ul><h4 id="SpringSession-实现分布式-Session"><a href="#SpringSession-实现分布式-Session" class="headerlink" title="SpringSession 实现分布式 Session"></a>SpringSession 实现分布式 Session</h4><p> <strong>描述：</strong>将用户 Session 不再存放到各自登录的 Tomcat 服务器，而是统一存在Redis  </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring data redis 依赖, 即 spring 整合 redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--pool2 对象池依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--实现分布式 session, 即将 Session 保存到指定的 Redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.200</span><span class="number">.130</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10000ms</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span>  <span class="comment">#最大连接数，默认是8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">10000ms</span> <span class="comment">#最大连接等待时间，默认是-1 一直等待</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">200</span>  <span class="comment">#最大空闲连接，高并发的情况下会来回切换连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">5</span>  <span class="comment">#最小空闲连接数，默认是0</span></span><br></pre></td></tr></table></figure><p>将user保存到session中改为保存到redis中： </p><ul><li>配置完后执行这句话 request.getSession().setAttribute(ticket, user); 就把session保存到redis中了</li><li>是以<strong>原始的形式</strong>保存的（保存的有session过期时间，最后访问时间等）</li></ul><h4 id="直接将用户信息统一放到Redis"><a href="#直接将用户信息统一放到Redis" class="headerlink" title="直接将用户信息统一放到Redis"></a>直接将用户信息统一放到Redis</h4><p>**描述： **前面将 Session 统一存放指定 Redis, 是以原生的形式存放, 在操作时, 还需要反序列化，不方便，我们可以直接将登录用户信息统一存放到 Redis, 利于操作<br>注销掉上面引入的spring-session-data-redis</p><ul><li><strong>使用 redisTemplate.opsForValue().set(“user:” + ticket, user);</strong></li><li>在Redis中key是 user: ticket 的格式</li><li>实现根据userTicket票据的Cookie 到 Redis中获取 user对象</li><li>刷新Cookie重新计算userTicket的过期时间</li></ul><p>GoodController中的toList方法改为直接从redis中获取user，然后放到Model中供下面使用</p><h4 id="WebMvcConfiger优化登录"><a href="#WebMvcConfiger优化登录" class="headerlink" title="WebMvcConfiger优化登录"></a>WebMvcConfiger优化登录</h4><h2 id="秒杀基本功能开发"><a href="#秒杀基本功能开发" class="headerlink" title="秒杀基本功能开发"></a>秒杀基本功能开发</h2><h3 id="商品列表"><a href="#商品列表" class="headerlink" title="商品列表"></a>商品列表</h3><p><strong>需求说明</strong><br>登录成功后可以看到商品列表<br><strong>表结构设计</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_goods` (</span><br><span class="line">`id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;商品 id&#x27;</span>, </span><br><span class="line">`goods_name` <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">`goods_title` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;商品标题&#x27;</span>, </span><br><span class="line">`goods_img` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;商品图片&#x27;</span>, </span><br><span class="line">`goods_detail` LONGTEXT <span class="keyword">not</span> <span class="keyword">null</span> COMMENT <span class="string">&#x27;商品详情&#x27;</span>,</span><br><span class="line">`goods_price` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0.00&#x27;</span> COMMENT <span class="string">&#x27;商品价格&#x27;</span>, </span><br><span class="line">`goods_stock` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;商品库存&#x27;</span>, </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>重点是id、库存</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_seckill_goods` (</span><br><span class="line">`id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">`goods_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">`seckill_price` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0.00&#x27;</span>, </span><br><span class="line">`stock_count` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">`start_date` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">`end_date` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>goods_id就是 t_goods 的主键<br><strong>设计GoodsVo</strong>，继承了Goods</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsVo</span> <span class="keyword">extends</span> <span class="title class_">Goods</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal seckillPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer stockCount;</span><br><span class="line">    <span class="keyword">private</span> Date startDate;</span><br><span class="line">    <span class="keyword">private</span> Date endDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询GoodsVo商品逻辑</strong><br><strong>把从Redis中查询到的user放model中后，再把从数据库中查出的商品放到model中</strong><br>model.addAttribute(“goodsList”, goodsService.findGoodsVo());</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findGoodsVo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hspedu.seckill.vo.GoodsVo&quot;</span>&gt;</span></span><br><span class="line">    SELECT g.id,</span><br><span class="line">           g.goods_name,</span><br><span class="line">           g.goods_title,</span><br><span class="line">           g.goods_img,</span><br><span class="line">           g.goods_detail,</span><br><span class="line">           g.goods_price,</span><br><span class="line">           g.goods_stock,</span><br><span class="line">           sg.seckill_price,</span><br><span class="line">           sg.stock_count,</span><br><span class="line">           sg.start_date,</span><br><span class="line">           sg.end_date</span><br><span class="line">    FROM t_goods g</span><br><span class="line">    LEFT JOIN t_seckill_goods sg</span><br><span class="line">    ON g.id = sg.goods_id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>商品表左连接秒杀商品表</p><h3 id="商品详情页"><a href="#商品详情页" class="headerlink" title="商品详情页"></a>商品详情页</h3><p><strong>需求说明</strong><br>在商品列表中点击查看详情会看到秒杀商品详情页<br><strong>实现逻辑</strong><br>在GoodsMapper中增加通过商品id获取GoodVo</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findGoodsVoByGoodsId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hspedu.seckill.vo.GoodsVo&quot;</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        g.id,</span><br><span class="line">        g.goods_name,</span><br><span class="line">        g.goods_title,</span><br><span class="line">        g.goods_img,</span><br><span class="line">        g.goods_detail,</span><br><span class="line">        g.goods_price,</span><br><span class="line">        g.goods_stock,</span><br><span class="line">        sg.seckill_price,</span><br><span class="line">        sg.stock_count,</span><br><span class="line">        sg.start_date,</span><br><span class="line">        sg.end_date</span><br><span class="line">    FROM t_goods g</span><br><span class="line">    LEFT JOIN t_seckill_goods sg</span><br><span class="line">    ON g.id = sg.goods_id</span><br><span class="line">    WHERE g.id=#&#123;goodsId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接入前端，根据秒杀开始时间和结束时间，在前端秒杀商品详情页有不同的显示：</p><ul><li>秒杀倒计时</li><li>秒杀进行中</li><li>秒杀结束</li></ul><h3 id="秒杀基本实现"><a href="#秒杀基本实现" class="headerlink" title="秒杀基本实现"></a>秒杀基本实现</h3><p><strong>需求说明</strong></p><ul><li>点击进行秒杀，更新库存，保存普通订单，秒杀订单</li><li>秒杀完成后进入秒杀订单页</li><li>只是最基本的功能，高并发下存在超卖的问题</li></ul><h4 id="功能1-秒杀倒计时"><a href="#功能1-秒杀倒计时" class="headerlink" title="功能1-秒杀倒计时"></a>功能1-秒杀倒计时</h4><p>在GoodsController的 toDetail 加入<br>根据查到的GoodVo的开始结束时间来鉴定秒杀状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回秒杀商品详情的同时返回该商品秒杀的状态和秒杀剩余的时间</span></span><br><span class="line"><span class="comment">//为了配合前端展示秒杀商品的状态 - 这里依然有一个业务设计</span></span><br><span class="line"><span class="comment">//1. 变量 secKillStatus 秒杀状态 0:秒杀未开始 1: 秒杀进行中 2: 秒杀已经结束</span></span><br><span class="line"><span class="comment">//2. 变量 remainSeconds 剩余秒数: &gt;0: 表示还有多久开始秒杀: 0: 秒杀进行中 -1: 表示秒杀已经结束</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">startDate</span> <span class="operator">=</span> goodsVo.getStartDate();</span><br><span class="line"><span class="type">Date</span> <span class="variable">endDate</span> <span class="operator">=</span> goodsVo.getEndDate();</span><br><span class="line"><span class="type">Date</span> <span class="variable">nowDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">//秒杀状态</span></span><br><span class="line"><span class="type">int</span> <span class="variable">secKillStatus</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//秒杀距离开始的剩余时间（单位是秒）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">remainSeconds</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nowDate.before(startDate)) &#123;</span><br><span class="line">    secKillStatus = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//得到还有多少秒开始秒杀</span></span><br><span class="line">    remainSeconds = (<span class="type">int</span>) ((startDate.getTime() - nowDate.getTime()) / <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nowDate.after(endDate)) &#123;</span><br><span class="line">    secKillStatus = <span class="number">2</span>;</span><br><span class="line">    remainSeconds = -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    secKillStatus = <span class="number">1</span>;</span><br><span class="line">    remainSeconds = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将secKillStatus 和 remainSeconds放入到model ,携带给模板页使用</span></span><br><span class="line">model.addAttribute(<span class="string">&quot;secKillStatus&quot;</span>, secKillStatus);</span><br><span class="line">model.addAttribute(<span class="string">&quot;remainSeconds&quot;</span>, remainSeconds);</span><br></pre></td></tr></table></figure><h4 id="功能2-秒杀按钮"><a href="#功能2-秒杀按钮" class="headerlink" title="功能2-秒杀按钮"></a>功能2-秒杀按钮</h4><p>前端实现的，就是按钮不到秒杀期间不能点</p><h4 id="功能3-点击按钮可以秒杀"><a href="#功能3-点击按钮可以秒杀" class="headerlink" title="功能3-点击按钮可以秒杀"></a>功能3-点击按钮可以秒杀</h4><p>秒杀成功后秒杀按钮变为立即支付，<strong>重复秒杀</strong>，<strong>库存不足</strong>都会秒杀失败（判断复购，库存）<br><strong>表设计</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_order` (</span><br><span class="line">`id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">`user_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">`goods_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">`delivery_addr_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">`goods_name` <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">`goods_count` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">`goods_price` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0.00&#x27;</span>, </span><br><span class="line">`order_channel` TINYINT(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;订单渠道1pc，2Android，3ios&#x27;</span>, </span><br><span class="line">`status` TINYINT(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;订单状态：0 新建未支付1已支付2 已发货 3 已收货 4 已退款 5 已完成&#x27;</span>,</span><br><span class="line">`create_date` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, `pay_date` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">600</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_seckill_order` (</span><br><span class="line">`id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">`user_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">`order_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">`goods_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY `seckill_uid_gid` (`user_id`,`goods_id`) <span class="keyword">USING</span> BTREE COMMENT <span class="string">&#x27; 用户id，商品 id 的唯一索引，解决同一个用户多次抢购&#x27;</span> ) </span><br><span class="line">ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">300</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p><strong>秒杀逻辑</strong><br> <strong>用户id，商品 id 的唯一索引，解决同一个用户多次抢购’  **<br>SeckillController 中的 doSeckill 方法</strong>版本1**：</p><ul><li><p>由商品列表页带来的user，供后面保存订单来使用</p></li><li><p>根据商品id直接从数据库中取出商品，看商品库存是否大于0</p></li><li><p>根据商品id和userId到数据库秒杀商品表中查询，进而判断该用户是否已经秒杀了该商品</p></li><li><p>通过了上面两个判断之后进入**orderService.seckill(user, goodsVo)**秒杀商品，生成订单</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理用户抢购请求/秒杀</span></span><br><span class="line"><span class="comment">//说明：我们先完成一个V1.0版本，后面在高并发的情况下, 还要做优化</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/doSeckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doSeckill</span><span class="params">(Model model, User user, Long goodsId)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------秒杀V1.0 开始-------&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;<span class="comment">//用户没有登录</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将user放入到model, 下一个模板可以使用</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="comment">//获取到goodsVo</span></span><br><span class="line">    <span class="type">GoodsVo</span> <span class="variable">goodsVo</span> <span class="operator">=</span> goodsService.findGoodsVoByGoodsId(goodsId);</span><br><span class="line">    <span class="comment">//判断库存</span></span><br><span class="line">    <span class="keyword">if</span> (goodsVo.getStockCount() &lt; <span class="number">1</span>) &#123;<span class="comment">//没有库存</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断用户是否复购-判断当前购买用户id和购买商品id是否已经在 商品秒杀表存在了</span></span><br><span class="line">    <span class="type">SeckillOrder</span> <span class="variable">seckillOrder</span> <span class="operator">=</span> seckillOrderService.getOne(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;SeckillOrder&gt;().eq(<span class="string">&quot;user_id&quot;</span>, user.getId())</span><br><span class="line">                    .eq(<span class="string">&quot;goods_id&quot;</span>, goodsId));</span><br><span class="line">    <span class="keyword">if</span> (seckillOrder != <span class="literal">null</span>) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.REPEAT_ERROR.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抢购</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.seckill(user, goodsVo);</span><br><span class="line">    <span class="keyword">if</span> (order == <span class="literal">null</span>) &#123; <span class="comment">//有可能执行过程中出错</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入到订单页</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;order&quot;</span>, order);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;goods&quot;</span>, goodsVo);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------秒杀V1.0 结束-------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;orderDetail&quot;</span>; <span class="comment">//进入订单详情页</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<strong>seckill</strong>方法是用来更新库存，保存普通订单，商品订单的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">seckill</span><span class="params">(User user, GoodsVo goodsVo)</span> &#123;</span><br><span class="line">    <span class="comment">//认为能进到这个代码中就是可以秒杀</span></span><br><span class="line">    <span class="comment">//查询秒杀商品的库存,并-1</span></span><br><span class="line">    <span class="type">SeckillGoods</span> <span class="variable">seckillGoods</span> <span class="operator">=</span> seckillGoodsService.</span><br><span class="line">            getOne(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;SeckillGoods&gt;().eq(<span class="string">&quot;goods_id&quot;</span>, goodsVo.getId()));</span><br><span class="line">    <span class="comment">//完成一个基本的秒杀操作[这块不具原子性],后面在高并发的情况下,还会优化, 不用急</span></span><br><span class="line">    seckillGoods.setStockCount(seckillGoods.getStockCount() - <span class="number">1</span>);</span><br><span class="line">    seckillGoodsService.updateById(seckillGoods);</span><br></pre></td></tr></table></figure><p><strong>版本1的问题</strong></p></li><li><p>从数据库拿出秒杀商品，减库存后更新到数据库，<strong>这两步操作不具备原子性</strong></p></li><li><p>查用户，查秒杀订单判断是否复购<strong>都是从数据库中查的</strong></p></li></ul><h2 id="秒杀压测Jmeter"><a href="#秒杀压测Jmeter" class="headerlink" title="秒杀压测Jmeter"></a>秒杀压测Jmeter</h2><h3 id="多用户测试"><a href="#多用户测试" class="headerlink" title="多用户测试"></a>多用户测试</h3><p><strong>测试方法</strong><br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/seckill/img1.png" alt="image.png"><br><strong>生成多用户测试脚本</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserUtil: 生成多用户测试脚本</span></span><br><span class="line"><span class="comment"> * 1. 创建多个用户,保存到seckill_user表</span></span><br><span class="line"><span class="comment"> * 2. 模拟http请求,生成jmeter压测的脚本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//生成多用户工具类</span></span><br><span class="line"><span class="comment">//创建用户，并且去登录得到userticket，得到的userTicket写入到config.txt文件内</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(<span class="type">int</span> count)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(count);</span><br><span class="line">        <span class="comment">//count表示你要创建的用户个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setId(<span class="number">13300000100L</span> + i);</span><br><span class="line">            user.setNickname(<span class="string">&quot;user&quot;</span> + i);</span><br><span class="line">            <span class="comment">//小伙伴也可以生成不同的盐,这里老师就是有一个</span></span><br><span class="line">            user.setSlat(<span class="string">&quot;ptqtXy16&quot;</span>);<span class="comment">//用户数据表的slat,由程序员设置</span></span><br><span class="line">            <span class="comment">//?是用户原始密码,比如12345 , hello等</span></span><br><span class="line">            <span class="comment">//小伙伴也可以生成不同的密码</span></span><br><span class="line">            user.setPassword(MD5Util.inputPassToDBPass(<span class="string">&quot;12345&quot;</span>, user.getSlat()));</span><br><span class="line">            users.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;create user&quot;</span>);</span><br><span class="line">        <span class="comment">//将插入数据库-seckill_user</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> getConn();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into seckill_user(nickname,slat,password,id) values(?,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; users.size(); i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> users.get(i);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, user.getNickname());</span><br><span class="line">            preparedStatement.setString(<span class="number">2</span>, user.getSlat());</span><br><span class="line">            preparedStatement.setString(<span class="number">3</span>, user.getPassword());</span><br><span class="line">            preparedStatement.setLong(<span class="number">4</span>, user.getId());</span><br><span class="line">            preparedStatement.addBatch();</span><br><span class="line">        &#125;</span><br><span class="line">        preparedStatement.executeBatch();</span><br><span class="line">        preparedStatement.clearParameters();<span class="comment">//关闭</span></span><br><span class="line">        connection.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;insert to do&quot;</span>);</span><br><span class="line">        <span class="comment">//模拟登录,发出登录拿到userTicket</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">urlStr</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8080/login/doLogin&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aHspJava\\projects\\iSecKill\\tool\\temp\\config.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        raf.seek(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; users.size(); i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> users.get(i);</span><br><span class="line">            <span class="comment">//请求</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(urlStr);</span><br><span class="line">            <span class="comment">//使用HttpURLConnection 发出http请求</span></span><br><span class="line">            <span class="type">HttpURLConnection</span> <span class="variable">co</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">            co.setRequestMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">            <span class="comment">//设置输入网页密码（相当于输出到页面）</span></span><br><span class="line">            co.setDoOutput(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> co.getOutputStream();</span><br><span class="line">            <span class="type">String</span> <span class="variable">params</span> <span class="operator">=</span> <span class="string">&quot;mobile=&quot;</span> + user.getId() + <span class="string">&quot;&amp;password=&quot;</span> + MD5Util.inputPassToMidPass(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">            outputStream.write(params.getBytes());</span><br><span class="line">            outputStream.flush();</span><br><span class="line">            <span class="comment">//获取网页输出，（得到输入流，把结果得到，再输出到ByteArrayOutputStream内）</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> co.getInputStream();</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                bout.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            inputStream.close();</span><br><span class="line">            bout.close();</span><br><span class="line">            <span class="comment">//把ByteArrayOutputStream内的东西转换为respBean对象</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bout.toByteArray());</span><br><span class="line">            <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">            <span class="type">RespBean</span> <span class="variable">respBean</span> <span class="operator">=</span> mapper.readValue(response, RespBean.class);</span><br><span class="line">            <span class="comment">//得到userTicket</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">userTicket</span> <span class="operator">=</span> (String) respBean.getObj();</span><br><span class="line">            System.out.println(<span class="string">&quot;create userTicket&quot;</span> + userTicket);</span><br><span class="line">            <span class="type">String</span> <span class="variable">row</span> <span class="operator">=</span> user.getId() + <span class="string">&quot;,&quot;</span> + userTicket;</span><br><span class="line">            <span class="comment">//写入指定文件</span></span><br><span class="line">            raf.seek(raf.length());</span><br><span class="line">            raf.write(row.getBytes());</span><br><span class="line">            raf.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;write to file:&quot;</span> + user.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        raf.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">getConn</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/seckill?useSSL=false&amp;useUnicode=false&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;19419&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        create(<span class="number">2000</span>);<span class="comment">//这里创建了2000个用户.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用Jmeter模拟多用户并发请求，发现出现超卖–后续解决</strong></p><h2 id="页面优化"><a href="#页面优化" class="headerlink" title="页面优化"></a>页面优化</h2><h3 id="redis页面缓存"><a href="#redis页面缓存" class="headerlink" title="redis页面缓存"></a>redis页面缓存</h3><p><strong>需求说明</strong></p><ul><li><a href="#xHjJs">在2.1 2.2中</a>， 多用户在查看<strong>商品列表</strong>和<strong>商品详情页</strong>的时候, 每一个用户都需要到DB 查询  </li><li>对 DB 查询的压力很大  </li><li>但是我们商品信息并不会频繁的变化, 所以你查询回来的结果都是一样的  </li><li>我们可以通过 Redis 缓存页面来进行优化, 这样可以将 1 分钟内多次查询DB, 优化成1次查询, 减少 DB 压力</li></ul><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/seckill/img2.png"><br><strong>WebContext就是上下文内容，当作一个常规的用法，知道怎么去使用就行</strong><br>设置过期时间60s</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入到商品列表单-改进的到redis中查询</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/toList&quot;, produces = &quot;text/html;charset=utf-8&quot;)</span> <span class="comment">//返回的编码</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toList</span><span class="params">(Model model, User user, HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果redis中有就直接返回，没有的话再继续往下走</span></span><br><span class="line">        <span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line">        <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> (String) valueOperations.get(<span class="string">&quot;goodsList&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(html))&#123;</span><br><span class="line">            <span class="keyword">return</span> html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将user放入到model，给下一个模板使用</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="comment">//将商品列表信息,放入到model,携带该下一个模板使用</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;goodsList&quot;</span>, goodsService.findGoodsVo());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果从redis中没有获取到页面，就手动渲染然后存到redis中 WebContext就是上下文内容，当作一个常规的用法，知道怎么去使用就行</span></span><br><span class="line">        <span class="comment">//说白了就是把WebContext上下文获取到，并且把model传进去</span></span><br><span class="line">        <span class="type">WebContext</span> <span class="variable">webContext</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WebContext</span>(request, response, request.getServletContext(), request.getLocale(), model.asMap());</span><br><span class="line">        <span class="comment">//处理了一个模板页，取了个名称叫goodsList，内容是从webContext中来的</span></span><br><span class="line">        <span class="comment">//上面没从redis中拿到html，就从这里给html赋值</span></span><br><span class="line">        <span class="comment">//goodsList来自templates中的goodsList.html，之前是走流程渲染的，现在是手动渲染到goodsList.html页面</span></span><br><span class="line">        html = thymeleafViewResolver.getTemplateEngine().process(<span class="string">&quot;goodsList&quot;</span>, webContext);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(html))&#123;  <span class="comment">//有内容说明渲染成功</span></span><br><span class="line">            <span class="comment">//将页面保存到redis，设置没60秒更新一次，该页面60秒失效，redis会清除这个页面，因为期间页面可能会变化</span></span><br><span class="line">            <span class="comment">//这个goodsList代表在redis中缓存的时候给key取得名称</span></span><br><span class="line">            valueOperations.set(<span class="string">&quot;goodsList&quot;</span>, html, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> html;</span><br><span class="line"><span class="comment">//        return &quot;goodsList&quot;;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入商品详情页-根据goodsId</span></span><br><span class="line"><span class="comment">//user是从自定义参数解析器完成带来的</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/toDetail/&#123;goodsId&#125;&quot;, produces = &quot;text/html;charset=utf-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toDetail</span><span class="params">(Model model, User user, <span class="meta">@PathVariable(&quot;goodsId&quot;)</span> Long goodsId,</span></span><br><span class="line"><span class="params">                       HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果redis中有就直接返回，没有的话再继续往下走</span></span><br><span class="line">    <span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line">    <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> (String) valueOperations.get(<span class="string">&quot;goodsDetail:&quot;</span> + goodsId);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.hasText(html))&#123;</span><br><span class="line">        <span class="keyword">return</span> html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放到model中，带给前端页面会用</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="type">GoodsVo</span> <span class="variable">goodsVo</span> <span class="operator">=</span> goodsService.findGoodsVoByGoodsId(goodsId);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;goods&quot;</span>, goodsVo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回秒杀商品详情的同时返回该商品秒杀的状态和秒杀剩余的时间</span></span><br><span class="line">    <span class="comment">//为了配合前端展示秒杀商品的状态 - 这里依然有一个业务设计</span></span><br><span class="line">    <span class="comment">//1. 变量 secKillStatus 秒杀状态 0:秒杀未开始 1: 秒杀进行中 2: 秒杀已经结束</span></span><br><span class="line">    <span class="comment">//2. 变量 remainSeconds 剩余秒数: &gt;0: 表示还有多久开始秒杀: 0: 秒杀进行中 -1: 表示秒杀已经结束</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">startDate</span> <span class="operator">=</span> goodsVo.getStartDate();</span><br><span class="line">    <span class="type">Date</span> <span class="variable">endDate</span> <span class="operator">=</span> goodsVo.getEndDate();</span><br><span class="line">    <span class="type">Date</span> <span class="variable">nowDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//秒杀状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">secKillStatus</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//秒杀距离开始的剩余时间（单位是秒）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainSeconds</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nowDate.before(startDate)) &#123;</span><br><span class="line">        secKillStatus = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//得到还有多少秒开始秒杀</span></span><br><span class="line">        remainSeconds = (<span class="type">int</span>) ((startDate.getTime() - nowDate.getTime()) / <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nowDate.after(endDate)) &#123;</span><br><span class="line">        secKillStatus = <span class="number">2</span>;</span><br><span class="line">        remainSeconds = -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        secKillStatus = <span class="number">1</span>;</span><br><span class="line">        remainSeconds = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将secKillStatus 和 remainSeconds放入到model ,携带给模板页使用</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;secKillStatus&quot;</span>, secKillStatus);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;remainSeconds&quot;</span>, remainSeconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果从redis中没有获取到页面，就手动渲染商品详情页然后存到redis中</span></span><br><span class="line">    <span class="comment">//说白了就是把WebContext上下文获取到，并且把model传进去</span></span><br><span class="line">    <span class="type">WebContext</span> <span class="variable">webContext</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">WebContext</span>(request, response, request.getServletContext(), request.getLocale(), model.asMap());</span><br><span class="line">    <span class="comment">//上面没从redis中拿到html，就从这里给html赋值</span></span><br><span class="line">    html = thymeleafViewResolver.getTemplateEngine().process(<span class="string">&quot;goodsDetail&quot;</span>, webContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.hasText(html))&#123;  <span class="comment">//有内容说明渲染成功</span></span><br><span class="line">        <span class="comment">//将页面保存到redis，设置没60秒更新一次，该页面60秒失效，redis会清除这个页面，因为期间页面可能会变化</span></span><br><span class="line">        <span class="comment">//这个goodsList代表在redis中缓存的时候给key取得名称</span></span><br><span class="line">        valueOperations.set(<span class="string">&quot;goodsDetail:&quot;</span> + goodsId, html, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象缓存"><a href="#对象缓存" class="headerlink" title="对象缓存"></a>对象缓存</h3><p><strong>需求说明</strong></p><ul><li><a href="#uRGjD">1.2.2</a>中当用户登录成功后, 就会将用户对象缓存到 Redis  </li><li>好处是解决了分布式架构下的 Session 共享问题  </li><li>但是也带来新问题, 如果用户信息改变, DB用户信息和Redis 缓存用户对象不一致问题-也就是对象缓存问题</li></ul><p><strong>解决思路</strong></p><ul><li>编写方法, 当用户信息变化时, 就更新用户在 DB 的信息, 同时删除该用户在Redis的缓存对象  </li><li>这样用户就需要使用新密码重新登录, 从而更新用户在 Redis 对应的缓存对象</li></ul><h2 id="复购和超卖"><a href="#复购和超卖" class="headerlink" title="复购和超卖"></a>复购和超卖</h2><h3 id="超卖"><a href="#超卖" class="headerlink" title="超卖"></a>超卖</h3><p><strong>需求说明</strong><br><a href="#fnMe4">解决2.3.3中</a>doSeckill 方法版本1的超卖问题<br><strong>出现超卖问题的原因</strong></p><ul><li>在SeckillController 中判断复购，库存之后就进入到OrderServiceImpl中的seckill方法进行秒杀</li><li>而在高并发下可能同时200个请求同时执行判断库存的语句，都通过了库存判断</li><li>然后都冲入到OrderServiceImpl中的seckill方法，而该方法中<strong>减库存的操作不具备原子性</strong></li><li>可能多个请求才减去1个商品，而冲到seckill中的请求都会生成订单</li></ul><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/seckill/img3.png" alt="image.png"><br><strong>解决思路</strong></p><ul><li>Mysql在默认的事务隔离级别（可重复读）下，执行update语句时,会在事务中锁定要更新的行</li><li>这可以防止其他会话在同一行上执行 <strong>UPDATE</strong> 或DELETE操作  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">seckill</span><span class="params">(User user, GoodsVo goodsVo)</span> &#123;</span><br><span class="line">    <span class="comment">//认为能进到这个代码中就是可以秒杀</span></span><br><span class="line">    <span class="comment">//查询秒杀商品的库存,并-1</span></span><br><span class="line">    <span class="type">SeckillGoods</span> <span class="variable">seckillGoods</span> <span class="operator">=</span> seckillGoodsService.</span><br><span class="line">            getOne(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;SeckillGoods&gt;().eq(<span class="string">&quot;goods_id&quot;</span>, goodsVo.getId()));</span><br><span class="line">    <span class="comment">//完成一个基本的秒杀操作[这块不具原子性],后面在高并发的情况下,还会优化, 不用急</span></span><br><span class="line"><span class="comment">//        seckillGoods.setStockCount(seckillGoods.getStockCount() - 1);</span></span><br><span class="line"><span class="comment">//        seckillGoodsService.updateById(seckillGoods);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. Mysql在默认的事务隔离级[REPEATABLE-READ]别下</span></span><br><span class="line">    <span class="comment">//2. 执行update语句时,会在事务中锁定要更新的行</span></span><br><span class="line">    <span class="comment">//3. 这样可以防止其它会话在同一行执行update,delete</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行update==&gt;&quot;</span> + user.getId());</span><br><span class="line">    <span class="comment">//只要在更新成功时,返回true,否则返回false, 即更新后，受影响的行数&gt;=1为T</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">update</span> <span class="operator">=</span> seckillGoodsService.update(<span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;SeckillGoods&gt;()</span><br><span class="line">            .setSql(<span class="string">&quot;stock_count=stock_count-1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;goods_id&quot;</span>, goodsVo.getId()).gt(<span class="string">&quot;stock_count&quot;</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!update) &#123;<span class="comment">//如果更新失败,说明已经没有库存了</span></span><br><span class="line">        <span class="comment">//把这个秒杀失败的信息-记录到Redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;seckillFail:&quot;</span> + user.getId() + <span class="string">&quot;:&quot;</span> + goodsVo.getId(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成普通订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    order.setUserId(user.getId());</span><br><span class="line">    order.setGoodsId(goodsVo.getId());</span><br><span class="line">    order.setDeliveryAddrId(<span class="number">0L</span>);<span class="comment">//老师就设置一个初始值</span></span><br><span class="line">    order.setGoodsName(goodsVo.getGoodsName());</span><br><span class="line">    order.setGoodsCount(<span class="number">1</span>);</span><br><span class="line">    order.setGoodsPrice(seckillGoods.getSeckillPrice());  <span class="comment">//秒杀的价格</span></span><br><span class="line">    order.setOrderChannel(<span class="number">1</span>);<span class="comment">//老师就设置一个初始值</span></span><br><span class="line">    order.setStatus(<span class="number">0</span>);<span class="comment">//老师就设置一个初始值-未支付</span></span><br><span class="line">    order.setCreateDate(<span class="keyword">new</span> <span class="title class_">Date</span>());<span class="comment">//设置成now</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存order</span></span><br><span class="line">    orderMapper.insert(order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成秒杀商品订单-</span></span><br><span class="line">    <span class="type">SeckillOrder</span> <span class="variable">seckillOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillOrder</span>();</span><br><span class="line">    seckillOrder.setGoodsId(goodsVo.getId());</span><br><span class="line">    <span class="comment">//这里秒杀商品订单对应的order_id 是从上面添加 order后获取到的</span></span><br><span class="line">    seckillOrder.setOrderId(order.getId());</span><br><span class="line">    seckillOrder.setUserId(user.getId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存seckillOrder 用mapper也行</span></span><br><span class="line">    seckillOrderService.save(seckillOrder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将生成的秒杀订单，存入到Redis, 这样在查询某个用户是否已经秒杀了这个商品时，</span></span><br><span class="line">    <span class="comment">//直接到Redis中查询，起到优化效果</span></span><br><span class="line">    <span class="comment">//设计秒杀订单的key =&gt; order:用户id:商品id</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;order:&quot;</span> + user.getId() + <span class="string">&quot;:&quot;</span> + goodsVo.getId(), seckillOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>使用update代替下面原来减库存的语句（Mybatis-plus）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeckillGoodsServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;SeckillGoodsMapper, SeckillGoods&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">SeckillGoodsService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">update</span> <span class="operator">=</span> seckillGoodsService.update(<span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;SeckillGoods&gt;()</span><br><span class="line">                .setSql(<span class="string">&quot;stock_count=stock_count-1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;goods_id&quot;</span>, goodsVo.getId()).gt(<span class="string">&quot;stock_count&quot;</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>这样减库存的操作就是串行执行的了，库存小于1会更新失败，也不会生成订单了<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!update) &#123;</span><br><span class="line">    <span class="comment">//如果更新失败,说明已经没有库存了，把这个秒杀失败的信息-记录到Redis</span></span><br><span class="line">    redisTemplate.opsForValue()</span><br><span class="line">    .set(<span class="string">&quot;seckillFail:&quot;</span> + user.getId() + <span class="string">&quot;:&quot;</span> + goodsVo.getId(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当然了，这样解决仍有大量的请求进入seckill然后到DB中执行sql，后面会优化</li></ul><h3 id="复购"><a href="#复购" class="headerlink" title="复购"></a>复购</h3><p><strong>需求说明</strong></p><ul><li><a href="#fnMe4">对版本1进行优化</a>，不去数据库看是否存在该用户对此商品的秒杀订单</li><li>而是把生成的订单放到redis中，后面直接从redis中判断是否复购</li><li>就是seckill最后生成秒杀订单后设置到redis中</li></ul><h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><h3 id="预减库存-Decrement"><a href="#预减库存-Decrement" class="headerlink" title="预减库存+Decrement"></a>预减库存+Decrement</h3><p><strong>目的就是减少去到数据库中的操作</strong><br><strong>需求说明</strong></p><ul><li><a href="#fnMe4">在2.3.3中</a>防止超卖，SeckillController 是直接到数据库查出商品的 goodsService.findGoodsVoByGoodsId(goodsId);    初步判断的库存，并发下不准确</li><li>大量的并发请求都去<strong>到数据库中尝试减库存的操作</strong>，虽然控制了超卖，但容易把数据库压垮</li></ul><p><strong>解决思路</strong></p><ul><li>使用 Redis 完成<strong>预减库存</strong>，如果没有库存了, 直接返回, 减小对DB的压力  </li><li><strong>如果预减库存后，库存小于0就不再去orderService.seckill()中了</strong></li><li><strong>结果就是库存有多少就进去几个请求</strong></li><li><strong>依赖decrement具有原子性</strong>，redisTemplate.opsForValue().<strong>decrement(“seckillGoods:” + goodsId);</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//库存预减, 如果在Redis中预减库存，发现秒杀商品已经没有了，就直接返回</span></span><br><span class="line"><span class="comment">//从而减少去执行 orderService.seckill() 请求,防止线程堆积, 优化秒杀/高并发</span></span><br><span class="line"><span class="comment">// decrement()是具有原子性!!</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">decrement</span> <span class="operator">=</span> redisTemplate.opsForValue().decrement(<span class="string">&quot;seckillGoods:&quot;</span> + goodsId);</span><br><span class="line"><span class="keyword">if</span> (decrement &lt; <span class="number">0</span>) &#123;<span class="comment">//说明这个商品已经没有库存</span></span><br><span class="line">    <span class="comment">//恢复库存为0</span></span><br><span class="line">    redisTemplate.opsForValue().increment(<span class="string">&quot;seckillGoods:&quot;</span> + goodsId);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>**前奏：SeckillController的初始化方法，从数据库查出所有的秒杀商品，然后存到redis中 seckillGoods : id **<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个方法是在类的所有属性，都初始化后，自动执行的</span></span><br><span class="line"><span class="comment">//这里把所有秒杀商品的库存量加载到redis</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//查询所有的秒杀商品</span></span><br><span class="line">    List&lt;GoodsVo&gt; list = goodsService.findGoodsVo();</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历List，然后将秒杀商品的库存量放入到redis</span></span><br><span class="line">    <span class="comment">//秒杀商品库存量对应key: seckillGoods:商品id</span></span><br><span class="line">    list.forEach(goodsVo -&gt; &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;seckillGoods:&quot;</span> + goodsVo.getId(), goodsVo.getStockCount());</span><br><span class="line">        <span class="comment">//初始化map</span></span><br><span class="line">        <span class="comment">//如果goodsId : false 表示有库存</span></span><br><span class="line">        <span class="comment">//如果goodsId : true 表示没有库存</span></span><br><span class="line">        entryStockMap.put(goodsVo.getId(), <span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="加入内存标记"><a href="#加入内存标记" class="headerlink" title="加入内存标记"></a>加入内存标记</h3><p><strong>目的就是减少到redis中预减库存</strong><br><strong>需求说明</strong></p><ul><li>如果某个商品库存已经为空了，我们仍然是到 Redis 去查询的，还可以进行优化  </li><li>给商品进行内存标记，如果库存为空，直接返回，避免总是到Redis 查询库存</li></ul><p><strong>解决思路</strong><br><strong>操作本机JVM快于操作Redis</strong><br><strong>添加属性    private HashMap&lt;Long, Boolean&gt; entryStockMap &#x3D; new HashMap&lt;&gt;();</strong></p><ul><li>在到redis中预减库存之前，先查看entryStockMap，如果标记为true，则表示redis中的库存已经为0</li><li>不再去redis中预减</li><li>如果是redis中库存<strong>第一次</strong>不足，预减后设置标记为true<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理用户抢购请求/秒杀</span></span><br><span class="line"><span class="comment">//说明：我们先完成一个V4.0版本，加入内存标记优化秒杀</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/doSeckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doSeckill</span><span class="params">(Model model, User user, Long goodsId)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------秒杀V4.0 开始-------&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    </span><br><span class="line">    <span class="type">GoodsVo</span> <span class="variable">goodsVo</span> <span class="operator">=</span> goodsService.findGoodsVoByGoodsId(goodsId);</span><br><span class="line">    <span class="comment">//判断库存</span></span><br><span class="line">    <span class="keyword">if</span> (goodsVo.getStockCount() &lt; <span class="number">1</span>) &#123;<span class="comment">//没有库存</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断用户是否复购</span></span><br><span class="line">    <span class="type">SeckillOrder</span> <span class="variable">seckillOrder</span> <span class="operator">=</span> (SeckillOrder) redisTemplate.opsForValue().get(<span class="string">&quot;order:&quot;</span> + user.getId() + <span class="string">&quot;:&quot;</span> + goodsId);</span><br><span class="line">    <span class="keyword">if</span> (seckillOrder != <span class="literal">null</span>) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.REPEAT_ERROR.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对map进行判断[内存标记],如果商品在map已经标记为没有库存，则直接返回，无需进行Redis预减</span></span><br><span class="line">    <span class="keyword">if</span> (entryStockMap.get(goodsId)) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//库存预减, 如果在Redis中预减库存，发现秒杀商品已经没有了，就直接返回</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">decrement</span> <span class="operator">=</span> redisTemplate.opsForValue().decrement(<span class="string">&quot;seckillGoods:&quot;</span> + goodsId);</span><br><span class="line">    <span class="keyword">if</span> (decrement &lt; <span class="number">0</span>) &#123;<span class="comment">//说明这个商品已经没有库存</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//就是在这设置了内存标记之后，相当于直接告诉后来的请求说已经没有库存了，不用再去redis中预减了。截断的效果</span></span><br><span class="line">        entryStockMap.put(goodsId, <span class="literal">true</span>);  <span class="comment">//定义的true是代表没有库存了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//恢复库存为0</span></span><br><span class="line">        redisTemplate.opsForValue().increment(<span class="string">&quot;seckillGoods:&quot;</span> + goodsId);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抢购</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.seckill(user, goodsVo);</span><br><span class="line">    <span class="keyword">if</span> (order == <span class="literal">null</span>) &#123; <span class="comment">//有可能执行过程中出错</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入到订单页</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;order&quot;</span>, order);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;goods&quot;</span>, goodsVo);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------秒杀V4.0 结束-------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;orderDetail&quot;</span>; <span class="comment">//进入订单详情页</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="加入消息队列，秒杀异步请求"><a href="#加入消息队列，秒杀异步请求" class="headerlink" title="加入消息队列，秒杀异步请求"></a>加入消息队列，秒杀异步请求</h3><p><strong>目的是把执行seckill交给消息队列，赶紧返回客户端消息，防止线程堆积</strong><br><strong>需求说明</strong></p><ul><li>前面秒杀, 没有实现异步机制, 是<strong>完成下订单后, 再返回</strong>的</li><li>当有大并发请求下订单操作时, 数据库来不及响应, 容易造成<strong>线程堆积</strong></li></ul><p><strong>解决思路</strong></p><ul><li>加入消息队列，实现秒杀的异步请求  </li><li>接收到客户端秒杀请求后，<strong>服务器立即返回 正在秒杀中..</strong>, 有利于流量削峰  </li><li>客户端进行轮询秒杀结果, 接收到秒杀结果后，在客户端页面显示即可</li></ul><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/seckill/img4.png" alt="秒杀加入消息队列逻辑"><br><strong>使用的是RabbotMQ的Topic主题模式</strong>（Direct路由模式下的一种扩展）<br>把秒杀操作seckill移到消息消费者，然后消费者执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SeckillMessage: 秒杀消息对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeckillMessage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="keyword">private</span> Long goodsId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>秒杀消息组成：</p><ul><li>用户 user</li><li>商品id goodsId<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RabbitMQSeckillConfig: 配置类，创建消息队列和交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQSeckillConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义消息队列名和交换机名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE</span> <span class="operator">=</span> <span class="string">&quot;seckillQueue&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;seckillExchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue_seckill</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建交换机-Topic</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TopicExchange <span class="title function_">topicExchange_seckill</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将队列绑定到交换机，并指定路由</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding_seckill</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue_seckill())</span><br><span class="line">        .to(topicExchange_seckill()).with(<span class="string">&quot;seckill.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MQSenderMessage: 消息的生产者/发送者[秒杀消息]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQSenderMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装配RabbitTemplate</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法：发送秒杀消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSeckillMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;发送消息--&gt;&quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;seckillExchange&quot;</span>, <span class="string">&quot;seckill.message&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>发送的是String<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MQReceiverMessage: 消息的接收者/消费者, 这里调用seckill方法()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQReceiverMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装配需要的组件/对象</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> GoodsService goodsService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息，并完成下单</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;seckillQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queue</span><span class="params">(String message)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;接收到的消息是--&gt;&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解读，这里我们从队列中取出的是string</span></span><br><span class="line">        <span class="comment">//但是我们需要的是SeckillMessage, 因此需要一个工具类JSONUtil</span></span><br><span class="line">        <span class="comment">//在hutool依赖</span></span><br><span class="line">        <span class="type">SeckillMessage</span> <span class="variable">seckillMessage</span> <span class="operator">=</span></span><br><span class="line">                JSONUtil.toBean(message, SeckillMessage.class);</span><br><span class="line">        <span class="comment">//秒杀用户对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> seckillMessage.getUser();</span><br><span class="line">        <span class="comment">//秒杀的商品id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">goodsId</span> <span class="operator">=</span> seckillMessage.getGoodsId();</span><br><span class="line">        <span class="comment">//通过商品id,得到对应的GoodsVo</span></span><br><span class="line">        <span class="type">GoodsVo</span> <span class="variable">goodsVo</span> <span class="operator">=</span> goodsService.findGoodsVoByGoodsId(goodsId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下单操作</span></span><br><span class="line">        orderService.seckill(user, goodsVo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>用工具类JSONUtil把String转为SeckillMessage<br>SeckillController 中抢购的代码变化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抢购</span></span><br><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.seckill(user, goodsVo);</span><br><span class="line"><span class="keyword">if</span> (order == <span class="literal">null</span>) &#123; <span class="comment">//有可能执行过程中出错</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, RespBeanEnum.ENTRY_STOCK.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;<span class="comment">//错误页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抢购,向消息队列发送秒杀请求,实现了秒杀异步请求</span></span><br><span class="line"><span class="comment">//这里我们发送秒杀消息后，立即快速返回结果[临时结果] - &quot;比如排队中..&quot;</span></span><br><span class="line"><span class="comment">//客户端可以通过轮询，获取到最终结果</span></span><br><span class="line"><span class="comment">//创建SeckillMessage</span></span><br><span class="line"><span class="type">SeckillMessage</span> <span class="variable">seckillMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillMessage</span>(user, goodsId);</span><br><span class="line">mqSenderMessage.sendSeckillMessage(JSONUtil.toJsonStr(seckillMessage));</span><br><span class="line">model.addAttribute(<span class="string">&quot;errmsg&quot;</span>, <span class="string">&quot;排队中...&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;secKillFail&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="秒杀安全"><a href="#秒杀安全" class="headerlink" title="秒杀安全"></a>秒杀安全</h2><h3 id="秒杀接口地址隐藏"><a href="#秒杀接口地址隐藏" class="headerlink" title="秒杀接口地址隐藏"></a>秒杀接口地址隐藏</h3><p><strong>需求说明</strong></p><ul><li>前面我们处理高并发, 是按照正常业务逻辑处理的, 也就是用户正常抢购  </li><li>还需要考虑抢购安全性, 当前程序, <strong>抢购接口是固定, 如果泄露, 会有安全隐患</strong>, 比如抢购未开始或者已结束, 还可以使用脚本发起抢购</li></ul><p><strong>解决思路</strong></p><ul><li>隐藏抢购接口  </li><li>用户抢购时, 先<strong>生成一个唯一的抢购路径, 返回给客户端</strong>  </li><li>客户端抢购时会携带生成的抢购路径, <strong>服务端做校验</strong>, 如果校验成功, 才走下一步, 否则直接返回</li></ul><p><strong>解决过程</strong><br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/seckill/img5.png" alt="image.png"><br><strong>OrderServiceImpl生成的秒杀路径放到redis中，便于后面到redis中校验</strong><br>set(“<strong>seckillPath:”+ user.getId() + “:” + goodsId</strong>，<strong>path</strong>, 60, TimeUnit.SECONDS);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法: 生成秒杀路径/值(唯一)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">createPath</span><span class="params">(User user, Long goodsId)</span> &#123;</span><br><span class="line">    <span class="comment">//生成秒杀路径/值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> MD5Util.md5(UUIDUtil.uuid());</span><br><span class="line">    <span class="comment">//将随机生成的路径保存到Redis, 设置一个超时时间60s</span></span><br><span class="line">    <span class="comment">//key的设计: seckillPath:userId:goodsId</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;seckillPath:&quot;</span>+ user.getId() + <span class="string">&quot;:&quot;</span> + goodsId,</span><br><span class="line">            path, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法: 对秒杀路径进行校验</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPath</span><span class="params">(User user, Long goodsId, String path)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || goodsId &lt; <span class="number">0</span> || !StringUtils.hasText(path)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出该用户秒杀该商品的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">redisPath</span> <span class="operator">=</span> (String) redisTemplate.opsForValue()</span><br><span class="line">                        .get(<span class="string">&quot;seckillPath:&quot;</span> + user.getId() + <span class="string">&quot;:&quot;</span> + goodsId);</span><br><span class="line">    <span class="keyword">return</span> path.equals(redisPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在OrderController中增加getPath，createPath后返回给客户端</strong><br>然后客户端带着新路径再次发出秒杀请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法：获取秒杀路径</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/path&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@AccessLimit(second = 5, maxCount = 5, needLogin = true)</span></span><br><span class="line"><span class="keyword">public</span> RespBean <span class="title function_">getPath</span><span class="params">(User user, Long goodsId, String captcha, HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || goodsId &lt; <span class="number">0</span> || !StringUtils.hasText(captcha)) &#123;</span><br><span class="line">        <span class="keyword">return</span> RespBean.error(RespBeanEnum.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> orderService.createPath(user, goodsId);</span><br><span class="line">    <span class="keyword">return</span> RespBean.success(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在SeckillController做地址校验，路径正确了再忘下一步走</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理用户抢购请求/秒杀</span></span><br><span class="line"><span class="comment">//说明：我们先完成一个V6.0版本，加入秒杀安全，直接返回RespBean，不再去下一个页面了</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&#123;path&#125;/doSeckill&quot;)</span>  <span class="comment">//每一个秒杀的路径都不一样</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> RespBean <span class="title function_">doSeckill</span><span class="params">(<span class="meta">@PathVariable</span> String path, Model model, User user, Long goodsId)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------秒杀V6.0 开始-------&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;<span class="comment">//用户没有登录</span></span><br><span class="line">        <span class="keyword">return</span> RespBean.error(RespBeanEnum.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里增加一个逻辑，校验用户携带的path是否正确</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">checkPath</span> <span class="operator">=</span> orderService.checkPath(user, goodsId, path);</span><br><span class="line">    <span class="keyword">if</span>(!checkPath)&#123;</span><br><span class="line">        <span class="keyword">return</span> RespBean.error(RespBeanEnum.REQUEST_ILLEGAL);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="验证码防止脚本攻击"><a href="#验证码防止脚本攻击" class="headerlink" title="验证码防止脚本攻击"></a>验证码防止脚本攻击</h3><p><strong>需求说明</strong></p><ul><li>在一些抢购活动中, 可以通过验证码的方式, 防止脚本攻击, 比如12306</li></ul><p><strong>解决思路</strong></p><ul><li>使用验证码 happyCaptcha  ![image.png.&#x2F;.&#x2F;duskimg&#x2F;seckill&#x2F;img6.png)</li></ul><p><strong>解决过程</strong><br><strong>在SeckillController中增加方法生成验证码，保存到reids，便于后面校验</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成验证码-happyCaptcha</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/captcha&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">happyCaptcha</span><span class="params">(HttpServletRequest request, HttpServletResponse response, User user, Long goodsId)</span> &#123;</span><br><span class="line">    <span class="comment">//生成验证码，并输出</span></span><br><span class="line">    <span class="comment">//注意，该验证码，默认就保存到session中, key是 happy-captcha</span></span><br><span class="line">    HappyCaptcha.require(request, response)</span><br><span class="line">            .style(CaptchaStyle.ANIM)               <span class="comment">//设置展现样式为动画</span></span><br><span class="line">            .type(CaptchaType.NUMBER)               <span class="comment">//设置验证码内容为数字</span></span><br><span class="line">            .length(<span class="number">6</span>)                              <span class="comment">//设置字符长度为6</span></span><br><span class="line">            .width(<span class="number">220</span>)                             <span class="comment">//设置动画宽度为220</span></span><br><span class="line">            .height(<span class="number">80</span>)                             <span class="comment">//设置动画高度为80</span></span><br><span class="line">            .font(Fonts.getInstance().zhFont())     <span class="comment">//设置汉字的字体</span></span><br><span class="line">            .build().finish();                      <span class="comment">//生成并输出验证码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//把验证码的值，保存Redis [考虑项目分布式], 设置了验证码的失效时间100s</span></span><br><span class="line">    <span class="comment">//key: captcha:userId:goodsId</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;captcha:&quot;</span> + user.getId() + <span class="string">&quot;:&quot;</span> + goodsId</span><br><span class="line">            , (String) request.getSession().getAttribute(<span class="string">&quot;happy-captcha&quot;</span>), <span class="number">100</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在OrderServiceImpl中增加校验验证码的方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法: 验证用户输入的验证码是否正确</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkCaptcha</span><span class="params">(User user, Long goodsId, String captcha)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || goodsId &lt; <span class="number">0</span> || !StringUtils.hasText(captcha)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从Redis取出验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">redisCaptcha</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;captcha:&quot;</span> + user.getId() + <span class="string">&quot;:&quot;</span> + goodsId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> captcha.equals(redisCaptcha);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="秒杀接口限流-防刷"><a href="#秒杀接口限流-防刷" class="headerlink" title="秒杀接口限流-防刷"></a>秒杀接口限流-防刷</h3><p><strong>需求说明</strong></p><ul><li>完成接口限流-防止某个用户频繁的请求秒杀接口  </li><li>比如在短时间内，频繁点击立即秒杀</li></ul><p><strong>解决思路</strong><br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/seckill/img7.png" alt="image.png"><br><strong>解决过程</strong></p><h4 id="简单接口限流"><a href="#简单接口限流" class="headerlink" title="简单接口限流"></a>简单接口限流</h4><ul><li>使用简单的 Redis 计数器, 完成接口限流防刷 </li><li>除了计数器算法，也有其它的算法来进行接口限流, 比如漏桶算法和令牌桶算法  </li><li>添加在获取路径代码之前<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加业务逻辑: 加入Redis计数器, 完成对用户的限流防刷</span></span><br><span class="line"><span class="comment">//比如:5秒内访问次数超过了5次, 我们就认为是刷接口</span></span><br><span class="line"><span class="comment">//这里先把代码写在方法中，后面我们使用注解提高使用的通用性</span></span><br><span class="line"><span class="comment">//uri就是 localhost:8080/seckill/path 的 /seckill/path</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line"><span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> uri + <span class="string">&quot;:&quot;</span> + user.getId();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> (Integer) valueOperations.get(key);</span><br><span class="line"><span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//说明还没有key,就初始化，值为1, 过期时间为5秒</span></span><br><span class="line">    valueOperations.set(key, <span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; <span class="number">5</span>) &#123;<span class="comment">//说明正常访问</span></span><br><span class="line">    valueOperations.increment(key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//说明用户在刷接口</span></span><br><span class="line">    <span class="keyword">return</span> RespBean.error(RespBeanEnum.ACCESS_LIMIT_REACHED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="通过接口限流"><a href="#通过接口限流" class="headerlink" title="通过接口限流"></a>通过接口限流</h4><ul><li>自定义注解@AccessLimit, 提高接口限流功能通用性 , 减少冗余代码, 同时也减少业务代码入侵</li></ul><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/seckill/img8.png" alt="image.png"><br>自定义注解@AccessLimit，时间范围，访问最大次数，是否登录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AccessLimit: 自定义的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AccessLimit &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">second</span><span class="params">()</span>;<span class="comment">//时间范围</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxCount</span><span class="params">()</span>;<span class="comment">//访问的最大次数</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">needLogin</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;<span class="comment">//是否登录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写到getPath方法里</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法：获取秒杀路径</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/path&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@AccessLimit</span>(second = 5,maxCount = 5,needLogin = true)</span></span><br><span class="line"><span class="comment"> * 1. 使用注解的方式完成对用户的限流防刷-通用性和灵活性提高</span></span><br><span class="line"><span class="comment"> * 2. second = 5,maxCount = 5 说明是在5秒内可以访问的最大次数是5次</span></span><br><span class="line"><span class="comment"> * 3. needLogin = true 表示用户是否需要登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AccessLimit(second = 5, maxCount = 5, needLogin = true)</span></span><br><span class="line"><span class="keyword">public</span> RespBean <span class="title function_">getPath</span><span class="params">(User user, Long goodsId, String captcha, HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || goodsId &lt; <span class="number">0</span> || !StringUtils.hasText(captcha)) &#123;</span><br><span class="line">        <span class="keyword">return</span> RespBean.error(RespBeanEnum.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //增加业务逻辑: 加入Redis计数器, 完成对用户的限流防刷</span></span><br><span class="line"><span class="comment">//        //比如:5秒内访问次数超过了5次, 我们就认为是刷接口</span></span><br><span class="line"><span class="comment">//        //这里先把代码写在方法中，后面我们使用注解提高使用的通用性</span></span><br><span class="line"><span class="comment">//        //uri就是 localhost:8080/seckill/path 的 /seckill/path</span></span><br><span class="line"><span class="comment">//        String uri = request.getRequestURI();</span></span><br><span class="line"><span class="comment">//        ValueOperations valueOperations = redisTemplate.opsForValue();</span></span><br><span class="line"><span class="comment">//        String key = uri + &quot;:&quot; + user.getId();</span></span><br><span class="line"><span class="comment">//        Integer count = (Integer) valueOperations.get(key);</span></span><br><span class="line"><span class="comment">//        if (count == null) &#123;//说明还没有key,就初始化，值为1, 过期时间为5秒</span></span><br><span class="line"><span class="comment">//            valueOperations.set(key, 1, 5, TimeUnit.SECONDS);</span></span><br><span class="line"><span class="comment">//        &#125; else if (count &lt; 5) &#123;//说明正常访问</span></span><br><span class="line"><span class="comment">//            valueOperations.increment(key);</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;//说明用户在刷接口</span></span><br><span class="line"><span class="comment">//            return RespBean.error(RespBeanEnum.ACCESS_LIMIT_REACHED);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个业务逻辑-校验用户输入的验证码是否正确</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">check</span> <span class="operator">=</span> orderService.checkCaptcha(user, goodsId, captcha);</span><br><span class="line">    <span class="keyword">if</span> (!check) &#123;<span class="comment">//如果校验失败</span></span><br><span class="line">        <span class="keyword">return</span> RespBean.error(RespBeanEnum.CAPTCHA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> orderService.createPath(user, goodsId);</span><br><span class="line">    <span class="keyword">return</span> RespBean.success(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用来存储拦截器获取的 user 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个线程都有自己的ThreadLocal, 把共享数据存放到这里，保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; userHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userHolder.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属实看不懂这个拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AccessLimitInterceptor: 自定义的拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessLimitInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装配需要的组件/对象</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法完成1. 得到user对象，并放入到ThreadLoacl 2. 去处理@Accesslimit</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">            <span class="comment">//这里我们就先获取到登录的user对象</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getUser(request, response);</span><br><span class="line">            <span class="comment">//存入到ThreadLocal</span></span><br><span class="line">            UserContext.setUser(user);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把handler 转成 HandlerMethod</span></span><br><span class="line">            <span class="type">HandlerMethod</span> <span class="variable">hm</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">            <span class="comment">//获取到目标方法的注解</span></span><br><span class="line">            <span class="type">AccessLimit</span> <span class="variable">accessLimit</span> <span class="operator">=</span> hm.getMethodAnnotation(AccessLimit.class);</span><br><span class="line">            <span class="keyword">if</span> (accessLimit == <span class="literal">null</span>) &#123;<span class="comment">//如果目标方法没有@AccessLimit说明该接口并没有处理限流防刷</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//继续</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取注解的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> accessLimit.second();<span class="comment">//获取到时间范围</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> accessLimit.maxCount();<span class="comment">//获取到最大的访问次数</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">needLogin</span> <span class="operator">=</span> accessLimit.needLogin();<span class="comment">//获取是否需要登录</span></span><br><span class="line">            <span class="keyword">if</span> (needLogin) &#123;<span class="comment">//说明用户必须登录才能访问目标方法/接口</span></span><br><span class="line">                <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;<span class="comment">//说明用户没有登录</span></span><br><span class="line">                    <span class="comment">//返回一个用户信息错误的提示...一会再单独处理...</span></span><br><span class="line">                    render(response, RespBeanEnum.SESSION_ERROR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> uri + <span class="string">&quot;:&quot;</span> + user.getId();</span><br><span class="line">            <span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> (Integer) valueOperations.get(key);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//说明还没有key,就初始化，值为1, 过期时间为5秒</span></span><br><span class="line">                valueOperations.set(key, <span class="number">1</span>, second, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; maxCount) &#123;<span class="comment">//说明正常访问</span></span><br><span class="line">                valueOperations.increment(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明用户在刷接口</span></span><br><span class="line">                <span class="comment">//返回一个频繁访问的的提示...一会再单独处理...</span></span><br><span class="line">                render(response,RespBeanEnum.ACCESS_LIMIT_REACHED);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法：构建返回对象-以流的形式返回</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(HttpServletResponse response,</span></span><br><span class="line"><span class="params">                        RespBeanEnum respBeanEnum)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="comment">//构建RespBean</span></span><br><span class="line">        <span class="type">RespBean</span> <span class="variable">error</span> <span class="operator">=</span> RespBean.error(respBeanEnum);</span><br><span class="line">        out.write(<span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(error));</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单独编写方法，得到登录的user对象-userTicket</span></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">getUser</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ticket</span> <span class="operator">=</span> CookieUtil.getCookieValue(request, <span class="string">&quot;userTicket&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(ticket)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//说明该用户没有登录，直接返回null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserByCookie(ticket, request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装配</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserArgumentResolver userArgumentResolver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AccessLimitInterceptor accessLimitInterceptor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    注册自定义拦截器，这样就可以生效</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(accessLimitInterceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态资源加载</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/static/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里加入我们自定义的解析器到 HandlerMethodArgumentResolver列表中</span></span><br><span class="line">    <span class="comment">//这样自定义的解析器工作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> &#123;</span><br><span class="line">        resolvers.add(userArgumentResolver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserArgumentResolver: 自定义的一个解析器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装配UserService</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断你当前要解析的参数类型是不是你需要的?</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">        <span class="comment">//获取参数是不是user类型</span></span><br><span class="line">        Class&lt;?&gt; aClass = parameter.getParameterType();</span><br><span class="line">        <span class="comment">//如果为t, 就执行resolveArgument</span></span><br><span class="line">        <span class="keyword">return</span> aClass == User.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果上面supportsParameter,返回T,就执行下面的resolveArgument方法</span></span><br><span class="line">    <span class="comment">//到底怎么解析，是由程序员根据业务来编写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span></span><br><span class="line"><span class="comment">//        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        String ticket = CookieUtil.getCookieValue(request, &quot;userTicket&quot;);</span></span><br><span class="line"><span class="comment">//        if (!StringUtils.hasText(ticket)) &#123;</span></span><br><span class="line"><span class="comment">//            return null;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        //从Redis来获取用户</span></span><br><span class="line"><span class="comment">//        User user = userService.getUserByCookie(ticket, request, response);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        return user;</span></span><br><span class="line">        <span class="keyword">return</span> UserContext.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Component 和 @Configuration 的区别</title>
      <link href="/2023/03/10/technology/Component%E5%92%8CConfiguration%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/03/10/technology/Component%E5%92%8CConfiguration%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="Component-和-Configuration-的区别"><a href="#Component-和-Configuration-的区别" class="headerlink" title="Component 和 @Configuration 的区别"></a>Component 和 @Configuration 的区别</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ul><li><p>Component类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">   * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Configguration类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>从定义来看， @Configuration 注解本质上还是 @Component，因此 @ComponentScan 能扫描到@Configuration 注解的类。</li><li>@Configuration 中所有带 @Bean 注解的方法都会被动态代理，因此调用该方法返回的都是同一个实例。</li><li>调用@Configuration类中的@Bean注解的方法，返回的是同一个示例；而调用@Component类中的@Bean注解的方法，返回的是一个新的实例。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hdfs的产生</title>
      <link href="/2022/05/09/bolg/hdfs%E7%9A%84%E4%BA%A7%E7%94%9F/"/>
      <url>/2022/05/09/bolg/hdfs%E7%9A%84%E4%BA%A7%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="HDFS产生背景"><a href="#HDFS产生背景" class="headerlink" title="HDFS产生背景"></a>HDFS产生背景</h3><p>HDFS（Hadoop分布式文件系统）是Apache  Hadoop项目的一个重要组成部分，用于存储和处理大规模数据集。<br>在过去的几十年中，数据量呈指数级增⻓，传统的存储和处理方法已经无法应对这些大规模数据的挑战。在此背景下，Google公司在 2003 年发表了一篇关于Google文件系统（GFS）的论文，介绍了他们自主开发的分布式文件系统。这篇论文引起了广泛的关注，并促进了分布式文件系统研究的发展。<br>随后，Apache软件基金会在 2006 年创建了Hadoop项目，旨在实现可靠、可扩展、高效的分布式计算平台，其中包括了HDFS作为其默认的分布式文件系统。HDFS受到GFS的启发，在设计上采用了类似的思想和架构。</p><p><strong>HDFS的产生背景主要有以下几个方面：</strong></p><ul><li>数据爆炸：随着互联网的普及和各种应用程序的快速发展，人们创造和收集的数据量不断增加。从社交媒体、移动应用到物联网设备，各种渠道都在不断产生大量的数据。传统的存储系统已经无法满足如此庞大的数据规模和处理需求。</li><li>数据分析：大数据分析已经成为企业和科研机构的重要工具。传统的数据存储和处理方法无法满足对大规模数据集进行高效处理和分析的需求。HDFS提供了高吞吐量的数据访问方式，能够满足大规模数据处理的需求。</li><li>分布式环境：随着计算资源的不断增加，采用分布式计算架构可以更好地利用这些资源。HDFS作为分布式文件系统，能够将数据存储在多个节点上，实现数据冗余和高可用性，并通过并行处理技术来提高数据处理效率。</li></ul><p>总之，HDFS的产生背景是由于传统的存储和处理方法无法应对大规模数据的挑战，而HDFS作为一种可靠、可扩展、高效的分布式文件系统，能够满足大规模数据存储和处理的需求。</p><h3 id="HDFS的定义"><a href="#HDFS的定义" class="headerlink" title="HDFS的定义"></a>HDFS的定义</h3><p>HDFS是一种可靠、可扩展、高吞吐量的分布式文件系统，通过目录树来定位文件，旨在存储和处 理大规模数据集。</p><p>思考：HDFS采用了什么方式达到了高吞吐的？</p><p>HDFS具有高吞吐量的特点主要因为以下几个原因：</p><ul><li>数据切块和分布复制：HDFS将大文件切分成多个固定大小的数据块，并将这些数据块复制到集群 中的多个节点上。这样可以实现数据的并行操作，提高了整体的数据传输速度和处理能力。</li><li>流式数据访问：HDFS采用了流式数据访问方式，即一次性连续读写大量数据而不是频繁的随机读写。这种设计避免了磁盘寻道时间的开销，使得数据的传输更加高效。</li><li>数据本地性优化：尽可能地将计算任务分配给存储数据的节点进行处理，以减少数据传输的开销。 这样可以最大限度地利用节点上的本地数据，提高数据的访问速度和处理效率。</li><li>写入优化：HDFS的写入操作采用了追加写入（append）的方式，即可以在已有数据的末尾进行写 入，而无需移动或重写已有的数据。这种写入方式可以提高写入的效率，适用于一次性写入大量数据的场景。</li></ul><p>总之，HDFS通过数据切块、分布复制、流式数据访问和数据本地性优化等策略来提高吞吐量。这些设 计和优化使得HDFS能够并行处理大规模数据集，实现高效的数据读写和传输，从而实现了高吞吐量的操作。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>一次写入，多次读取，不支持文件修改，适合数据分析。</li><li>不适合低延迟访问，不适合小文件存储。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>存储架构的发展</title>
      <link href="/2022/05/04/bolg/%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8F%91%E5%B1%95/"/>
      <url>/2022/05/04/bolg/%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8F%91%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h2 id="存储架构的发展"><a href="#存储架构的发展" class="headerlink" title="存储架构的发展"></a>存储架构的发展</h2><h3 id="单机存储"><a href="#单机存储" class="headerlink" title="单机存储"></a>单机存储</h3><p>单机存储是最早的存储方式，将数据保存在单个计算机的本地存储设备中，如硬盘或固态硬盘。</p><ul><li>优点：存取速度快，简单易用。</li><li>缺点：容量有限，可靠性低，不具备横向扩展能力。</li></ul><h3 id="集中式存储"><a href="#集中式存储" class="headerlink" title="集中式存储"></a>集中式存储</h3><p>随着数据量的增⻓，人们开始将数据集中存储在专用服务器或存储设备上。通过网络连接，多个客戶端可以同时访问和共享存储设备上的数据。</p><ul><li><p>优点：提供了更高的存储容量和可靠性，实现了更好的数据管理和共享。</p></li><li><p>缺点：单点故障⻛险较高，不适合大规模分布式应用。</p></li></ul><h3 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h3><p>分布式存储将数据分散存储在多个节点上，每个节点都具有自己的存储资源。 数据可以通过分片和冗余备份来提高可靠性和容错性。 通过分布式协调和数据一致性机制，实现数据的高可用性和负载均衡。</p><ul><li><p>优点：具备良好的可扩展性、容错性和性能。</p></li><li><p>缺点：复杂度较高，需要解决一致性、并发和故障处理等挑战。</p></li></ul><h3 id="云存储"><a href="#云存储" class="headerlink" title="云存储"></a>云存储</h3><p>云存储是一种基于云计算模式的存储方式，将数据存储在云服务提供商的服务器上，并通过网络进行访问。 用戶可以根据需求弹性地扩展存储容量，并享受高可用性、灵活性和成本效益等优势。提供了多种存储服务模型，如对象存储、块存储和文件存储，满足不同应用场景的需求。</p><h3 id="云原生存储"><a href="#云原生存储" class="headerlink" title="云原生存储"></a>云原生存储</h3><p>云原生存储是一种将存储与容器编排平台紧密集成的新兴存储方式，以支持动态、可移植和弹性的应 用程序部署。 提供了存储卷管理、数据持久化和多租戶支持等高级功能。</p><ul><li>优点：更好地适应容器化环境，提供了更高的灵活性和可操作性。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2022/05/03/javabase/%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/05/03/javabase/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>在开发代码时，我们通常明确使用关键字new创建对象，然后调用对象的某个具体方法，这种方式在<br>程序运行前就已经确定了对象的类型、方法、字段等。有些功能场景下，需要动态获取并修改对象运<br>行时行为，这就是Java反射的作用，通过Java反射，可以动态获取对象的方法(包括构造方法)、属<br>性、注解、修饰符等，任何东西在反射面前都是透明的。</p><p><strong>反射的一些缺点</strong></p><ul><li>性能相对较低：没有经过编译优化，需要动态即时解析。</li><li>有安全⻛险：私有方法或属性，可通过反射强制进入。</li><li>难以维护：修改类的方法或字段时，部分反射代码功能错误在编译时无法检查</li></ul><p>虽然反射有一些缺点，但是它的应用场景也非常广泛。</p><ul><li>动态代理，字节码增强</li><li>框架设计，解耦、提升扩展性</li><li>序列化与反序列化</li><li>JavaBean</li><li>IDE工具</li></ul><p>java.lang.reflect包提供了大量的反射API，主要的一些核心类包括Method、Field、Constructor等。<br>JVM给每个对象提供了一个java.lang.Class实例，相同类型的实例对象得到的是同一个Class对象，<br>Class是反射API操作的入口。</p><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><p>Java提供了三种方式获取Class对象</p><h4 id="Object-getClass"><a href="#Object-getClass" class="headerlink" title="Object.getClass()"></a>Object.getClass()</h4><h4 id="class-语法"><a href="#class-语法" class="headerlink" title=".class 语法"></a>.class 语法</h4><p>当有一个有效的类型，但是并没有对应的类型实例时，直接在类型实例后面增加.class语法，即可获取Class对象。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean b;</span><br><span class="line">Class c = b.getClass(); // 编译错误</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class c = boolean.class; // 正确</span><br></pre></td></tr></table></figure><p>获取Integer的Class对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class c = java.lang.Integer.class;</span><br></pre></td></tr></table></figure><h4 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName()"></a>Class.forName()</h4><p>这种方式必须知道类的全类名，然后通过Class的静态方法forName()获取，全类名不存在，则会抛出ClassNotFoundException异常，不能使用这种方式获取Java原始类型的Class对象。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clz = Class.forName(&quot;java.lang.Integer&quot;);</span><br></pre></td></tr></table></figure><p>Class.forName经常用于让JVM主动加载某个Class，如加载MySQL的驱动类。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure><p>这种方式作用是什么？<br>类加载之后，接着会进行初始化，其中包括类的静态代码块的执行，MySQL的Driver类就是通过静态代码块，完成了一个非常重要的操作，即把MySQL的驱动注册到JDBC驱动管理器中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">try &#123;</span><br><span class="line">DriverManager.registerDriver(new Driver());</span><br><span class="line">&#125; catch (SQLException var1) &#123;</span><br><span class="line">throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span><br></pre></td></tr></table></figure><h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p>构造方法用于创建一个Class的实例对象，反射API可以获取构造方法，包括方法的修饰符、参数类型、注解以及是否抛出异常等，构造方法不能继承。</p><h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><p>在反射API中，一个Field对象代表的是一个字段信息，通过java.lang.reflect.Field可以获取字段的名称、类型、修饰符、注解等，Filed可能是一个Java原始类型，也可能是对象引用类型。</p><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>一个Method对象代表的是一个可被调用的普通方法(包括静态方法)，java.lang.reflect.Method类提供<br>了获取方法的修饰符、返回值类型、参数类型、注解以及已经声明的抛出异常等信息。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>缓冲流</title>
      <link href="/2022/05/03/javabase/%E7%BC%93%E5%86%B2%E6%B5%81/"/>
      <url>/2022/05/03/javabase/%E7%BC%93%E5%86%B2%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>Java非缓冲流的每次读写都需要进行本地方法调用，交给底层操作系统进行处理，工作效率非常低， 因为每次请求可能都会触发磁盘读写、网络活动以及其它一些开销昂贵的操作。为了减少操作系统的负载，Java提供了IO缓冲流，缓冲流内部提供了缓冲区(buffer)进行读写，大部分缓冲流的buffer默认 大小为 8192 字节(8KB)。</p><ul><li>缓冲输入流从内存区域的buffer读取数据，当buffer数据为空时，Java本地输入方法才会进行调<br>用。</li><li>缓冲输出流将数据写入到内存区域的buffer，当buffer写满时，Java本地输出方法才会进行调用。</li></ul><p>Java程序可以通过包装方式将非缓冲流构造成为一个缓冲流，BufferedInputStream、 BufferedOutputStream用于构造缓冲字节流，BufferedReader、BufferedWriter用于构造缓冲字符流。</p><h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><p>字节缓冲流主要包括缓冲输入流BufferedInputStream，缓冲输出流BufferedOutputStreamWriter。</p><ul><li>BufferedInputStream通过非缓冲字节流FileInputStream进行一次磁盘IO，一次性读取多个字节<br>数据到内存buffer(字节数组)，后续程序只需从内存中的buffer数组中读取字节数据，减少IO操作次<br>数。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStreamDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://test/source.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">int</span> c;</span><br><span class="line">            <span class="comment">// 从内存buffer中读取字节数据，如果buffer为空，才会进行IO操作</span></span><br><span class="line">            <span class="keyword">while</span>((c = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BufferedInputStream通过FileInputStream提供的本地方法readBytes，可以通过一次IO操作读取多个字节数据。</p><ul><li>BufferedOutputStream通过非缓冲字节流FileOutputStream进行一次磁盘IO，将内存缓冲区<br>buffer中的多个字节数据一次性写入文件中，减少IO操作次数。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedOutputStreamDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://test/target.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="comment">// 写入字符 &#x27;2&#x27; 到内存buffer</span></span><br><span class="line">            bos.write(<span class="number">50</span>);</span><br><span class="line">            <span class="comment">// 写入字符 &#x27;0&#x27; 到内存buffer</span></span><br><span class="line">            bos.write(<span class="number">48</span>);</span><br><span class="line">            <span class="comment">// 写入字符 &#x27;2&#x27; 到内存buffer </span></span><br><span class="line">            bos.write(<span class="number">50</span>);</span><br><span class="line">            <span class="comment">// 写入字符 &#x27;3&#x27; 到内存buffer</span></span><br><span class="line">            bos.write(<span class="number">51</span>);</span><br><span class="line"><span class="comment">// 可在此 sleep 10s，去检测文件内容， 10s后调用了flush方法文件内容才写入         </span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(10000);</span></span><br><span class="line"><span class="comment">//        &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">            <span class="comment">// 刷新输出流，将内存buffer数据写到文件中</span></span><br><span class="line">            <span class="comment">// 缓冲流的close方法调用时，会先自动调用一次flush方法，强制将数据写出</span></span><br><span class="line">            <span class="comment">// 但是明确后续没有数据可写时，最好养成良好习惯，手动调用一次flush方法</span></span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BufferedOutputStream此时依赖的方法是非缓冲字节流FileOutputStream提供的本地方法writeBytes。</p><h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><p>字符缓冲流主要包括缓冲输入流BufferedReader，缓冲输出流BufferedWriter。</p><ul><li>BufferedReader可基于InputStreamReader、FileReader等非字符缓冲流构造。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D://test/source.txt&quot;</span>))) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="comment">// 按行读取，自动处理回车换行符</span></span><br><span class="line">            <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于FileReader构造BufferedReader</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;D://test/source.txt&quot;))</span><br></pre></td></tr></table></figure><ul><li>BufferedWriter可基于OutputStreamReader、FileWriter等非字符缓冲流构造。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriterDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://test/target.txt&quot;</span>)))) &#123;</span><br><span class="line">            bw.write(<span class="string">&quot;2023&quot;</span>);</span><br><span class="line">            <span class="comment">// windows换行符</span></span><br><span class="line">            <span class="comment">// bw.write(&quot;\r\n&quot;);</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.write(<span class="string">&quot;2023&quot;</span>);</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于FileWriter构造BufferedWriter</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;D://test/target.txt&quot;))</span><br></pre></td></tr></table></figure><p>基于PrintWriter构造BufferedWriter</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 BufferedWriter bw = new BufferedWriter(new PrintWriter(new FileWriter(&quot;D://test/</span><br></pre></td></tr></table></figure><p>flush方法是属于输出流的方法，调用非缓冲流的flush方法不会产生任何作用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符流</title>
      <link href="/2022/05/03/javabase/%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
      <url>/2022/05/03/javabase/%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>Java采用Unicode规范处理字符，字符流IO自动将Java内部字符格式与本地字符集进行转换，自动解<br>码编码，因此比起直接使用IO字节流，字符流操作相对更简单高效，所有的字符操作流都是从抽象类<br>Reader以及Writer继承而来。</p><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>字符都有编码，读写字符时的编码不一致，则容易出现乱码，因此首先需要简单了解下常⻅的字符编<br>码规则。</p><p><strong>ASCII码</strong></p><p>ASCII是American Standard Code for Information Interchange缩写，称为美国信息交换标准代码。<br>ASCII一共定义了 128 个字符，其中 33 个字符是不可显示的控制字符， 95 个可显示的字符。</p><p>一个字节占 8 位，2^8&#x3D;256，即一个字节可表示 256 个字符(0<del>255)，而ASCII字符只有 128 个，因此一个字节的低 7 位，2^7&#x3D;128，足以表达全部的ASCII字符(0</del>127)，128~255则预留扩展其它字符，但 128 位根本不足以表示其它国家的字符。</p><p><strong>GBK</strong></p><ul><li>GBK全称汉字内码扩展规范，GBK一共收集了^2 万多汉字与字符，一个中文字符编码成两个字节进<br>行存储。</li><li>GBK兼容了ASCII字符集</li></ul><p>GBK是从GB2312编码规范上扩展的，而中国的汉字与符号有数十万，显然GBK也是不够的，因此又出现了GB18030, 按照字符集表示范围GB18030 &gt; GBK &gt; GB2312。</p><p><strong>Unicode</strong></p><p>各个国家都有自己的编码，当计算机信息在国际上进行交换时，就会出现问题，如用GBK编码的字节<br>数据发送给A国家，A国家采用A国码解码肯定就出现了乱码，此时国际标准组织就制定了一套通用的字<br>符集Unicode，即统一码，也叫万国码。</p><ul><li>Unicode字符集收纳了世界上所有文字、符号，统一进行编号</li></ul><p><strong>UTF-8</strong></p><p>Unicode只是一种字符集，并不是编码方案，没有编码方案则无法存储。Unicode字符集出现最早的编<br>码方案是UTF-32，它规定所有的字符都采用固定的 4 个字节来表示， 4 个字节3 2位，可以表示 42 亿字<br>符，足以支撑Unicode字符集。即使只需一个字节的ASCII字符a(二进制0110 0001 )，也必须用 4 个字<br>节表示，前三字节直接补 0 。</p><p>UTF-32采用固定字节编码，程序处理简单，但是占用空间太大，基本很少使用，此时国际标准组织推出了Unicode编码方案UTF-8。</p><ul><li>UTF-8针对Unicode字符集采取可变⻓编码方案，共分为四个⻓度区，1~4个字节</li><li>英文、数字等只占用一个字节(兼容标准的ASCII编码)，汉字字符占用^3 个字节</li></ul><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p>Reader读取字符流，子类必须实现read、close方法，大部分子类会覆盖Reader中方法，提供更高效<br>的操作或者一些额外的功能。</p><p>Reader提供的方法</p><p>1.4.3 Writer</p><p>Writer用于将字符写入到字符流中，子类必须实现write、flush、close方法，大部分子类会覆盖Writer<br>中方法，提供更高效的操作或者一些额外的功能。Note: 下图中少了一个常用的PrintWriter</p><h4 id="操作使用"><a href="#操作使用" class="headerlink" title="操作使用"></a>操作使用</h4><p>一个字符流通常包装一个字节流，通过字节流去实现底层物理IO操作，字符流处理字符与字节之间的数据转换。在Java中有两个通用的字节到字符的桥接流，InputStreamReader与 OutputStreamReader。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyCharacters</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://test/source.txt&quot;</span>));</span><br><span class="line">             <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(</span><br><span class="line">                     <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://test/target.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">int</span> c;</span><br><span class="line">            <span class="keyword">while</span>((c=isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(c);</span><br><span class="line">                osw.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字符流编码"><a href="#字符流编码" class="headerlink" title="字符流编码"></a>字符流编码</h5><p>上述main方法在构造字符输入输出流时，未明确指定读写字符编码，字符流最终采用的是系统平台默<br>认编码。</p><ul><li>Windows中文系统默认是GBK</li><li>Linux系统默认是UTF-8</li></ul><p>Java在安装时，根据系统编码自动设置Java系统属性，通过如下命令查看Java系统属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 java -XshowSettings:property -version</span><br></pre></td></tr></table></figure><p>Java系统属性值中有 2 个与编码相关的属性</p><ul><li><strong>file.encoding</strong> ：这个非常重要，在Java中读取文件、URLEncode、字符串数据编码等都与此属性<br>有关。</li><li>sun.jnu.encoding：不用关注，用于JVM查找加载class的类名路径编码等</li></ul><p>注意：在Windows下开发时，使用Java命令查看Java系统属性时，file.encoding&#x3D;GBK，当使用IDEA<br>工具开发项目时，通过IDEA给项目又设置了UTF-8编码，最终IDEA运行Java程序时，会通过-Dfile.encoding&#x3D;UTF-8去覆盖默认的编码。当开发过程中遇⻅字符乱码时，需要关注JVM实际运行时的系统属性，也可通过代码获取。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 String fileEncoding = System.getProperty(&quot;file.encoding&quot;)</span><br></pre></td></tr></table></figure><p>指定字符编码构造字符输入输出流</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 指定UTF-8编码读字符数据</span><br><span class="line">new InputStreamReader(new FileInputStream(&quot;D://test/source.txt&quot;), StandardCharse</span><br><span class="line">// 指定UTF-8编码写字符数据</span><br><span class="line">new OutputStreamWriter(new FileOutputStream(&quot;D://test/target.txt&quot;), StandardChar</span><br></pre></td></tr></table></figure><p>读写字符数据时编码必须保持一致，否则会出现字符乱码。<br>在中文Windows上使用记事本新建D:&#x2F;&#x2F;test&#x2F;source.txt文件，写入 2023,星云训练营 ，然后以ANSI编码 保存，在Windows中文系统上ANSI处理中文时就是GBK。</p><h5 id="文件读写字符流"><a href="#文件读写字符流" class="headerlink" title="文件读写字符流"></a>文件读写字符流</h5><p>Java中还提供了FileReader、FileWriter简化了从文件读写字符，其内部自动封装包裹了对应的文件字节流，但是采用FileReader、FileWriter时只能使用JVM默认编码，无法单独设置读取字符的编码，因 此统一编码非常重要。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// InputStreamReader从文件读取字符内容</span><br><span class="line">new InputStreamReader(new FileInputStream(&quot;D://test/source.txt&quot;), StandardCharse</span><br><span class="line">// OutputStreamWriter将字符内容写入文件</span><br><span class="line">new OutputStreamWriter(new FileOutputStream(&quot;D://test/target.txt&quot;), StandardChar</span><br></pre></td></tr></table></figure><p>使用FileReader、FileWriter读写字符内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyFileCharacters</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D://test/source.txt&quot;</span>);</span><br><span class="line">             <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D://test/target.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 查看FileReader读取字符编码</span></span><br><span class="line">            System.out.println(fr.getEncoding());</span><br><span class="line">            <span class="comment">// 查看FileWriter写入字符编码</span></span><br><span class="line">            System.out.println(fw.getEncoding());</span><br><span class="line">            <span class="type">int</span> c;</span><br><span class="line">            <span class="keyword">while</span> ((c = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(c);</span><br><span class="line">                fw.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要追加内容到文件中，请使用FileWriter两个参数的构造方法，第二个参数设置为true</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public FileWriter(File file, boolean append)</span><br><span class="line">// 第二个参数为true，字节内容会从文件末尾开始写入</span><br><span class="line">FileWriter fw = new FileWriter(&quot;D://test/target.txt&quot;, true);</span><br></pre></td></tr></table></figure><p>字符流IO经常会以更大单位读取字符，最常用的就是按行读取字符。一行包括一系列字符组成的字符串以及末尾的行结束符，行结束符可以是回⻋换行符\r\n，也可以是单个回⻋键字符\r，或者单个换行符\n。不同的操作系统，其换行符可能有所不同。</p><ul><li>Dos、Windows采用回⻋+换行符(CR+LF)表示下一行，即字符表现形式\r\n</li><li>Unix、Linux采用换行符(LF)表示下一行，字符表现形式为\n</li><li>Mac采用回⻋符(CR)表示下一行，字符表现形式为\r</li></ul><p>CR回⻋符ascii码十进制为13, 换行符ascii码十进制为 10 。</p><p>支持按行读写的字符流有BufferedReader、BufferedWriter、PrintWriter等，根据操作系统自动处理行结束符。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节流</title>
      <link href="/2022/05/02/javabase/%E5%AD%97%E8%8A%82%E6%B5%81/"/>
      <url>/2022/05/02/javabase/%E5%AD%97%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>字节流的输入输出都是以字节为单位处理数据，一个字节等于 8 个二进制位，即由 8 位 0 或 1 组成的序列，如 01102300 为一个字节。在Java中所有的字节流都是从抽象类InputStream或OutputStream 类继承而来。大部分字节流使用方式相同，只是它们的构造方式可能不一样。</p><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/javabase/img_1.png" alt="image.png"></p><p>InputStream提供的方法</p><table><thead><tr><th>方法名</th><th>签名</th><th>描述</th></tr></thead><tbody><tr><td>read</td><td>public abstract int read()</td><td>这是一个抽象方法，需要子类实现，用于从输入流中读取下一个字节数据。由于一个字节是 8 位，返回值介于0~255之间，如果没有可读数据，即达到了流的末尾，则返回-1。方法会一直阻塞直到有字节数据可读、到达流末尾或者发生IO异常。</td></tr><tr><td>read</td><td>public int read(byte b[])</td><td>从输入流中读取b.length个字节，并储存到字节数组b中，如果b⻓度为 0 ，则不会读取任何字节数据，方法返回 0 。 read(byte b[]) -&gt; read(byte b[], int off, int len) -&gt; read</td></tr><tr><td>read</td><td>public int read(byte b[], int off, int len)</td><td>从输入流中读取最多len个字节，如果len为 0 ，不会读取任何字节数据，直接返回 0 ，读取的字节从数组b的off位置开始存放。 read(byte b[], int off, int len) -&gt; read()</td></tr><tr><td>skip</td><td>public long skip(long n)</td><td>跳过并丢弃输入流中的n个字节数据，通过调用read(byte b[], int off, int len)读取字节并丢弃。</td></tr><tr><td>available</td><td>public int available()</td><td>返回下一次操作时，输入流中预估的可读字节数量</td></tr><tr><td>close</td><td>public void close()</td><td>关闭输入流，释放与流关联的系统资源</td></tr><tr><td>markSupported</td><td>public boolean markSupported()</td><td>用于测试输入流是否支持mark与reset方法</td></tr><tr><td>mark</td><td>public synchronized void mark(int readlimit)</td><td>在输入流中标记当前位置，标记位置后，还可以读取最多readlimit字节，后续可以通过reset方法回到上一次mark的位置，达到重复读取相同字节数据的操作，使用mark方法，则markSupported必须返回true，在关闭的流中调用mark方法，不会有任何效果。</td></tr><tr><td>reset</td><td>public synchronized void reset()</td><td>在流中复位，回到上一次调用mark方法标记的位置，如果未发现任何mark或者上一次mark标记后读取的字节数超过readlimit，则发生IOException，使用reset方法，则markSupported必须返回true。</td></tr></tbody></table><p>InputStream中的方法大部分都是一种规范，最终的字节流子类某些方法可能会有所不同。</p><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><p>OutputStream提供的方法</p><table><thead><tr><th>方法名</th><th>签名</th><th>描述</th></tr></thead><tbody><tr><td>write</td><td>public abstract void write(int b)</td><td>这是一个抽象方法，需要子类实现，用于将指定的字节数据写入到输出流中，在Java中int是 32 位，4个字节，write方法实际写入的只是整型数据b的低 8位，其余 24 位直接忽略。write  public void write(byte b[])  将字节数组b中的数据写入到输出流中，write(byte b[])-&gt;write(byte b[], int off, int len)-&gt;write()</td></tr><tr><td>write</td><td>public void write(byte b[], int off, int len)</td><td>从字节数组b下标为off的位置开始，将len个字节数据写入到输出流中。write(byte b[], int off, int len)-&gt;write()</td></tr><tr><td>flush</td><td>public void flush()</td><td>刷新输出流，强制一些缓冲输出流将内部缓冲的一些字节数据立即写入目标地，如果目标地是磁盘文件，调用flush方法后，并不保证文件⻢上更新，这取决于操作系统。</td></tr><tr><td>close</td><td>public void close()</td><td>关闭输出流，释放与流关联的系统资源</td></tr></tbody></table><h4 id="操作使用"><a href="#操作使用" class="headerlink" title="操作使用"></a>操作使用</h4><p>文件IO字节流FileInputStream、FileOutputStream是使用最广泛的两个类，以这两个类进行操作说明。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyBytes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 文件数据输入流，如果文件不存在或者是一个目录，则发生FileNotFoundException</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://test/source.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 数据输出流，目标文件不存在，大部分系统都会自动创建，如果文件已存在，则覆盖文件中已有内容</span></span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://test/target.txt&quot;</span>);</span><br><span class="line">            <span class="type">int</span> c;</span><br><span class="line">            <span class="comment">// 如果返回-1，表示已经读到流的末端</span></span><br><span class="line">            <span class="keyword">while</span> ((c = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是ascii字符，每个字符对应的整型值一定是0~127，</span></span><br><span class="line">                <span class="comment">// 如果是汉字，而一个汉字由多个字节组成，因此会输出多个整型数据，128~255</span></span><br><span class="line">                System.out.print(c + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                fos.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 从输入流读取数据完成后，一定要关闭流，释放系统资源</span></span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将数据写入输出流完成后，一定要关闭流，释放系统资源</span></span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IO流操作完成后，一定要在finally语句块中进行关闭，Java7开始提供了try-with-resources语法，编<br>译器识别该语法后，在字节码文件中自动生成了对应的finally语句块，并在语句块中关闭对应的流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用try-with-resources语法读写文件代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyBytes2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://test/source.txt&quot;</span>);</span><br><span class="line">             <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://test/target.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> c;</span><br><span class="line">            <span class="comment">// 内容长度(可读取的字节数量)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;内容有效字节数: &quot;</span> + fis.available());</span><br><span class="line">            <span class="keyword">while</span> ((c = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(c + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                fos.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如source.txt文件有如下字符内容：I2023,我 ，文件编码为UTF-8时输出 9 个字节(汉字占用了三个字节)。</p><p>最后三个大于 127 的十进制值则表示汉字 我，其余的对应的是ascii字符。</p><p>FileOutputStream可以控制字节内容写入起始位置</p><ul><li>通过new FileOutputStream(D:&#x2F;&#x2F;test&#x2F;target.txt) 构造输出流</li></ul><p>每次从文件开头写入字节数据，因此会覆盖上一次打开文件时写入的内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://test/target.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2023,Ksyun 星云训练营&quot;</span>;</span><br><span class="line">            <span class="comment">// 调用FileOutputStream的write(byte b[])方法，写入多个字节</span></span><br><span class="line">            fos.write(s.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过new FileOutputStream(D:&#x2F;&#x2F;test&#x2F;target.txt, true) 构造输出流</li></ul><p>每次从文件末尾写入字节数据，相当于向文档中追加数据内容，多次运行上述main方法，会发现<br>D:&#x2F;&#x2F;test&#x2F;target.txt文件内容增加。</p><p>字节流是IO流中最底层的低水平操作流，文件中包含的是字符数据，更高效的方法是通过字符流进行操作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文件操作</title>
      <link href="/2022/05/01/javabase/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/05/01/javabase/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-文件操作"><a href="#1-1-文件操作" class="headerlink" title="1.1 文件操作"></a>1.1 文件操作</h3><p>java.io.File是Java提供的专⻔针对文件操作的类，File是文件与目录路径的一种抽象表示，用于操作文件与目录，不能操作文件内容。</p><h4 id="构造File对象"><a href="#构造File对象" class="headerlink" title="构造File对象"></a>构造File对象</h4><p>一个File对象通常表示磁盘上一个真实存在的文件或目录，创建File对象时，无论对应的文件与目录是否存在，不会影响File对象的构造。</p><p><strong>常用的三个构造File方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public File(String pathname)</td><td>通过给定的路径名创建指定的File实例</td></tr><tr><td>public File(String parent</td><td>String child)  根据指定的父路径与子路径字符串创建File实例</td></tr><tr><td>public File(File parent</td><td>String child)  根据指定的父路径File与子路径字符串创建新的File实例</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建表示一个目录的File实例</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建表示文件的File实例</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">sourceFile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test&quot;</span>, <span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据父路径File实例创建新的File实例</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">sourceFile2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir, <span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用的判断方法"><a href="#常用的判断方法" class="headerlink" title="常用的判断方法"></a>常用的判断方法</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public boolean exists()</td><td>判断文件或者目录是否存在</td></tr><tr><td>public boolean isDirectory()</td><td>判断File表示的路径是否是一个目录</td></tr><tr><td>public boolean isFile()</td><td>判断File表示的路径是否是一个文件</td></tr><tr><td>public boolean isHidden()</td><td>判断File是否是一个隐藏的文件与路径，即Unix以. 开始命名的文件或目录，Window需要在文件系统中 明确标记是否隐藏。</td></tr><tr><td>public boolean canRead()</td><td>判断是否可读</td></tr><tr><td>public boolean canWrite()</td><td>判断是否可写public boolean canExecute()  判断是否可执行</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">hiddenSshDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test/hidden&quot;</span>);</span><br><span class="line">    System.out.println(hiddenSshDir.isHidden()); <span class="comment">// true</span></span><br><span class="line">    System.out.println(hiddenSshDir.isFile()); <span class="comment">// false</span></span><br><span class="line">    System.out.println(hiddenSshDir.isDirectory()); <span class="comment">//true</span></span><br><span class="line">    System.out.println(hiddenSshDir.exists()); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用的获取属性方法"><a href="#常用的获取属性方法" class="headerlink" title="常用的获取属性方法"></a>常用的获取属性方法</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public String getName()</td><td>获取文件名或目录名，如source.txt</td></tr><tr><td>public String getAbsolutePath()</td><td>获取文件或目录绝对路径</td></tr><tr><td>public String getPath()</td><td>获取文件或目录相对路径，如果构造File时指定的就是绝对路径，则与getAbsolutePath返回内容一致，如果是相对路径，则以系统属性user.dir为目录创建。</td></tr><tr><td>public long length()</td><td>返回文件内容大小，单位字节。如果File表示的是目录，则返回0。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">sourceFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test/dir&quot;</span>); </span><br><span class="line">    System.out.println(sourceFile.getName()); <span class="comment">// dir</span></span><br><span class="line">    System.out.println(sourceFile.getAbsolutePath()); <span class="comment">// D:\workspace\base-star-point\test\dir</span></span><br><span class="line">    System.out.println(sourceFile.getParent()); <span class="comment">// test</span></span><br><span class="line">    System.out.println(sourceFile.getPath()); <span class="comment">// test\dir</span></span><br><span class="line">    System.out.println(sourceFile.length()); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作文件方法"><a href="#操作文件方法" class="headerlink" title="操作文件方法"></a>操作文件方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法  描述 </span><br><span class="line">public boolean createNewFile()  创建文件，如果文件已经存在，则返回false。 </span><br><span class="line">public boolean mkdir()  创建目录 </span><br><span class="line">public boolean mkdirs() </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建目录，父路径中任何一级目录不存在都会自动创</span><br><span class="line">建，类似mkdir -p /data/test/dir 命令 </span><br><span class="line">public boolean delete()  删除文件或目录，如果File是一个目录，并且目录不</span><br><span class="line">为空，则无法删除， 文件或目录正被其他程序使</span><br><span class="line">用，也无法删除。 </span><br><span class="line">public boolean renameTo(File dest)  重命名文件，即移动文件 </span><br></pre></td></tr></table></figure><p>创建文件或目录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test/txt&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">suc</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line">    System.out.println(suc); <span class="comment">// true，创建成功</span></span><br><span class="line">    suc = file.createNewFile();</span><br><span class="line">    System.out.println(suc); <span class="comment">// false, 文件已经存在</span></span><br><span class="line">    suc = file.mkdir();</span><br><span class="line">    System.out.println(suc); <span class="comment">// fasle, 相同路径名的文件已经存在，无法创建同名目录</span></span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test/a/b/c&quot;</span>);</span><br><span class="line">    suc = dir.mkdir();</span><br><span class="line">    System.out.println(suc); <span class="comment">// false，无法创建目录c, 父目录D://test/a/b不存在</span></span><br><span class="line">    suc = dir.mkdirs();</span><br><span class="line">    System.out.println(suc); <span class="comment">// true，整个目录D://test/a/b/c全部创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重命名文件，将D:&#x2F;&#x2F;test&#x2F;source.txt移动到D:&#x2F;&#x2F;test&#x2F;sub目录，并命名为b.txt。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test/source.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test/sub&quot;</span>);</span><br><span class="line">    dir.mkdir();</span><br><span class="line">    <span class="type">File</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test/sub/b.txt&quot;</span>);</span><br><span class="line">    System.out.println(source.renameTo(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建临时文件</p><p>File提供了一个静态方法创建临时文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未指定临时目录，使用系统属性java.io.tmpdir值作为临时目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title function_">createTempFile</span><span class="params">(String prefix, String suffix)</span></span><br><span class="line"><span class="comment">// 指定临时目录创建临时文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title function_">createTempFile</span><span class="params">(String prefix, String suffix, File directory)</span></span><br></pre></td></tr></table></figure><p>创建临时文件时，可以指定系统临时目录，File类默认使用系统属性java.io.tmpdir( java -<br>XshowSettings:properties -version 查看)值作为临时目录，后缀未填写则默认为.tmp。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> System.getProperties();</span><br><span class="line">    properties.forEach((k,v) -&gt; System.out.println(k + <span class="string">&quot;=&quot;</span> + v));</span><br><span class="line">    <span class="comment">// C:\Users\SUNJINFU\AppData\Local\Temp\test-1385972536118005697.log</span></span><br><span class="line">    System.out.println(File.createTempFile(<span class="string">&quot;test-&quot;</span>, <span class="string">&quot;.log&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历文件目录"><a href="#遍历文件目录" class="headerlink" title="遍历文件目录"></a>遍历文件目录</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public String[] list()</td><td>返回目录下子文件与子目录名，不是目录直接返回null</td></tr><tr><td>public String[] list(FilenameFilter filter)</td><td>返回目录下符合文件名条件的子文件与子目录字符串名</td></tr><tr><td>public File[] listFiles()</td><td>与list方法类似，返回类型是File数组</td></tr><tr><td>public File[] listFiles(FilenameFilter filter)</td><td>返回目录下符合文件名条件的子文件或子目录File数组</td></tr><tr><td>public File[] listFiles(FileFilter filter)</td><td>返回目录下符合条件的子文件或子目录File数组</td></tr></tbody></table><p>删除指定目录下的所有.txt文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过name filter过滤出文件名后缀为.txt的文件</span></span><br><span class="line">    File[] files = file.listFiles((dir, name) -&gt; name.endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (files != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            f.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除目录，如果目录不为空，则需先遍历删除子文件、子目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\test&gt;tree /f</span><br><span class="line">│ 1.log</span><br><span class="line">│</span><br><span class="line">├─a</span><br><span class="line">│ a.txt</span><br><span class="line">│</span><br><span class="line">└─b</span><br><span class="line">└─c</span><br><span class="line">c.txt</span><br></pre></td></tr></table></figure><p>删除D:&#x2F;&#x2F;test目录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteDirectoryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://test&quot;</span>);</span><br><span class="line">        deleteFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断文件是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是文件，直接删除</span></span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!file.delete()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;failed to delete file: &quot;</span> +  file.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是目录，则先遍历删除目录下文件或者子目录</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(files) &amp;&amp; files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                deleteFile(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后删除目录</span></span><br><span class="line">        <span class="keyword">if</span> (!file.delete()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;failed to delete directory: &quot;</span> +  file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h4><p>从Java7开始，在java.nio.file包下提供了一个文件或者目录操作工具类Files，F iles的方法基本都是静<br>态方法，该类不仅能操作文件，还能结合IO流操作文件内容。与File类相比，Files的很多方法都能明确<br>的返回操作失败的异常信息，而不是只返回简单的true或者false。</p><p>如test目录不存在时直接使用Files创建source.txt</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Exception in thread &quot;main&quot; java.nio.file.NoSuchFileException:</span><br><span class="line">D:\test\source.txt</span><br><span class="line">Files.createFile(Paths.get(&quot;D://test/source.txt&quot;));</span><br></pre></td></tr></table></figure><p>删除不存在的文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Exception in thread &quot;main&quot; java.nio.file.NoSuchFileException: D:\test\1.txt</span><br><span class="line">Files.delete(Paths.get(&quot;D://test/1.txt&quot;));</span><br></pre></td></tr></table></figure><p>Files提供了非常丰富的方法，按功能分为如下几类方法<br><img src="https://cdn.jsdelivr.net/gh/sazxsdawn2022/picgoimg/duskimg/javabase/img.png" alt="image.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tcp重传机制</title>
      <link href="/2022/04/12/technology/tcp%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/04/12/technology/tcp%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。</p><p>显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。</p><p>但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。</p><p>快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。</p><p>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。<br>与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p><h3 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h3><p>死等M3，当发送方发现收不到M3的ack超时后，会重传M3。一旦接收方收到M3后，会ack 回M4——意味着M3和M4都收到了。</p><p>但是，这种方式会有比较严重的问题，那就是因为要死等M3，所以会导致M4和M5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。</p><p>对此有两种选择：</p><ul><li>一种是仅重传timeout的包。也就是第3份数据。</li><li>另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。<br>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tcp的拥塞控制</title>
      <link href="/2022/04/12/technology/tcp%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/04/12/technology/tcp%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="tcp拥塞控制"><a href="#tcp拥塞控制" class="headerlink" title="tcp拥塞控制"></a>tcp拥塞控制</h2><h3 id="拥塞控制的原理"><a href="#拥塞控制的原理" class="headerlink" title="拥塞控制的原理"></a>拥塞控制的原理</h3><ul><li><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p></li><li><p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p></li></ul><h3 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h3><ul><li>当主机开始发送数据时，如果立即将大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。</li><li>通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</li><li>慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd&#x3D;1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</li></ul><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下：</p><ul><li>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当 cwnd &#x3D; ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。拥塞避免</li></ul><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><ul><li>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</li><li>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</li><li>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</li></ul><h3 id="乘法减小和加法增大"><a href="#乘法减小和加法增大" class="headerlink" title="乘法减小和加法增大"></a>乘法减小和加法增大</h3><ul><li>乘法减小：是指不论在慢开始阶段还是拥塞避免阶段，只要出现超时，就把慢开始门限减半，即设置为当前的拥塞窗口的一半（于此同时，执行慢开始算法）。当网络出现频繁拥塞时，ssthresh值就下降的很快，以大大将小注入到网络中的分组数。</li><li>加法增大：是指执行拥塞避免算法后是拥塞窗口缓慢增大，以防止网络过早出现拥塞。</li></ul><h3 id="拥塞控制和流量控制的差别"><a href="#拥塞控制和流量控制的差别" class="headerlink" title="拥塞控制和流量控制的差别"></a>拥塞控制和流量控制的差别</h3><ul><li>所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。</li><li>拥塞问题是一个全局性的问题,涉及到所有的主机、所有的路由器、以及与降低网络传输性能有关的所有因素。</li><li>流量控制往往指的是点对点通信量的控制，是个端到端的问题。流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tcp的流量控制</title>
      <link href="/2022/04/11/technology/tcp%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/04/11/technology/tcp%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><h3 id="什么是流量控制"><a href="#什么是流量控制" class="headerlink" title="什么是流量控制"></a>什么是流量控制</h3><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，对发送方发送速率的控制，要让接收方来得及接收。</p><p><strong>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制</strong></p><h3 id="如何控制？"><a href="#如何控制？" class="headerlink" title="如何控制？"></a>如何控制？</h3><p>接收方每次收到数据包，可以在发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，我们也把缓存区的剩余大小称之为接收窗口大小，用变量win来表示接收窗口的大小。<br>发送方收到之后，便会调整自己的发送速率，也就是<strong>调整</strong>自己发送窗口的<strong>大小</strong>，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，<strong>防止出现大量丢包情况的发生</strong>。</p><h3 id="发送方何时再继续发送数据"><a href="#发送方何时再继续发送数据" class="headerlink" title="发送方何时再继续发送数据?"></a>发送方何时再继续发送数据?</h3><p>当发送方收到接受窗口 win &#x3D; 0 时，这时发送方停止发送报文，并且同时开启一个<strong>定时器</strong>（心跳包），每隔一段时间就发个测试报文去询问接收方，打听是否可以继续发送数据了，如果可以，接收方就告诉他此时接受窗口的大小；如果接受窗口大小还是为0，则发送方再次刷新启动定时器。</p><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><ul><li>由于TCP&#x2F;IP支持<strong>全双工传输</strong>，因此通信的双方都拥有两个滑动窗口，一个用于接受数据，称之为<strong>接收窗口</strong>；一个用于发送数据，称之为<strong>拥塞窗口</strong>(即发送窗口)。指出接受窗口大小的通知我们称之为窗口通告。</li><li>在早期的TCP协议中，接受接受窗口的大小确实是固定的，不过随着网络的快速发展，固定大小的窗口太不灵活了，成为TCP性能瓶颈之一，也就是说，在现在的TCP协议中，接受窗口的大小是根据某种算法动态调整的。</li><li>接受窗口如果太小的话，显然是不行的，这会严重浪费链路利用率，增加丢包率。那是否越大越好呢？答否，当接收窗口达到某个值的时候，再增大的话也不怎么会减少丢包率的了，而且还会更加消耗内存。所以接收窗口的大小必须根据网络环境以及发送发的的拥塞窗口来<strong>动态调整</strong>。</li><li>接收方在发送确认报文的时候，会告诉发送发自己的接收窗口大小，而发送方的发送窗口会据此来设置自己的发送窗口，但这并不意味着他们就会相等。首先接收方把确认报文发出去的那一刻，就已经在一边处理堆在自己缓存区的数据了，所以一般情况下<strong>接收窗口</strong> &gt;&#x3D; <strong>发送窗口</strong>。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/2022/03/29/technology/%E6%BC%94%E7%A4%BA/"/>
      <url>/2022/03/29/technology/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/16/hello-world/"/>
      <url>/2022/03/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
